declare interface OmegaNumJSON {
    array: number[];
    sign: number;
};

declare type OmegaNumSource = number | string | number[] | OmegaNumJSON | OmegaNum;

declare class OmegaNum {
    static maxArrow: number;
    static serializeMode: number;
    static debug: number;
    static readonly ZERO: OmegaNum;
    static readonly ONE: OmegaNum;
    static readonly E: OmegaNum;
    static readonly LN2: OmegaNum;
    static readonly LN10: OmegaNum;
    static readonly LOG2E: OmegaNum;
    static readonly LOG10E: OmegaNum;
    static readonly PI: OmegaNum;
    static readonly SQRT1_2: OmegaNum;
    static readonly SQRT2: OmegaNum;
    static readonly TWO: OmegaNum;
    static readonly TEN: OmegaNum;
    static readonly MAX_SAFE_INTEGER: OmegaNum;
    static readonly MIN_SAFE_INTEGER: OmegaNum;
    static readonly NaN: OmegaNum;
    static readonly NEGATIVE_INFINITY: OmegaNum;
    static readonly POSITIVE_INFINITY: OmegaNum;
    static readonly E_MAX_SAFE_INTEGER: OmegaNum;
    static readonly EE_MAX_SAFE_INTEGER: OmegaNum;
    static readonly TETRATED_MAX_SAFE_INTEGER: OmegaNum;
    array: number[];
    sign: number;
    abs(): OmegaNum;
    absoluteValue(): OmegaNum;
    static abs(x: OmegaNumSource): OmegaNum;
    static absoluteValue(x: OmegaNumSource): OmegaNum;
    neg(): OmegaNum;
    negate(): OmegaNum;
    static neg(x: OmegaNumSource): OmegaNum;
    static negate(x: OmegaNumSource): OmegaNum;
    cmp(other: OmegaNumSource): number;
    compareTo(other: OmegaNumSource): number;
    static cmp(x: OmegaNumSource, y: OmegaNumSource): number;
    static compare(x: OmegaNumSource, y: OmegaNumSource): number;
    gt(other: OmegaNumSource): boolean;
    greaterThan(other: OmegaNumSource): boolean;
    static gt(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static greaterThan(x: OmegaNumSource, y: OmegaNumSource): boolean;
    gte(other: OmegaNumSource): boolean;
    greaterThanOrEqualTo(other: OmegaNumSource): boolean;
    static gte(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static greaterThanOrEqualTo(x: OmegaNumSource, y: OmegaNumSource): boolean;
    lt(other: OmegaNumSource): boolean;
    lessThan(other: OmegaNumSource): boolean;
    static lt(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static lessThan(x: OmegaNumSource, y: OmegaNumSource): boolean;
    lte(other: OmegaNumSource): boolean;
    lessThanOrEqualTo(other: OmegaNumSource): boolean;
    static lte(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static lessThanOrEqualTo(x: OmegaNumSource, y: OmegaNumSource): boolean;
    eq(other: OmegaNumSource): boolean;
    equal(other: OmegaNumSource): boolean;
    equalsTo(other: OmegaNumSource): boolean;
    static eq(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static equal(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static equalsTo(x: OmegaNumSource, y: OmegaNumSource): boolean;
    neq(other: OmegaNumSource): boolean;
    notEqual(other: OmegaNumSource): boolean;
    notEqualsTo(other: OmegaNumSource): boolean;
    static neq(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static notEqual(x: OmegaNumSource, y: OmegaNumSource): boolean;
    static notEqualsTo(x: OmegaNumSource, y: OmegaNumSource): boolean;
    min(other: OmegaNumSource): OmegaNum;
    minimum(other: OmegaNumSource): OmegaNum;
    static min(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static minimum(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    max(other: OmegaNumSource): OmegaNum;
    maximum(other: OmegaNumSource): OmegaNum;
    static max(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static maximum(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    ispos(): boolean;
    isPositive(): boolean;
    static ispos(x: OmegaNumSource): boolean;
    static isPositive(x: OmegaNumSource): boolean;
    isneg(): boolean;
    isNegative(): boolean;
    static isneg(x: OmegaNumSource): boolean;
    static isNegative(x: OmegaNumSource): boolean;
    isNaN(): boolean;
    static isNaN(x: OmegaNumSource): boolean;
    isFinite(): boolean;
    static isFinite(x: OmegaNumSource): boolean;
    isInfinite(): boolean;
    static isInfinite(x: OmegaNumSource): boolean;
    isint(): boolean;
    isInteger(): boolean;
    static isint(x: OmegaNumSource): boolean;
    static isInteger(x: OmegaNumSource): boolean;
    floor(): OmegaNum;
    static floor(x: OmegaNumSource): OmegaNum;
    ceil(): OmegaNum;
    ceiling(): OmegaNum;
    static ceil(x: OmegaNumSource): OmegaNum;
    static ceiling(x: OmegaNumSource): OmegaNum;
    round(): OmegaNum;
    static round(x: OmegaNumSource): OmegaNum;
    add(otherIn: OmegaNumSource): OmegaNum;
    plus(other: OmegaNumSource): OmegaNum;
    static add(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static plus(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    sub(otherIn: OmegaNumSource): OmegaNum;
    minus(other: OmegaNumSource): OmegaNum;
    static sub(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static minus(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    mul(otherIn: OmegaNumSource): OmegaNum;
    times(other: OmegaNumSource): OmegaNum;
    static mul(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static times(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    div(otherIn: OmegaNumSource): OmegaNum;
    divide(other: OmegaNumSource): OmegaNum;
    static div(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static divide(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    rec(): OmegaNum;
    reciprocate(): OmegaNum;
    static rec(x: OmegaNumSource): OmegaNum;
    static reciprocate(x: OmegaNumSource): OmegaNum;
    mod(otherIn: OmegaNumSource): OmegaNum;
    modular(other: OmegaNumSource): OmegaNum;
    static mod(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static modular(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    gamma(): OmegaNum;
    static gamma(x: OmegaNumSource): OmegaNum;
    static factorials: number[];
    fact(): OmegaNum;
    factorial(): OmegaNum;
    static fact(x: OmegaNumSource): OmegaNum;
    static factorial(x: OmegaNumSource): OmegaNum;
    pow(otherIn: OmegaNumSource): OmegaNum;
    toPower(other: OmegaNumSource): OmegaNum;
    static pow(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static toPower(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    exp(): OmegaNum;
    exponential(): OmegaNum;
    static exp(x: OmegaNumSource): OmegaNum;
    static exponential(x: OmegaNumSource): OmegaNum;
    sqrt(): OmegaNum;
    squareRoot(): OmegaNum;
    static sqrt(x: OmegaNumSource): OmegaNum;
    static squareRoot(x: OmegaNumSource): OmegaNum;
    cbrt(): OmegaNum;
    cubeRoot(): OmegaNum;
    static cbrt(x: OmegaNumSource): OmegaNum;
    static cubeRoot(x: OmegaNumSource): OmegaNum;
    root(otherIn: OmegaNumSource): OmegaNum;
    static root(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    log10(): OmegaNum;
    generalLogarithm(): OmegaNum;
    static log10(x: OmegaNumSource): OmegaNum;
    static generalLogarithm(x: OmegaNumSource): OmegaNum;
    logBase(base?: OmegaNumSource): OmegaNum;
    logarithm(base?: OmegaNumSource): OmegaNum;
    static logBase(x: OmegaNumSource, base?: OmegaNumSource): OmegaNum;
    static logarithm(x: OmegaNumSource, base?: OmegaNumSource): OmegaNum;
    ln(): OmegaNum;
    log(): OmegaNum;
    naturalLogarithm(): OmegaNum;
    static ln(x: OmegaNumSource): OmegaNum;
    static log(x: OmegaNumSource): OmegaNum;
    static naturalLogarithm(x: OmegaNumSource): OmegaNum;
    lambertw(): OmegaNum;
    static lambertw(x: OmegaNumSource): OmegaNum;
    tetr(otherIn: OmegaNumSource, payloadIn?: OmegaNumSource): OmegaNum;
    tetrate(other: OmegaNumSource, payload?: OmegaNumSource): OmegaNum;
    static tetr(x: OmegaNumSource, y: OmegaNumSource, payload?: OmegaNumSource): OmegaNum;
    static tetrate(x: OmegaNumSource, y: OmegaNumSource, payload?: OmegaNumSource): OmegaNum;
    iteratedexp(other: OmegaNumSource, payload?: OmegaNumSource): OmegaNum;
    static iteratedexp(x: OmegaNumSource, y: OmegaNumSource, payload?: OmegaNumSource): OmegaNum;
    iteratedlog(baseIn?: OmegaNumSource, otherIn?: OmegaNumSource): OmegaNum;
    static iteratedlog(x: OmegaNumSource, y?: OmegaNumSource, z?: OmegaNumSource): OmegaNum;
    layeradd(otherIn?: OmegaNumSource, baseIn?: OmegaNumSource): OmegaNum;
    static layeradd(x: OmegaNumSource, y?: OmegaNumSource, z?: OmegaNumSource): OmegaNum;
    layeradd10(other?: OmegaNumSource): OmegaNum;
    static layeradd10(x: OmegaNumSource, y?: OmegaNumSource): OmegaNum;
    ssrt(): OmegaNum;
    ssqrt(): OmegaNum;
    static ssrt(x: OmegaNumSource): OmegaNum;
    static ssqrt(x: OmegaNumSource): OmegaNum;
    slog(baseIn?: OmegaNumSource): OmegaNum;
    static slog(x: OmegaNumSource, y?: OmegaNumSource): OmegaNum;
    pent(other: OmegaNumSource): OmegaNum;
    pentate(other: OmegaNumSource): OmegaNum;
    static pent(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static pentate(x: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    arrow(arrowsIn: OmegaNumSource): ((other: OmegaNumSource) => OmegaNum);
    chain(other: OmegaNumSource, arrows: OmegaNumSource): OmegaNum;
    static arrow(x: OmegaNumSource, z: OmegaNumSource, y: OmegaNumSource): OmegaNum;
    static chain(x: OmegaNumSource, y: OmegaNumSource, z: OmegaNumSource): OmegaNum;
    static hyper(zIn: OmegaNumSource): (x: OmegaNumSource, y: OmegaNumSource) => OmegaNum;
    static affordGeometricSeries(resourcesAvailableIn: OmegaNumSource, priceStartIn: OmegaNumSource, priceRatioIn: OmegaNumSource, currentOwned: OmegaNumSource): OmegaNum;
    static affordArithmeticSeries(resourcesAvailableIn: OmegaNumSource, priceStartIn: OmegaNumSource, priceAddIn: OmegaNumSource, currentOwnedIn: OmegaNumSource): OmegaNum;
    static sumGeometricSeries(numItems: OmegaNumSource, priceStartIn: OmegaNumSource, priceRatioIn: OmegaNumSource, currentOwned: OmegaNumSource): OmegaNum;
    static sumArithmeticSeries(numItemsIn: OmegaNumSource, priceStartIn: OmegaNumSource, priceAdd: OmegaNumSource, currentOwnedIn: OmegaNumSource): OmegaNum;
    static choose(n: OmegaNumSource, k: OmegaNumSource): OmegaNum;
    choose(other: OmegaNumSource): OmegaNum;
    standardize(): this;
    toNumber(): number;
    toString(): string;
    toStringWithDecimalPlaces(places: number, applyToOpNums: boolean): string;
    toExponential(places: number, applyToOpNums: boolean): string;
    toFixed(places: number, applyToOpNums: boolean): string;
    toPrecision(places: number, applyToOpNums: boolean): string;
    valueOf(): string;
    toJSON(): string | OmegaNumJSON;
    toHyperE(): string;
    static fromNumber(input: number): OmegaNum;
    static fromString(input: string): OmegaNum;
    static fromArray(input1: number[], input2?: number): OmegaNum;
    static fromArray(input1: number, input2: number[]): OmegaNum;
    static fromObject(input: number[] | OmegaNumJSON | OmegaNum): OmegaNum;
    static fromJSON(input: string | OmegaNumJSON): OmegaNum;
    static fromHyperE(input: string): OmegaNum;
    clone(): OmegaNum;
    constructor(input?: OmegaNumSource, input2?: undefined);
    constructor(input: number, input2: number[]);
    static readonly JSON = 0;
    static readonly STRING = 1;
    static readonly NONE = 0;
    static readonly NORMAL = 1;
    static readonly ALL = 2;
    static config(obj: Record<string, number>): typeof OmegaNum;
    static get default(): typeof OmegaNum;
    static get OmegaNum(): typeof OmegaNum;
    static set(obj: Record<string, number>): void;
}