<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Our World of Text</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAHdElNRQfhCh4FGBfsuYX/AAAAGXRFWHRTb2Z0d2FyZQBwYWludC5uZXQgNC4wLjIx8SBplQAAAXFJREFUWEftkztOA0EQRH0O58Sk3MBkcAAyQgISchIkDkFMzik4BAE5l8CorHlyedQ9HyzYxCWVdmemuvtp1l4tru3351Yuy/+Xhj9fXy0HsTiA5BA9l5JUs/mdFATg6e6maW8eOcuXUbEUEAAQXx9vqesBtbN8CqGD9eZyFxiFiPz++hju4xSiBrg/u5gGYHgLYgqAWxhpPJLBIQQAahBBRI1mrL64eQsyg/XkU/yFy9hDcchwh9AN1Y726dGqaf4jJB3WAJgmvbXv15kugKRABEEzfVvW0V62lqdvoAfAma99n/fuD9GlwCiAm5xneapmGEBSKIKgma9HrBp5CkB2AJoc6yYEg2Wu7zcAfPPojL5l5F4MdQOwWZ9PQTiAg+g9BGD4y8PtgbWv4XgGwg2Qeh4NQLNZp8OlCIC1Q0QAytR77rpnCCABgb0QCD1plNnrMGfpcKRADeLF/p7Za+p8GdOXN4xcYqFm8yedtKBWqx9ASySa1Ve81QAAAABJRU5ErkJggg==">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta name="description" content="Offline OWOT 6.0">
    <style>
* {
  margin: 0;
  padding: 0;
}
html, body {
  overflow: hidden;
  width: 100%;
  height: 100%;
  overscroll-behavior: contain;
  touch-action: pan-down;
}
.screen_canvas {
  overflow: hidden;
}
body {
  background: #ccc;
}
img {
  border: 0;
  text-decoration: none;
}
a,
a:link,
a:hover,
a:active,
a:visited {
  text-decoration: none;
  color: inherit;
}
.announce_text {
  text-align: center;
  margin-right: 3px;
  background-color: rgb(181 181 241);
  border-radius: 5px;
  color: #525252;
  padding-left: 7px;
  padding-right: 7px;
  font-weight: bold;
}
.announce_text > a {
  text-decoration: underline;
  color: blue;
}
.announce_text > a:hover {
  color: #f1d94a;
}
#topbar {
  position: absolute;
  top: 0;
  width: 100%;
}
#topbar_inner {
  width: 100%;
  position: absolute;
}
#announce_container {
  text-align: center;
}
.announce_close {
  font-size: 11px;
  font-weight: bold;
  color: #636060;
  background-color: #C5C2C2;
  border-radius: 2px;
  padding: 0 3px;
  position: relative;
  z-index: 1;
}
.announce_close:hover {
  background: #928E8E;
  color: white;
  cursor: pointer;
}
.ui {
  color: #888;
  font-family: Verdana;
  font-size: 12px;
  z-index: 100;
}
.ui-vis {
  background-color: rgba(0, 0, 255, .1);
  padding: 2px;
}
.tab {
  padding-top: 0;
  top: 0px;
  position: absolute;
}
.message {
  margin-left: auto;
  margin-right: auto;
  padding: 5px 0px;
  width: 60%;
  text-align: center;
  background: #E5E5FF;
  color: #333;
}
.message a {
  color: blue;
}
#loading {
  font-family: Verdana;
}
#coords {
  position: absolute;
  bottom: 0;
  right: 0;
  color: #555;
  background: #E5E5FF;
  cursor: pointer;
}
.menu {
  right: 0;
}
#menu {
  cursor: pointer;
}
#menu.hover {
  color: #555;
  background: #E5E5FF;
  border-left: 1px solid #ccc;
}
#nav {
  position: absolute;
  text-align: right;
  top: 1.5em;
  background: #E5E5FF;
  width: 8em;
  color: #555;
  border-left: 1px solid #ccc;
  border-bottom: 1px solid #ccc;
  overflow: hidden;
  max-height: 100%;
}
#nav li {
  display: block;
  list-style: none;
  position: relative;
  cursor: pointer;
  border-top: 1px solid #ccc;
}
#nav li:first-child {
  border-top: 0;
}
#nav a {
  display: block;
}
* html #nav ul {
  line-height: 0;
}
#nav li.hover {
  background-color: white;
}
#goto_submit {
  margin-left: 1em;
  margin-top: 3px;
}
#west_gui {
  position: absolute;
  top: 30px;
  left: 0px;
}
#protect_precision {
  background-color: #626262;
  color: white;
  padding: 4px;
  margin-bottom: 3px;
  display: inline-block;
}
#protect_selection {
  display: block;
  text-decoration: underline;
  color: white;
  text-align: center;
  cursor: pointer;
}
#protect_selection:hover {
  color: #F3DB65;
}
#protect_selection:active {
  color: #917c17;
}
#char_choice {
  margin-left: 14px;
}
.protect_button {
  border: solid 1px white;
  text-align: center;
  cursor: pointer;
  min-width: 40px;
  display: inline-block;
}
.auto_prog_panel {
  width: 150px;
  height: 30px;
  background-color: rgb(104, 104, 104);
  text-align: center;
  color: white;
}
#chat_open {
  position: absolute;
  bottom: 0px;
  left: 0px;
  width: 70px;
  text-align: center;
  background-color: #003399;
  color: white;
  height: 20px;
  border-style: solid;
  border-width: 1px;
  border-color: #000033;
  cursor: default;
}
#chat_open:hover {
  background-color: #2763dc;
}
#chat_open:active {
  background-color: #0e2961;
}
#usr_online {
  padding-left: 16px;
  display: inline-block;
  cursor: default;
  user-select: none;
}
#chatsend {
  padding: 1px 6px 1px 6px;
}
.chat_tab_button {
  height: 20px;
  border: solid 1px black;
  text-align: center;
  font-family: Verdana;
  font-size: 13px;
  cursor: default;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-right: 3px;
}
.chat_tab_selected {
  background-color: #8C8C8C;
  color: white;
}
#chat_page_tab {
  width: 100px;
}
#chat_global_tab {
  width: 80px;
}
.chatfield {
  border: solid 1px black;
  background-color: white;
  overflow: scroll;
  overflow-x: hidden;
  overflow-wrap: break-word;
  margin: 3px;
  margin-bottom: 0px;
  height: 100%;
  padding: 2px;
  contain: strict;
}
.chatfield > div {
  overflow: hidden;
}
.unread_bar {
  background-color: red;
  width: 100%;
  height: 2px;
  margin-top: 6px;
  margin-bottom: 6px;
  text-align: center;
}
.unread_bar_msg {
  background-color: white;
  position: relative;
  top: -8px;
  padding-left: 3px;
  padding-right: 3px;
  font-family: Verdana;
  font-size: 0.7em;
  color: red;
}
.unread {
  color: red;
  font-size: 11px;
}
#total_unread {
  font-size: 15px;
}
#chat_window {
  position: absolute;
  background-color: #e0e0e0;
  border: solid 1px black;
  display: flex;
  flex-flow: column;
}
#chat_close {
  background-color: red;
  width: 20px;
  height: 20px;
  text-align: center;
  color: white;
  border: solid 1px black;
  font-family: monospace;
  font-size: 16px;
  cursor: default;
  float: right;
}
#confirm_js {
  width: 441px;
  height: 256px;
  position: absolute;
  background-color: #dbdbdb;
  border-width: 2px;
  border-style: solid;
  border-color: black;
}
#confirm_js_code {
  background-color: #e6e6e6;
  position: absolute;
  width: 365px;
  height: 110px;
  top: 90px;
  left: 35px;
  padding: 3px;
  font-family: "Courier New", monospace;
  word-wrap: break-word;
  word-break: break-all;
  overflow: scroll;
  overflow-x: hidden;
}
#confirm_js_cancel {
  position: absolute;
  font-family: Helvetica;
  background-color: #7c7c7c;
  border-style: solid;
  width: 80px;
  height: 17px;
  top: 220px;
  left: 340px;
  border-width: 1px;
  padding: 2px;
  text-align: center;
  font-size: 15px;
  color: white;
  border-color: black;
  cursor: pointer;
}
#confirm_js_cancel_x {
  background-color: red;
  width: 20px;
  height: 20px;
  position: absolute;
  right: 3px;
  top: 2px;
  text-align: center;
  color: white;
  font-family: monospace;
  font-size: 16px;
  border-style: solid;
  border-width: 1px;
  border-color: black;
  cursor: pointer;
}
#confirm_js_msg {
  text-align: center;
  position: absolute;
  left: 20px;
  font-family: verdana;
  top: 40px;
}
#confirm_js_cancel:hover {
  background-color: #979797;
}
#run_js_confirm {
  position: absolute;
  color: blue;
  text-decoration: underline;
  top: 220px;
  left: 20px;
}
.region_selection {
  position: absolute;
  border: 1px solid black;
  pointer-events: none;
}
#area_results {
  width: 100%;
  height: 200px;
  white-space: pre;
  overflow: auto;
  overflow-x: scroll;
}
#link_element {
  position: absolute;
  display: block;
}
#owot {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAAAAACMmsGiAAAAAklEQVR4AewaftIAAAAYSURBVAXBgQAAAADDoPsDRTWI14pFo6YcgrQNEaFuVVoAAAAASUVORK5CYII="); /* (MOD) */
  background-repeat: repeat;
}
#owot.nightmode {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEAQMAAACTPww9AAAABlBMVEVJSUkTExPF/tKBAAAAEElEQVQI12M4wDCBwYAhAQAJCAHhHe5F/AAAAABJRU5ErkJggg=="); /* (MOD) */
}
#zoombar {
  width: 100%;
}
.color_btn {
  background-color: black;
  width: 16px;
  height: 16px;
  border-radius: 4px;
  border: solid 1px black;
  display: inline-block;
  font-weight: bold;
  font-family: verdana;
  text-align: center;
  cursor: default;
  font-size: 0.8em;
  overflow: hidden;
  margin: 3px;
  user-select: none;
  vertical-align: top;
}
.color_btn:hover {
  border-color: orange;
}
.color_btn:active {
  border-color: rgb(165, 107, 0);
}
#color_btn_no_cell {
  background: linear-gradient(to right top, white 47.75%, red 49.5%, red 55%, white 50%);
}
.modal_corner_checkbox_label {
  margin-left: 5px;
  user-select: none;
  white-space: nowrap;
}
#modal_overlay {
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  cursor: default;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}
.modal_close {
  position: absolute;
  right: 0px;
  bottom: 0px;
  margin-right: 8px;
  margin-bottom: 8px;
  color: blue;
  text-decoration: underline;
  cursor: pointer
}
.modal_frame {
  background-color: #C3C3FF;
}
.modal_client {
  background-color: #E5E5FF;
}
.modal-tab-btn {
  background-color: rgb(178 178 231);
}
.modal-tab-btn:hover {
  background-color: rgb(212 212 235);
}
.chat_emote {
  background: url("data:image/png;base64,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"); /* (MOD) */
  height: 1em;
  vertical-align: middle;
  display: inline-block;
}
#text_decorations {
  background-color: #E5E5FF;
  padding: 3px;
  margin-bottom: 3px;
  display: inline-flex;
}
.text_deco_btn {
  width: 32px;
  height: 32px;
  text-align: center;
  display: inline-block;
  font-size: 28px;
  user-select: none;
  font-family: Arial, Verdana;
}
.text_deco_btn:hover {
  background-color: #CDCDFF;
}
#text_deco_b {
  font-weight: bold;
}
#text_deco_i {
  font-style: italic;
}
#text_deco_u {
  text-decoration: underline;
}
#text_deco_s {
  text-decoration: line-through;
}
.menuPin {
  width: 12px;
  height: 12px;
}
    </style>
    <style>
/* (EXT) */
/* Force file picker to be hidden, but be interactable */
#import_world {
  cursor: pointer;
  position: absolute;
  top: 0;
  right: 0;
  opacity: 0;
  -moz-opacity: 0;
  filter: progid:DXImageTransform.Microsoft.Alpha(opacity=0);
}
    </style>
  </head>
  <body>
    <div id="main_view">
      <canvas id="owot" class="screen_canvas" style="display: none;"></canvas>
    </div>
    <a href="javascript: void 0;" id="link_element" title="Link to url..." target="_blank" style="cursor: pointer;">
      <div id="link_div"></div>
    </a>
    <div id="topbar" class="ui">
      <div id="topbar_inner">
        <div id="announce_container"></div>
        <span id="menu" class="ui-vis tab menu" style="display: none;">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsAAAA7AAWrWiQkAAABWSURBVChTY2QAgtDQUBBFFGCC0kQDmmj4D6XBAKYBJOgHxPJoeB8QowCYp1FMwQLA6kCAZp4GuQCMidUAchIYU+QkfyBWQMP7gRgFEJM0QG6HhhIDAwBHgQ0nu8eENgAAAABJRU5ErkJggg==" class="menuPin" style="display: none;">
          <span class="menuText">Menu</span>
          <span style="font-size:50%">▼</span>
        </span>
      </div>
    </div>
    <div id="nav" class="ui menu ui-vis" style="display: none;">
      <ul></ul>
    </div>
    <div id="coords" class="ui ui-vis" style="display: none;">
      X: <span id="coord_X"></span>
      Y: <span id="coord_Y"></span>
      <div id="cursor_coords" style="display: none;">
        Cursor:
        <span id="cursor_on" style="display: none;">
          <span id="tile_X"></span>, <span id="tile_Y"></span> /
          <span id="char_X"></span>, <span id="char_Y"></span>
        </span>
        <span id="cursor_off" style="display: none">
          N/A
        </span>
      </div>
    </div>

    <div id="modal_overlay" style="display: none;"></div>

    <h1 id="loading">Loading...</h1>
    <div style="display:none"><input type="hidden" name="csrfmiddlewaretoken" value="abcd0123" /></div>
    <script>
      var state = {"userModel":{"username":"user","is_superuser":true,"authenticated":true,"is_member":true,"is_owner":true,"is_staff":true,"is_operator":true},"worldModel":{"feature_membertiles_addremove":true,"writability":0,"feature_url_link":0,"feature_go_to_coord":0,"name":"","feature_paste":0,"readability":0,"feature_coord_link":0,"pathname":"","chat_permission":0,"color_text":0,"color_cell":1,"show_cursor":-1,"char_rate":[20480,1000],"write_interval":1000,"no_chat_global":false}};
    </script>

    <textarea autocapitalize="off" autocorrect="off" autocomplete="off" style="left: -1000px; top: -1000px; position: absolute;" id="textInput"></textarea>

    <div id="west_gui">
      <div id="text_decorations" style="display: none">
        <div class="text_deco_btn" id="text_deco_b" title="Bold">A</div>
        <div class="text_deco_btn" id="text_deco_i" title="Italic">A</div>
        <div class="text_deco_btn" id="text_deco_u" title="Underline">A</div>
        <div class="text_deco_btn" id="text_deco_s" title="Strikethrough">A</div>
      </div>
      <br>
      <div id="protect_precision" style="display: none;">
        <div style="padding-bottom: 3px;">
          Protect type:
        </div>
        <div class="protect_button" id="tile_choice" onclick="protectPrecisionOption(0);">
          Tile
        </div>
        <div class="protect_button" id="char_choice" onclick="protectPrecisionOption(1);">
          Char
        </div>
        <a id="protect_selection" onclick="protectSelection();">Select</a>
      </div>
      <div id="auto_prog" class="auto_prog_panel" style="display: none"></div>
    </div>

    <div id="chat_open" style="display: none;">
      <span>Chat&nbsp;<b id="total_unread" class="unread" style="display: none;">(-)</b></span>
    </div>
    <div id="chat_window" style="width: 400px; height: 300px; bottom: 0px; left: 0px; display: none;">
      <div id="chat_upper" style="padding: 3px; padding-bottom: 0px;">
        <div class="chat_tab_button chat_tab_selected" id="chat_page_tab">
          This page&nbsp;<b id="page_unread" class="unread" style="display: none;">(-)</b>
        </div><div class="chat_tab_button" id="chat_global_tab">
          Global&nbsp;<b id="global_unread" class="unread" style="display: none;">(-)</b>
        </div>
        <span id="usr_online"></span>
        <div id="chat_close">X</div>
      </div>
      <div class="chatfield" id="page_chatfield"></div>
      <div class="chatfield" id="global_chatfield" style="display: none;"></div>
      <div id="chat_lower" style="width: 100%; display: flex;">
        <input style="width: 100%; margin: 3px; margin-right: 0px;" id="chatbar" autocomplete="off" aria-autocomplete="list">
        <button id="chatsend" style="margin: 3px;">Send</button>
      </div>
    </div>
    <div id="confirm_js" style="display: none; top: 50px; left: 100px;">
      <a href="javascript:void 0;" id="run_js_confirm">run</a>
      <span id="confirm_js_msg">
        --
      </span>
      <span id="confirm_js_code">
        --
      </span>
      <div id="confirm_js_cancel">
        Close
      </div>
      <div id="confirm_js_cancel_x">
        X
      </div>
    </div>

    <script>
/*
(MOD) = modified
(EXT) = extra script
*/
    
// (EXT)
var tile_database = {};
var server_start = Date.now();

function uptime(custom_ms_ago) {
  // (milliseconds ago)
  var difference = custom_ms_ago || (Date.now() - server_start);

  var str = "";

  var days = Math.floor(difference / 86400000);
  difference -= days * 86400000;
  var hours = Math.floor(difference / 3600000);
  difference -= hours * 3600000;
  var minutes = Math.floor(difference / 60000);
  difference -= minutes * 60000;
  var seconds = Math.floor(difference / 1000);
  difference -= seconds * 1000;

  if(days > 0) {
    if(str) str += ", ";
    str += days + " day" + (days != 1 ? "s" : "");
  }
  if(hours > 0) {
    if(str) str += ", ";
    str += hours + " hour" + (hours != 1 ? "s" : "");
  }
  if(minutes > 0) {
    if(str) str += ", ";
    str += minutes + " minute" + (minutes != 1 ? "s" : "");
  }
  if(seconds > 0) {
    if(str) str += ", ";
    str += seconds + " second" + (seconds != 1 ? "s" : "");
  }

  return str;
}

var command_list = [
  [3, "uptime", null, "get uptime of server", null],
  [0, "help", null, "list all commands", null],
  [0, "nick", ["nickname"], "change your nickname", "JohnDoe"], // client-side
  [0, "ping", null, "check the latency", null],
  [0, "gridsize", ["WxH"], "change the size of cells", "10x20"], // client-side
  [0, "color", ["color code"], "change your text color", "#FF00FF"], // client-side
  [0, "chatcolor", ["color code"], "change your chat color", "#FF00FF"], // client-side
  [0, "night", null, "enable night mode", null], // client-side
  [0, "day", null, "disable night mode", null], // client-side
  [0, "whoami", null, "display your identity"],
  [0, "test", null, "preview your appearance"],
  
  [0, "search", ["phrase"], "search for a phrase"] // for offlineOWOT
];

function generate_command_list() {
  var list = [];
  for(var i = 0; i < command_list.length; i++) {
    var command = command_list[i];
    var rank = command[0];
    list.push(command);
  }

  // sort the command list
  list.sort(function(v1, v2) {
    return v1[1].localeCompare(v2[1], "en", { sensitivity: "base" });
  });

  var html = "";
  html += "Command list:<br>";
  html += "<div style=\"background-color: #DADADA; font-family: monospace; font-size: 13px;\">";
  var cmdIdx = 0;
  for(var i = 0; i < list.length; i++) {
    var row = list[i];
    var command = row[1];
    var args = row[2];
    var desc = row[3];
    var example = row[4];

    // display arguments for this command
    var arg_desc = "";
    if(args) {
      arg_desc += html_tag_esc("<");
      for(var v = 0; v < args.length; v++) {
        var arg = args[v];
        arg_desc += "<span style=\"font-style: italic\">" + html_tag_esc(arg) + "</span>";
        if(v != args.length - 1) {
          arg_desc += ", ";
        }
      }
      arg_desc += html_tag_esc(">");
    }

    var exampleElm = "";
    if(example && args) {
      exampleElm = "title=\"" + html_tag_esc("Example: /" + command + " " + example) +"\"";
    }

    command = "<span " + exampleElm + "style=\"color: #00006F\">" + html_tag_esc(command) + "</span>";

    var help_row = html_tag_esc("-> /") + command + " " + arg_desc + " :: " + html_tag_esc(desc);

    // alternating stripes
    if(cmdIdx % 2 == 1) {
      help_row = "<div style=\"background-color: #C3C3C3\">" + help_row + "</div>";
    }

    html += help_row;
    cmdIdx++;
  }

  html += "</div>";

  return html;
}

function SimulatedServerSocket() {
  var self = this;
  this.cli_id = Math.floor(Math.random() * 9999) + 1;
  this.cli_channel = "";
  this.readyState = 0;
  for(var i = 0; i < 14; i++) {
    this.cli_channel += "0123456789abcdef"[Math.floor(Math.random() * 16)];
  }
  this.send = function(data) {
    setTimeout(function() {
      data = JSON.parse(data);
      if(data.kind == "ping") {
        self.onmessage({
          data: JSON.stringify({
            kind: "ping",
            result: "pong",
            id: data.id
          })
        });
      }
      if(data.kind == "fetch") {
        var fr = data.fetchRectangles;
        var resp = {
          kind: "fetch",
          tiles: {}
        };
        for(var i = 0; i < fr.length; i++) {
          var rect = fr[i];
          var x1 = rect.minX;
          var y1 = rect.minY;
          var x2 = rect.maxX;
          var y2 = rect.maxY;
          for(var y = y1; y <= y2; y++) {
            for(var x = x1; x <= x2; x++) {
              var tile = tile_database[y + "," + x];
              if(!tile) tile = null;
              resp.tiles[y + "," + x] = tile;
            }
          }
        }
        self.onmessage({
          data: JSON.stringify(resp)
        });
      }
      if(data.kind == "write") {
        var edits = data.edits;
        var editedTiles = {};
        var accepted = [];
        for(var i = 0; i < edits.length; i++) {
          var edit = edits[i];
          var tileY = edit[0];
          var tileX = edit[1];
          var charY = edit[2];
          var charX = edit[3];
          var time = edit[4];
          var char = edit[5];
          var id = edit[6];
          var color = edit[7];
          var bgcolor = edit[8];
          var tile = tile_database[tileY + "," + tileX];
          if(!tile) {
            tile_database[tileY + "," + tileX] = {
              content: " ".repeat(128),
              properties: {
                cell_props: {},
                writability: null
              }
            };
            tile = tile_database[tileY + "," + tileX];
          }
          if(tile.properties.cell_props && tile.properties.cell_props[charY]) {
            if(tile.properties.cell_props[charY][charX]) {
              tile.properties.cell_props[charY][charX] = {};
            }
          }
          editedTiles[tileY + "," + tileX] = 1;
          var con = advancedSplit(tile.content);
          con[charY * 16 + charX] = char;
          tile.content = con.join("");
          if(!color) color = 0;
          if(bgcolor == null) bgcolor = -1;
          if(!tile.properties.color) {
            tile.properties.color = new Array(128).fill(0);
          }
          if(!tile.properties.bgcolor && bgcolor > -1) {
            tile.properties.bgcolor = new Array(128).fill(-1);
          }
          tile.properties.color[charY * 16 + charX] = color;
          if(tile.properties.bgcolor) {
            tile.properties.bgcolor[charY * 16 + charX] = bgcolor;
          }
          accepted.push(id);
        }
        var dataResp = {
          channel: self.cli_channel,
          kind: "tileUpdate",
          source: "write",
          tiles: {}
        };
        for(var i in editedTiles) {
          dataResp.tiles[i] = tile_database[i];
        }
        self.onmessage({
          data: JSON.stringify(dataResp)
        });
        self.onmessage({
          data: JSON.stringify({
            accepted: accepted,
            rejected: {},
            kind: "write"
          })
        });
      }
      if(data.kind == "link") {
        var ldata = data.data;
        var type = data.type;
        var tileX = ldata.tileX;
        var tileY = ldata.tileY;
        var charX = ldata.charX;
        var charY = ldata.charY;
        var url = ldata.url;
        var link_tileX = ldata.link_tileX;
        var link_tileY = ldata.link_tileY;
        var tile = tile_database[tileY + "," + tileX];
        if(!tile) {
          tile_database[tileY + "," + tileX] = {
            content: " ".repeat(128),
            properties: {
              cell_props: {},
              writability: null
            }
          };
          tile = tile_database[tileY + "," + tileX];
        }
        var cell_props = tile.properties.cell_props;
        if(!cell_props[charY]) {
          cell_props[charY] = {};
        }
        if(!cell_props[charY][charX]) {
          cell_props[charY][charX] = {};
        }
        cell_props[charY][charX] = {
          link: {
            type: type
          }
        };
        var lobj = cell_props[charY][charX].link;
        if(type == "url") {
          lobj.url = url;
        }
        if(type == "coord") {
          lobj.link_tileX = link_tileX;
          lobj.link_tileY = link_tileY;
        }
        self.onmessage({
          data: JSON.stringify({
            channel: self.cli_channel,
            kind: "tileUpdate",
            source: "write",
            tiles: {
              [tileY + "," + tileX]: tile
            }
          })
        });
      }
      if(data.kind == "protect") {
        var pdata = data.data;
        var action = data.action;
        var tileX = pdata.tileX;
        var tileY = pdata.tileY;
        var charX = pdata.charX;
        var charY = pdata.charY;
        var charWidth = pdata.charWidth;
        var charHeight = pdata.charHeight;
        if(!charWidth) charWidth = 1;
        if(!charHeight) charHeight = 1;
        var precise = pdata.precise;
        var type = pdata.type;
        var tile = tile_database[tileY + "," + tileX];
        if(!tile) {
          tile_database[tileY + "," + tileX] = {
            content: " ".repeat(128),
            properties: {
              cell_props: {},
              writability: null
            }
          };
          tile = tile_database[tileY + "," + tileX];
        }
        if(precise) {
          var pchardata = tile.properties.char;
          if(pchardata) {
            pchardata = decodeCharProt(pchardata);
          } else {
            pchardata = new Array(128).fill(null);
          }
          
          for(var y = 0; y < charHeight; y++) {
            for(var x = 0; x < charWidth; x++) {
              var cx = charX + x;
              var cy = charY + y;
              if(action == "protect") {
                var protVal = null;
                if(type == "owner-only") {
                  protVal = 2;
                } else if(type == "member-only") {
                  protVal = 1;
                } else if(type == "public") {
                  protVal = 0;
                }
                pchardata[cy * 16 + cx] = protVal;
              } else if(action == "unprotect") {
                if(tile.properties.writability == null) {
                  pchardata[cy * 16 + cx] = null;
                } else {
                  for(var a = 0; a < pchardata.length; a++) {
                    if(pchardata[a] == null) {
                      pchardata[a] = tile.properties.writability;
                    }
                  }
                  tile.properties.writability = null;
                  pchardata[cy * 16 + cx] = null;
                }
              }
            }
          }
          
          tile.properties.char = encodeCharProt(pchardata);
        } else {
          delete tile.properties.char;
          if(action == "protect") {
            if(type == "owner-only") {
              tile.properties.writability = 2;
            } else if(type == "member-only") {
              tile.properties.writability = 1;
            } else if(type == "public") {
              tile.properties.writability = 0;
            }
          } else if(action == "unprotect") {
            tile.properties.writability = null;
          }
        }
        self.onmessage({
          data: JSON.stringify({
            channel: self.cli_channel,
            kind: "tileUpdate",
            source: "write",
            tiles: {
              [tileY + "," + tileX]: tile
            }
          })
        });
      }
      if(data.kind == "clear_tile") {
        var tileX = data.tileX;
        var tileY = data.tileY;
        var tile = tile_database[tileY + "," + tileX];
        if(!tile) return;
        tile.content = " ".repeat(128);
        tile.properties.cell_props = {};
        delete tile.properties.color;
        delete tile.properties.bgcolor;
        self.onmessage({
          data: JSON.stringify({
            kind: "tileUpdate",
            source: "write",
            tiles: {
              [tileY + "," + tileX]: tile
            }
          })
        });
      }
      if(data.kind == "chat") {
        var msg = data.message;
        if(msg == "/help") {
          self.onmessage({
            data: JSON.stringify({
              nickname: "[ Server ]",
              realUsername: "[ Server ]",
              id: 0,
              message: generate_command_list(),
              registered: true,
              location: data.location,
              op: true,
              admin: true,
              staff: true,
              color: "",
              kind: "chat"
            })
          });
        } else if(msg == "/uptime") {
          self.onmessage({
            data: JSON.stringify({
              nickname: "[ Server ]",
              realUsername: "[ Server ]",
              id: 0,
              message: "Server uptime: " + uptime(),
              registered: true,
              location: data.location,
              op: true,
              admin: true,
              staff: true,
              color: "",
              kind: "chat"
            })
          });
        } else if(msg == "/whoami") {
          self.onmessage({
            data: JSON.stringify({
              nickname: data.nickname,
              realUsername: "user",
              id: self.cli_id,
              message: `Who Am I:<br>Login username: user<br>Display username: user<br>Chat ID: ${self.cli_id}`,
              registered: true,
              location: data.location,
              op: true,
              admin: true,
              staff: true,
              color: data.color,
              kind: "chat"
            })
          });
        } else if(msg == "/test") {
          self.onmessage({
            data: JSON.stringify({
              nickname: data.nickname,
              realUsername: "user",
              id: self.cli_id,
              message: "This message is visible to only you.",
              registered: true,
              location: data.location,
              op: true,
              admin: true,
              staff: true,
              color: data.color,
              kind: "chat"
            })
          });
        } else {
          self.onmessage({
            data: JSON.stringify({
              nickname: data.nickname,
              realUsername: "user",
              id: self.cli_id,
              message: data.message,
              registered: true,
              location: data.location,
              op: true,
              admin: true,
              staff: true,
              color: data.color,
              kind: "chat"
            })
          });
        }
      }
    }, 1);
  }
  this.close = function() {
    this.onclose();
  }
  setTimeout(function() {
    self.readyState = WebSocket.OPEN;
    self.onopen();
    self.onmessage({
      data: JSON.stringify({
        kind: "channel",
        sender: self.cli_channel,
        id: self.cli_id,
        initial_user_count: 1
      })
    });
  }, 1);
  return this;
}
    </script>
    <script>
    // (EXT)
    // The Legacy Computing Symbols Font
var lcsFont = [
"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"].join("");

lcsFont = atob(lcsFont);
var lcsBytes = new Array(lcsFont.length);
for(var i = 0; i < lcsFont.length; i++) {
  lcsBytes[i] = lcsFont.charCodeAt(i);
}
lcsBytes = new Uint8Array(lcsBytes);
var lcsBlob = new Blob([lcsBytes], {
  type: "font/woff2"
});
lcsBytes = null;
var lcsURL = URL.createObjectURL(lcsBlob);
    </script>
    <script>
if(!window.WebSocket && window.MozWebSocket) {
  window.WebSocket = window.MozWebSocket;
}

function assert(exp, optMsg) {
  if(!exp) {
    throw new Error(optMsg || "Assertion failed");
  }
}

function intmax(ints) {
  if(typeof ints == "number") ints = [ints];
  for(var i = 0; i < ints.length; i++)
    if(ints[i] > Number.MAX_SAFE_INTEGER || ints[i] < Number.MIN_SAFE_INTEGER) return false;
  return true;
}

function clipIntMax(x) {
  if(x < Number.MIN_SAFE_INTEGER) x = Number.MIN_SAFE_INTEGER;
  if(x > Number.MAX_SAFE_INTEGER) x = Number.MAX_SAFE_INTEGER;
  return x;
}

function closest(element, parElement) {
  var currentElm = element;
  while(currentElm) {
    if(currentElm == parElement) return true;
    currentElm = currentElm.parentNode;
  }
  return false;
}

function getQuerystring(search) {
  var res = {};
  if(!search || typeof search != "string") return res;
  if(search[0] == "?") search = search.slice(1);
  search = search.split("&");
  for(var i = 0; i < search.length; i++) {
    var data = search[i].split("=");
    if(data.length < 2) continue;
    var key = data[0].trim();
    var value = data[1].trim();
    res[key] = value;
  }
  return res;
}

function lineGen(x0, y0, x1, y1, max) {
  if(!max) max = 2000;
  var list = [];
  var x0 = Math.floor(x0);
  var y0 = Math.floor(y0);
  var x1 = Math.floor(x1);
  var y1 = Math.floor(y1);
  var dx = Math.abs(x1 - x0);
  var dy = Math.abs(y1 - y0);
  var sx = (x0 < x1) ? 1 : -1;
  var sy = (y0 < y1) ? 1 : -1;
  var err = dx - dy;
  for(var i = 0; i < max; i++) {
    list.push([x0, y0]);
    if((x0 == x1) && (y0 == y1)) break;
    var e2 = 2 * err;
    if(e2 > -dy) {
      err -= dy;
      x0 += sx;
    }
    if(e2 < dx) {
      err += dx;
      y0 += sy;
    }
  }
  return list;
}

function getDistance(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

function orderRangeABCoords(coordA, coordB) {
  var tmp;
  if(coordA[0] > coordB[0]) {
    // swap X coords
    tmp = coordA[0];
    coordA[0] = coordB[0];
    coordB[0] = tmp;
    tmp = coordA[2];
    coordA[2] = coordB[2];
    coordB[2] = tmp;
  } else if(coordA[0] == coordB[0] && coordA[2] > coordB[2]) {
    // swap X char coords
    tmp = coordA[2];
    coordA[2] = coordB[2];
    coordB[2] = tmp;
  }
  if(coordA[1] > coordB[1]) {
    // swap Y coords
    tmp = coordA[1];
    coordA[1] = coordB[1];
    coordB[1] = tmp;
    tmp = coordA[3];
    coordA[3] = coordB[3];
    coordB[3] = tmp;
  } else if(coordA[1] == coordB[1] && coordA[3] > coordB[3]) {
    // swap Y char coords
    tmp = coordA[3];
    coordA[3] = coordB[3];
    coordB[3] = tmp;
  }
}

function ajaxRequest(settings) {
  var req = new XMLHttpRequest();

  var formData = "";
  var ampAppend = false;
  if(settings.data) {
    for(var i in settings.data) {
      if(ampAppend) formData += "&";
      ampAppend = true;
      formData += encodeURIComponent(i) + "=" + encodeURIComponent(settings.data[i]);
    }
  }
  // append form data to url if this is a GET
  if(settings.type == "GET" && formData) {
    settings.url += "?" + formData;
  }
  var async = !!settings.async;
  req.open(settings.type, settings.url, !async);
  req.onload = function() {
    if(req.status >= 200 && req.status < 400) {
      if(settings.done) {
        settings.done(req.responseText, req);
      }
    } else {
      if(settings.error) {
        settings.error(req);
      }
    }
  }
  req.onerror = function() {
    if(settings.error) {
      settings.error(req);
    }
  }
  if(settings.type == "POST") {
    if(formData) req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    req.send(formData);
  } else {
    req.send();
  }
}

function removeAlpha(data) {
  var res = [];
  var len = data.length / 4;
  for(var i = 0; i < len; i++) {
    var indx = i * 4;
    res.push(data[indx + 0]);
    res.push(data[indx + 1]);
    res.push(data[indx + 2]);
  }
  return res;
}

function getRange(x1, y1, x2, y2) {
  var tmp;
  if(x1 > x2) {
    tmp = x1;
    x1 = x2;
    x2 = tmp;
  }
  if(y1 > y2) {
    tmp = y1;
    y1 = y2;
    y2 = tmp;
  }

  assert(intmax([x1, y1, x2, y2]), "Invalid ranges");

  var coords = [];
  for(var y = y1; y <= y2; y++) {
    for(var x = x1; x <= x2; x++) {
      coords.push([x, y]);
      if(coords.length >= 400000) throw "Potential memory leak";
    }
  }
  return coords;
}

var colors = ["#660066", "#003366", "#ff9900", "#ff0066", "#003300", "#ff0000", "#3a3a3a", "#006666", "#3399ff", "#3333ff", "#000000"];
function assignColor(username) {
  username = username.toUpperCase();
  var colLen = colors.length;
  var usrLen = username.length;
  var avg = 0;
  for(var i = 0; i < usrLen; i++) {
    var chr = username.charCodeAt(i);
    avg += (chr * chr | (i * chr) % 628) * (i << chr) + (chr*(i + 19 + (chr % 56))*chr);
  }
  return colors[(Math.abs(avg | 0)) % colLen];
}

function spaceTrim(str_array, left, right, gaps, secondary_array) {
  // secondary_array is an optional argument where elements are trimmed in parallel with str_array
  var marginLeft = 0;
  var marginRight = 0;
  var countL = left;
  var countR = right;
  var whitespaces = "\u0009\u000a\u000b\u000d\u0020\u0085\u00a0";
  for(var i = 0; i < str_array.length; i++) {
    var idxL = i;
    var idxR = str_array.length - 1 - i;
    if(whitespaces.indexOf(str_array[idxL]) > -1 && countL) {
      marginLeft++;
    } else {
      countL = false;
    }
    if(whitespaces.indexOf(str_array[idxR]) > -1 && countR) {
      marginRight++;
    } else {
      countR = false;
    }
    if(!countL && !countR) break;
  }
  if(marginLeft) {
    str_array.splice(0, marginLeft);
    spliceArray(secondary_array, 0, marginLeft);
  }
  if(marginRight) {
    str_array.splice(str_array.length - marginRight);
    spliceArray(secondary_array, secondary_array.length - marginRight);
  }
  if(gaps) {
    var spaceFreq = 0;
    for(var i = 0; i < str_array.length; i++) {
      var chr = str_array[i];
      if(whitespaces.indexOf(chr) > -1) {
        spaceFreq++;
      } else {
        spaceFreq = 0;
      }
      if(spaceFreq > 1) {
        str_array.splice(i, 1);
        spliceArray(secondary_array, i, 1);
        i--;
      }
    }
  }
  return str_array;
}

function spliceArray(array, A, B) {
  if(!array) return;
  if(Array.isArray(array)) {
    // list of arrays
    for(var i = 0; i < array.length; i++) {
      if(!array[i]) continue;
      array[i].splice(A, B);
    }
  } else {
    array.splice(A, B);
  }
}

function byId(a) {
  return document.getElementById(a);
}

function getDate() {
  return Date.now();
}

var keydownTable = {};
function keydownTableDown(e) {
  var key = e.key;
  if(!key) return;
  keydownTable[key] = 1;
}
function keydownTableUp(e) {
  var key = e.key;
  if(!key) return;
  if(keydownTable[key]) {
    delete keydownTable[key];
  }
}
document.addEventListener("keydown", keydownTableDown);
document.addEventListener("keyup", keydownTableUp);

// Element references
var elm = {};
function defineElements(list) {
  for(var el in list) {
    elm[el] = list[el];
  }
}

var keyCodeTbl = {
  "BACKSPACE":8, "TAB":9, "ENTER":13, "SHIFTRIGHT":16, "CONTROLLEFT":17, "CAPSLOCK":20, "ESCAPE":27, 
  "SPACE":32, "PAGEUP":33, "PAGEDOWN":34, "END":35, "HOME":36, "ARROWLEFT":37, "ARROWUP":38, "ARROWRIGHT":39, 
  "ARROWDOWN":40, "DELETE":46, "DIGIT0":48, "DIGIT1":49, "DIGIT2":50, "DIGIT3":51, "DIGIT4":52, "DIGIT5":53, 
  "DIGIT6":54, "DIGIT7":55, "DIGIT8":56, "DIGIT9":57, "KEYA":65, "KEYB":66, "KEYC":67, "KEYD":68, "KEYE":69, 
  "KEYF":70, "KEYG":71, "KEYH":72, "KEYI":73, "KEYJ":74, "KEYK":75, "KEYL":76, "KEYM":77, "KEYN":78, "KEYO":79, 
  "KEYP":80, "KEYQ":81, "KEYR":82, "KEYS":83, "KEYT":84, "KEYU":85, "KEYV":86, "KEYW":87, "KEYX":88, "KEYY":89, 
  "KEYZ":90, "CONTEXTMENU":93, "NUMPAD0":96, "NUMPAD1":97, "NUMPAD2":98, "NUMPAD3":99, "NUMPAD4":100, 
  "NUMPAD5":101, "NUMPAD6":102, "NUMPAD7":103, "NUMPAD8":104, "NUMPAD9":105, "NUMPADMULTIPLY":106, 
  "NUMPADADD":107, "NUMPADSUBTRACT":109, "NUMPADDECIMAL":110, "NUMPADDIVIDE":111, "F1":112, "F2":113, 
  "F3":114, "F4":115, "F5":116, "F6":117, "F7":118, "F8":119, "F9":120, "F10":121, "F11":122, "F12":123,
  "SEMICOLON":186, "COMMA":188, "MINUS":189, "PERIOD":190, "SLASH":191, "BACKQUOTE":192, "BRACKETLEFT":219,
  "BACKSLASH":220, "BRACKETRIGHT":221, "QUOTE":222
};

function getKeyCode(e) {
  if(e.keyCode != void 0) return e.keyCode;
  if(e.which != void 0) return e.which;
  if(e.code != void 0) return keyCodeTbl[e.code.toUpperCase()];
  return 0;
}

function escapeQuote(text) { // escapes " and ' and \
  return text.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\'/g, "\\'");
}

function escapeURLQuote(url) {
  try {
    var decode = decodeURIComponent(url);
  } catch(e) {
    return "";
  }
  return encodeURIComponent(escapeQuote(decode));
}

function getPos(ref) {
  ref = ref.split(",");
  return [parseInt(ref[0]), parseInt(ref[1])];
}

function html_tag_esc(str, non_breaking_space, newline_br) {
  str += "";
  str = str.replace(/\&/g, "&amp;");
  str = str.replace(/\</g, "&lt;");
  str = str.replace(/\>/g, "&gt;");
  str = str.replace(/\0/g, " ");
  if(newline_br) {
    str = str.replace(/\r\n/g, "<br>");
    str = str.replace(/\n/g, "<br>");
    str = str.replace(/\r/g, "<br>");
  } else {
    str = str.replace(/\r/g, " ");
    str = str.replace(/\n/g, " ");
  }
  str = str.replace(/\"/g, "&quot;");
  str = str.replace(/\'/g, "&#39;");
  str = str.replace(/\`/g, "&#96;");
  str = str.replace(/\//g, "&#x2F;");
  str = str.replace(/\\/g, "&#x5C;");
  str = str.replace(/\=/g, "&#61;");
  if(non_breaking_space) str = str.replace(/\u0020/g, "&nbsp;");
  if(str.indexOf(">") > -1 || str.indexOf("<") > -1) return "";
  return str;
}

function isHexString(str) {
  if(!str.length) return false;
  for(var i = 0; i < str.length; i++) {
    var chr = str[i];
    var isHex = ("a" <= chr && chr <= "f") || ("A" <= chr && chr <= "F") || ("0" <= chr && chr <= "9");
    if(!isHex) return false;
  }
  return true;
}

function convertToDate(epoch) {
  var months = [
    "January", "February", "March",
    "April", "May", "June",
    "July", "August", "September",
    "October", "November", "December"
  ];
  var str = "";
  var date = new Date(epoch);
  var month = date.getMonth();
  var day = date.getDate();
  var year = date.getFullYear();
  var hour = date.getHours();
  var minute = date.getMinutes();
  str += year + " " + months[month] + " " + day + " ";
  var per = "AM";
  if(hour >= 12) {
    per = "PM";
  }
  if(hour > 12) {
    hour = hour - 12;
  }
  if(hour == 0) {
    hour = 12;
  }
  str += hour + ":" + ("0" + minute).slice(-2) + " " + per;
  return str;
}

function int_to_rgb(value) {
  var r = (value >> 16) & 255;
  var g = (value >> 8) & 255;
  var b = value & 255;
  return [r, g, b];
}

function int_to_hexcode(value) {
  return "#" + value.toString(16).padStart(6, 0);
}

function rgb_to_int(r, g, b) {
  return b | g << 8 | r << 16;
}

function easeOutQuad(h, f, j, i) {
  return -j * (h /= i) * (h - 2) + f;
}

if(!Math.trunc) {
  Math.trunc = function(v) {
    v = +v;
    return (v - v % 1) || (!isFinite(v) || v === 0 ? v : v < 0 ? -0 : 0);
  }
}

if(!Object.assign) {
  Object.assign = function(target, vars) {
    for(var i in vars) {
      target[i] = vars[i];
    }
    return target;
  }
}

if(!Array.prototype.fill) {
  Array.prototype.fill = function(val) {
    var ar = this;
    for(var i = 0; i < ar.length; i++) {
      ar[i] = val;
    }
    return ar;
  }
}

if(!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) == search;
  }
}

if(!String.prototype.codePointAt) {
  String.prototype.codePointAt = function() {
    return this[0].charCodeAt();
  }
}

if(!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    if(count < 0) throw "Range error";
    var res = "";
    for(var i = 0; i < count; i++) {
      res += this;
    }
    return res;
  }
}

if(!String.prototype.padStart) {
  String.prototype.padStart = function(count, fillStr) {
    fillStr += "";
    return (fillStr.repeat(count) + this).slice(-count);
  }
}

if(!Math.log2) {
  Math.log2 = function(x) {
    return Math.log(x) * Math.LOG2E;
  }
}

function CircularBuffer(maxLen) {
  this.len = maxLen;
  this.buffer = [];
  this.pos = 0;
  this.elms = 0;
  return this;
}

CircularBuffer.prototype.push = function(data) {
  if(data === undefined) throw "Element cannot be undefined";
  if(this.pos >= this.buffer.length) {
    this.buffer.push(data);
    this.elms++;
    this.pos++;
    if(this.pos >= this.len) this.pos = 0;
    return;
  }
  this.buffer[this.pos] = data;
  this.elms++;
  if(this.elms > this.len) this.elms = this.len;
  this.pos++;
  if(this.pos >= this.len) this.pos = 0;
}

CircularBuffer.prototype.pop = function() {
  if(!this.buffer.length) return;
  if(!this.elms) return;
  this.pos--;
  if(this.pos < 0) this.pos = this.len - 1;
  var res = this.buffer[this.pos];
  this.elms--;
  return res;
}

CircularBuffer.prototype.unpop = function() {
  if(!this.buffer.length) return;
  if(this.elms >= this.buffer.length) return;
  var res = this.buffer[this.pos];
  if(res === undefined) return;
  this.pos++;
  if(this.pos >= this.len) this.pos = 0;
  this.elms++;
  return res;
}

CircularBuffer.prototype.trim = function() {
  var tmpPos = this.pos;
  for(var i = this.elms; i < this.buffer.length; i++) {
    if(tmpPos >= this.buffer.length) tmpPos = 0;
    if(this.buffer[tmpPos] === undefined) return;
    this.buffer[tmpPos] = undefined;
    tmpPos++;
  }
}

CircularBuffer.prototype.unwind = function() {
  var res = [];
  var tmpPos = this.pos - this.elms;
  if(tmpPos < 0) tmpPos += this.buffer.length;
  for(var i = 0; i < this.elms; i++) {
    if(tmpPos >= this.buffer.length) tmpPos = 0;
    var elm = this.buffer[tmpPos];
    if(elm === undefined) break;
    res.push(elm);
    tmpPos++;
  }
  return res;
}

CircularBuffer.prototype.top = function() {
  if(!this.buffer.length) return;
  if(!this.elms) return;
  var tmpPos = this.pos - 1;
  if(tmpPos < 0) tmpPos = this.len - 1;
  return this.buffer[tmpPos];
}

function getBasicHostname(host) {
  var host = host.toLowerCase().split(".");
  if(host[0] == "www") host.shift();
  return host.join(".");
}

function isSafeHostname(host) {
  return safeLinkHosts.includes(host);
}

var safeLinkHosts = [
  getBasicHostname(window.location.host),
  "yourworldoftext.com",
  "ourworldofpixels.com",
  "ourworldoftext.com",
  "dir.ourworldoftext.com",
  "testserver1.ourworldoftext.com",
  "spooks.me",
  "youtube.com",
  "discord.com",
  "discord.gg",
  "discordapp.com",
  "reddit.com",
  "old.reddit.com"
];

// compatibility (deprecated)
var blankColor = new Array(128).fill(0);

if(state.worldModel.nsfw) {
  var check = localStorage.getItem("nsfw_yes");
  if(check) {
    check = JSON.parse(check);
    if(!check[state.worldModel.name.toUpperCase()]) {
      window.location.pathname = "/accounts/nsfw/" + state.worldModel.name;
    }
  } else {
    window.location.pathname = "/accounts/nsfw/" + state.worldModel.name;
  }
}

function ReconnectingWebSocket(url) {
  this.binaryType = "blob";
  this.onopen = null;
  this.onclose = null;
  this.onmessage = null;
  this.onerror = null;
  this.reconnectTimeout = 1000;
  var closed = false;
  var self = this;
  function connect() {
    self.socket = new SimulatedServerSocket(url); // (MOD)
    self.socket.onclose = function(r) {
      if(self.onclose) self.onclose(r);
      if(closed) return;
      setTimeout(connect, self.reconnectTimeout);
    }
    self.socket.onopen = function(e) {
      self.socket.binaryType = self.binaryType;
      if(self.onopen) self.onopen(e);
    }
    self.socket.onmessage = function(m) {
      if(self.onmessage) self.onmessage(m);
    }
    self.socket.onerror = function(m) {
      if(self.onerror) self.onerror(m);
    }
  }
  connect();
  this.send = function(data) {
    this.socket.send(data);
  }
  this.close = function() {
    closed = true;
    this.socket.close();
  }
  this.refresh = function() {
    this.socket.close();
  }
  return this;
}

// split a mixed string with surrogates and combining characters
function advancedSplit(str, noSurrog, noComb, norm) {
  if(str && str.constructor == Array) return str.slice(0);
  var chars = [];
  var buffer = "";
  var surrogMode = false;
  var charMode = false;
  var combCount = 0;
  var combLimit = 15;
  for(var i = 0; i < str.length; i++) {
    var char = str[i];
    var code = char.charCodeAt();
    if(code >= 0xDC00 && code <= 0xDFFF) {
      if(surrogMode) {
        buffer += char;
      } else {
        buffer = "";
        chars.push("?");
      }
      surrogMode = false;
      combCount = 0;
      continue;
    } else if(surrogMode) {
      buffer = "";
      chars.push("?");
      surrogMode = false;
      continue;
    }
    if(!noSurrog && code >= 0xD800 && code <= 0xDBFF) {
      if(charMode) {
        chars.push(buffer);
      }
      charMode = true;
      surrogMode = true;
      buffer = char;
      continue;
    }
    if(!norm && ((code >= 0x0300 && code <= 0x036F) ||
      (code >= 0x1DC0 && code <= 0x1DFF) ||
      (code >= 0x20D0 && code <= 0x20FF) ||
      (code >= 0xFE20 && code <= 0xFE2F))) {
      if(!noComb && charMode && combCount < combLimit) {
        buffer += char;
        combCount++;
      }
      continue;
    } else {
      if(charMode) {
        chars.push(buffer);
      }
      combCount = 0;
      charMode = true;
      buffer = char;
    }
  }
  if(buffer) {
    chars.push(buffer);
  }
  return chars;
}

function filterAdvancedChars(array, noSurrogates, noCombining) {
  if(!noSurrogates && !noCombining) {
    return array;
  }
  for(var i = 0; i < array.length; i++) {
    var char = array[i];
    var combSize = 0;
    for(var x = 0; x < char.length; x++) {
      var subchar = char[char.length - 1 - x];
      var scode = subchar.charCodeAt();
      if(((scode >= 0x0300 && scode <= 0x036F) ||
        (scode >= 0x1DC0 && scode <= 0x1DFF) ||
        (scode >= 0x20D0 && scode <= 0x20FF) ||
        (scode >= 0xFE20 && scode <= 0xFE2F))) {
        combSize++;
      } else {
        break;
      }
    }
    var baseChar = char.slice(0, char.length - combSize);
    var combChar = char.slice(char.length - combSize, char.length);
    if(noSurrogates && baseChar.length > 1) {
      baseChar = "?";
    }
    if(noCombining) {
      combChar = "";
    }
    array[i] = baseChar + combChar;
  }
  return array;
}

if(!HTMLElement.prototype.append) {
  HTMLElement.prototype.append = function(string) {
    this.appendChild(document.createTextNode(string));
  }
}

var w = {
  loadScript: function(url, callback) {
    var script = document.createElement("script");
    if(callback === true) {
      // synchronous
      ajaxRequest({
        type: "GET",
        url: url,
        async: true,
        done: function(e) {
          script.innerText = e;
          document.head.appendChild(script);
        }
      });
    } else {
      script.src = url;
      document.head.appendChild(script);
      script.onload = callback;
    }
  },
  clipboard: {
    textarea: null,
    init: function() {
      var area = document.createElement("textarea");
      area.value = "";
      area.id = "textCopy";
      area.style.width = "1px";
      area.style.height = "1px";
      area.style.position = "absolute";
      area.style.left = "-1000px";
      area.style.top = "-1000px";
      document.body.appendChild(area);
      w.clipboard.textarea = area;
    },
    copy: function(string) {
      w.clipboard.textarea.value = string;
      w.clipboard.textarea.select();
      document.execCommand("copy");
      w.clipboard.textarea.value = "";
    }
  },
  events: {},
  on: function(type, call) {
    if(typeof call != "function") {
      throw "Callback is not a function";
    }
    type = type.toLowerCase();
    if(!OWOT.events[type]) {
      OWOT.events[type] = [];
    }
    OWOT.events[type].push(call);
  },
  off: function(type, call) {
    type = type.toLowerCase();
    if(!OWOT.events[type]) return;
    while(true) {
      var idx = OWOT.events[type].indexOf(call);
      if(idx == -1) break;
      OWOT.events[type].splice(idx, 1);
    }
  },
  emit: function(type, data) {
    type = type.toLowerCase();
    var evt = OWOT.events[type];
    if(!evt) return;
    for(var e = 0; e < evt.length; e++) {
      var func = evt[e];
      func(data);
    }
  },
  listening: function(type) {
    type = type.toLowerCase();
    return !!OWOT.events[type];
  },
  split: advancedSplit
};

var OWOT = w;
w.clipboard.init();

    </script>
    <script>
/**
 * jscolor - JavaScript Color Picker
 *
 * @link    http://jscolor.com
 * @license For open source use: GPLv3
 *          For commercial use: JSColor Commercial License
 * @author  Jan Odvarko
 *
 * See usage examples at http://jscolor.com/examples/
 */"use strict";window.jscolor||(window.jscolor=function(){var e={register:function(){e.attachDOMReadyEvent(e.init),e.attachEvent(document,"mousedown",e.onDocumentMouseDown),e.attachEvent(document,"touchstart",e.onDocumentTouchStart),e.attachEvent(window,"resize",e.onWindowResize)},init:function(){e.jscolor.lookupClass&&e.jscolor.installByClassName(e.jscolor.lookupClass)},tryInstallOnElements:function(t,n){var r=new RegExp("(^|\\s)("+n+")(\\s*(\\{[^}]*\\})|\\s|$)","i");for(var i=0;i<t.length;i+=1){if(t[i].type!==undefined&&t[i].type.toLowerCase()=="color"&&e.isColorAttrSupported)continue;var s;if(!t[i].jscolor&&t[i].className&&(s=t[i].className.match(r))){var o=t[i],u=null,a=e.getDataAttr(o,"jscolor");a!==null?u=a:s[4]&&(u=s[4]);var f={};if(u)try{f=(new Function("return ("+u+")"))()}catch(l){e.warn("Error parsing jscolor options: "+l+":\n"+u)}o.jscolor=new e.jscolor(o,f)}}},isColorAttrSupported:function(){var e=document.createElement("input");if(e.setAttribute){e.setAttribute("type","color");if(e.type.toLowerCase()=="color")return!0}return!1}(),isCanvasSupported:function(){var e=document.createElement("canvas");return!!e.getContext&&!!e.getContext("2d")}(),fetchElement:function(e){return typeof e=="string"?document.getElementById(e):e},isElementType:function(e,t){return e.nodeName.toLowerCase()===t.toLowerCase()},getDataAttr:function(e,t){var n="data-"+t,r=e.getAttribute(n);return r!==null?r:null},attachEvent:function(e,t,n){e.addEventListener?e.addEventListener(t,n,!1):e.attachEvent&&e.attachEvent("on"+t,n)},detachEvent:function(e,t,n){e.removeEventListener?e.removeEventListener(t,n,!1):e.detachEvent&&e.detachEvent("on"+t,n)},_attachedGroupEvents:{},attachGroupEvent:function(t,n,r,i){e._attachedGroupEvents.hasOwnProperty(t)||(e._attachedGroupEvents[t]=[]),e._attachedGroupEvents[t].push([n,r,i]),e.attachEvent(n,r,i)},detachGroupEvents:function(t){if(e._attachedGroupEvents.hasOwnProperty(t)){for(var n=0;n<e._attachedGroupEvents[t].length;n+=1){var r=e._attachedGroupEvents[t][n];e.detachEvent(r[0],r[1],r[2])}delete e._attachedGroupEvents[t]}},attachDOMReadyEvent:function(e){var t=!1,n=function(){t||(t=!0,e())};if(document.readyState==="complete"){setTimeout(n,1);return}if(document.addEventListener)document.addEventListener("DOMContentLoaded",n,!1),window.addEventListener("load",n,!1);else if(document.attachEvent){document.attachEvent("onreadystatechange",function(){document.readyState==="complete"&&(document.detachEvent("onreadystatechange",arguments.callee),n())}),window.attachEvent("onload",n);if(document.documentElement.doScroll&&window==window.top){var r=function(){if(!document.body)return;try{document.documentElement.doScroll("left"),n()}catch(e){setTimeout(r,1)}};r()}}},warn:function(e){window.console&&window.console.warn&&window.console.warn(e)},preventDefault:function(e){e.preventDefault&&e.preventDefault(),e.returnValue=!1},captureTarget:function(t){t.setCapture&&(e._capturedTarget=t,e._capturedTarget.setCapture())},releaseTarget:function(){e._capturedTarget&&(e._capturedTarget.releaseCapture(),e._capturedTarget=null)},fireEvent:function(e,t){if(!e)return;if(document.createEvent){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}else if(document.createEventObject){var n=document.createEventObject();e.fireEvent("on"+t,n)}else e["on"+t]&&e["on"+t]()},classNameToList:function(e){return e.replace(/^\s+|\s+$/g,"").split(/\s+/)},hasClass:function(e,t){return t?-1!=(" "+e.className.replace(/\s+/g," ")+" ").indexOf(" "+t+" "):!1},setClass:function(t,n){var r=e.classNameToList(n);for(var i=0;i<r.length;i+=1)e.hasClass(t,r[i])||(t.className+=(t.className?" ":"")+r[i])},unsetClass:function(t,n){var r=e.classNameToList(n);for(var i=0;i<r.length;i+=1){var s=new RegExp("^\\s*"+r[i]+"\\s*|"+"\\s*"+r[i]+"\\s*$|"+"\\s+"+r[i]+"(\\s+)","g");t.className=t.className.replace(s,"$1")}},getStyle:function(e){return window.getComputedStyle?window.getComputedStyle(e):e.currentStyle},setStyle:function(){var e=document.createElement("div"),t=function(t){for(var n=0;n<t.length;n+=1)if(t[n]in e.style)return t[n]},n={borderRadius:t(["borderRadius","MozBorderRadius","webkitBorderRadius"]),boxShadow:t(["boxShadow","MozBoxShadow","webkitBoxShadow"])};return function(e,t,r){switch(t.toLowerCase()){case"opacity":var i=Math.round(parseFloat(r)*100);e.style.opacity=r,e.style.filter="alpha(opacity="+i+")";break;default:e.style[n[t]]=r}}}(),setBorderRadius:function(t,n){e.setStyle(t,"borderRadius",n||"0")},setBoxShadow:function(t,n){e.setStyle(t,"boxShadow",n||"none")},getElementPos:function(t,n){var r=0,i=0,s=t.getBoundingClientRect();r=s.left,i=s.top;if(!n){var o=e.getViewPos();r+=o[0],i+=o[1]}return[r,i]},getElementSize:function(e){return[e.offsetWidth,e.offsetHeight]},getAbsPointerPos:function(e){e||(e=window.event);var t=0,n=0;return typeof e.changedTouches!="undefined"&&e.changedTouches.length?(t=e.changedTouches[0].clientX,n=e.changedTouches[0].clientY):typeof e.clientX=="number"&&(t=e.clientX,n=e.clientY),{x:t,y:n}},getRelPointerPos:function(e){e||(e=window.event);var t=e.target||e.srcElement,n=t.getBoundingClientRect(),r=0,i=0,s=0,o=0;return typeof e.changedTouches!="undefined"&&e.changedTouches.length?(s=e.changedTouches[0].clientX,o=e.changedTouches[0].clientY):typeof e.clientX=="number"&&(s=e.clientX,o=e.clientY),r=s-n.left,i=o-n.top,{x:r,y:i}},getViewPos:function(){var e=document.documentElement;return[(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),(window.pageYOffset||e.scrollTop)-(e.clientTop||0)]},getViewSize:function(){var e=document.documentElement;return[window.innerWidth||e.clientWidth,window.innerHeight||e.clientHeight]},redrawPosition:function(){if(e.picker&&e.picker.owner){var t=e.picker.owner,n,r;t.fixed?(n=e.getElementPos(t.targetElement,!0),r=[0,0]):(n=e.getElementPos(t.targetElement),r=e.getViewPos());var i=e.getElementSize(t.targetElement),s=e.getViewSize(),o=e.getPickerOuterDims(t),u,a,f;switch(t.position.toLowerCase()){case"left":u=1,a=0,f=-1;break;case"right":u=1,a=0,f=1;break;case"top":u=0,a=1,f=-1;break;default:u=0,a=1,f=1}var l=(i[a]+o[a])/2;if(!t.smartPosition)var c=[n[u],n[a]+i[a]-l+l*f];else var c=[-r[u]+n[u]+o[u]>s[u]?-r[u]+n[u]+i[u]/2>s[u]/2&&n[u]+i[u]-o[u]>=0?n[u]+i[u]-o[u]:n[u]:n[u],-r[a]+n[a]+i[a]+o[a]-l+l*f>s[a]?-r[a]+n[a]+i[a]/2>s[a]/2&&n[a]+i[a]-l-l*f>=0?n[a]+i[a]-l-l*f:n[a]+i[a]-l+l*f:n[a]+i[a]-l+l*f>=0?n[a]+i[a]-l+l*f:n[a]+i[a]-l-l*f];var h=c[u],p=c[a],d=t.fixed?"fixed":"absolute",v=(c[0]+o[0]>n[0]||c[0]<n[0]+i[0])&&c[1]+o[1]<n[1]+i[1];e._drawPosition(t,h,p,d,v)}},_drawPosition:function(t,n,r,i,s){var o=s?0:t.shadowBlur;e.picker.wrap.style.position=i,e.picker.wrap.style.left=n+"px",e.picker.wrap.style.top=r+"px",e.setBoxShadow(e.picker.boxS,t.shadow?new e.BoxShadow(0,o,t.shadowBlur,0,t.shadowColor):null)},getPickerDims:function(t){var n=!!e.getSliderComponent(t),r=[2*t.insetWidth+2*t.padding+t.width+(n?2*t.insetWidth+e.getPadToSliderPadding(t)+t.sliderSize:0),2*t.insetWidth+2*t.padding+t.height+(t.closable?2*t.insetWidth+t.padding+t.buttonHeight:0)];return r},getPickerOuterDims:function(t){var n=e.getPickerDims(t);return[n[0]+2*t.borderWidth,n[1]+2*t.borderWidth]},getPadToSliderPadding:function(e){return Math.max(e.padding,1.5*(2*e.pointerBorderWidth+e.pointerThickness))},getPadYComponent:function(e){switch(e.mode.charAt(1).toLowerCase()){case"v":return"v"}return"s"},getSliderComponent:function(e){if(e.mode.length>2)switch(e.mode.charAt(2).toLowerCase()){case"s":return"s";case"v":return"v"}return null},onDocumentMouseDown:function(t){t||(t=window.event);var n=t.target||t.srcElement;n._jscLinkedInstance?n._jscLinkedInstance.showOnClick&&n._jscLinkedInstance.show():n._jscControlName?e.onControlPointerStart(t,n,n._jscControlName,"mouse"):e.picker&&e.picker.owner&&e.picker.owner.hide()},onDocumentTouchStart:function(t){t||(t=window.event);var n=t.target||t.srcElement;n._jscLinkedInstance?n._jscLinkedInstance.showOnClick&&n._jscLinkedInstance.show():n._jscControlName?e.onControlPointerStart(t,n,n._jscControlName,"touch"):e.picker&&e.picker.owner&&e.picker.owner.hide()},onWindowResize:function(t){e.redrawPosition()},onParentScroll:function(t){e.picker&&e.picker.owner&&e.picker.owner.hide()},_pointerMoveEvent:{mouse:"mousemove",touch:"touchmove"},_pointerEndEvent:{mouse:"mouseup",touch:"touchend"},_pointerOrigin:null,_capturedTarget:null,onControlPointerStart:function(t,n,r,i){var s=n._jscInstance;e.preventDefault(t),e.captureTarget(n);var o=function(s,o){e.attachGroupEvent("drag",s,e._pointerMoveEvent[i],e.onDocumentPointerMove(t,n,r,i,o)),e.attachGroupEvent("drag",s,e._pointerEndEvent[i],e.onDocumentPointerEnd(t,n,r,i))};o(document,[0,0]);if(window.parent&&window.frameElement){var u=window.frameElement.getBoundingClientRect(),a=[-u.left,-u.top];o(window.parent.window.document,a)}var f=e.getAbsPointerPos(t),l=e.getRelPointerPos(t);e._pointerOrigin={x:f.x-l.x,y:f.y-l.y};switch(r){case"pad":switch(e.getSliderComponent(s)){case"s":s.hsv[1]===0&&s.fromHSV(null,100,null);break;case"v":s.hsv[2]===0&&s.fromHSV(null,null,100)}e.setPad(s,t,0,0);break;case"sld":e.setSld(s,t,0)}e.dispatchFineChange(s)},onDocumentPointerMove:function(t,n,r,i,s){return function(t){var i=n._jscInstance;switch(r){case"pad":t||(t=window.event),e.setPad(i,t,s[0],s[1]),e.dispatchFineChange(i);break;case"sld":t||(t=window.event),e.setSld(i,t,s[1]),e.dispatchFineChange(i)}}},onDocumentPointerEnd:function(t,n,r,i){return function(t){var r=n._jscInstance;e.detachGroupEvents("drag"),e.releaseTarget(),e.dispatchChange(r)}},dispatchChange:function(t){t.valueElement&&e.isElementType(t.valueElement,"input")&&e.fireEvent(t.valueElement,"change")},dispatchFineChange:function(e){if(e.onFineChange){var t;typeof e.onFineChange=="string"?t=new Function(e.onFineChange):t=e.onFineChange,t.call(e)}},setPad:function(t,n,r,i){var s=e.getAbsPointerPos(n),o=r+s.x-e._pointerOrigin.x-t.padding-t.insetWidth,u=i+s.y-e._pointerOrigin.y-t.padding-t.insetWidth,a=o*(360/(t.width-1)),f=100-u*(100/(t.height-1));switch(e.getPadYComponent(t)){case"s":t.fromHSV(a,f,null,e.leaveSld);break;case"v":t.fromHSV(a,null,f,e.leaveSld)}},setSld:function(t,n,r){var i=e.getAbsPointerPos(n),s=r+i.y-e._pointerOrigin.y-t.padding-t.insetWidth,o=100-s*(100/(t.height-1));switch(e.getSliderComponent(t)){case"s":t.fromHSV(null,o,null,e.leavePad);break;case"v":t.fromHSV(null,null,o,e.leavePad)}},_vmlNS:"jsc_vml_",_vmlCSS:"jsc_vml_css_",_vmlReady:!1,initVML:function(){if(!e._vmlReady){var t=document;t.namespaces[e._vmlNS]||t.namespaces.add(e._vmlNS,"urn:schemas-microsoft-com:vml");if(!t.styleSheets[e._vmlCSS]){var n=["shape","shapetype","group","background","path","formulas","handles","fill","stroke","shadow","textbox","textpath","imagedata","line","polyline","curve","rect","roundrect","oval","arc","image"],r=t.createStyleSheet();r.owningElement.id=e._vmlCSS;for(var i=0;i<n.length;i+=1)r.addRule(e._vmlNS+"\\:"+n[i],"behavior:url(#default#VML);")}e._vmlReady=!0}},createPalette:function(){var t={elm:null,draw:null};if(e.isCanvasSupported){var n=document.createElement("canvas"),r=n.getContext("2d"),i=function(e,t,i){n.width=e,n.height=t,r.clearRect(0,0,n.width,n.height);var s=r.createLinearGradient(0,0,n.width,0);s.addColorStop(0,"#F00"),s.addColorStop(1/6,"#FF0"),s.addColorStop(2/6,"#0F0"),s.addColorStop(.5,"#0FF"),s.addColorStop(4/6,"#00F"),s.addColorStop(5/6,"#F0F"),s.addColorStop(1,"#F00"),r.fillStyle=s,r.fillRect(0,0,n.width,n.height);var o=r.createLinearGradient(0,0,0,n.height);switch(i.toLowerCase()){case"s":o.addColorStop(0,"rgba(255,255,255,0)"),o.addColorStop(1,"rgba(255,255,255,1)");break;case"v":o.addColorStop(0,"rgba(0,0,0,0)"),o.addColorStop(1,"rgba(0,0,0,1)")}r.fillStyle=o,r.fillRect(0,0,n.width,n.height)};t.elm=n,t.draw=i}else{e.initVML();var s=document.createElement("div");s.style.position="relative",s.style.overflow="hidden";var o=document.createElement(e._vmlNS+":fill");o.type="gradient",o.method="linear",o.angle="90",o.colors="16.67% #F0F, 33.33% #00F, 50% #0FF, 66.67% #0F0, 83.33% #FF0";var u=document.createElement(e._vmlNS+":rect");u.style.position="absolute",u.style.left="-1px",u.style.top="-1px",u.stroked=!1,u.appendChild(o),s.appendChild(u);var a=document.createElement(e._vmlNS+":fill");a.type="gradient",a.method="linear",a.angle="180",a.opacity="0";var f=document.createElement(e._vmlNS+":rect");f.style.position="absolute",f.style.left="-1px",f.style.top="-1px",f.stroked=!1,f.appendChild(a),s.appendChild(f);var i=function(e,t,n){s.style.width=e+"px",s.style.height=t+"px",u.style.width=f.style.width=e+1+"px",u.style.height=f.style.height=t+1+"px",o.color="#F00",o.color2="#F00";switch(n.toLowerCase()){case"s":a.color=a.color2="#FFF";break;case"v":a.color=a.color2="#000"}};t.elm=s,t.draw=i}return t},createSliderGradient:function(){var t={elm:null,draw:null};if(e.isCanvasSupported){var n=document.createElement("canvas"),r=n.getContext("2d"),i=function(e,t,i,s){n.width=e,n.height=t,r.clearRect(0,0,n.width,n.height);var o=r.createLinearGradient(0,0,0,n.height);o.addColorStop(0,i),o.addColorStop(1,s),r.fillStyle=o,r.fillRect(0,0,n.width,n.height)};t.elm=n,t.draw=i}else{e.initVML();var s=document.createElement("div");s.style.position="relative",s.style.overflow="hidden";var o=document.createElement(e._vmlNS+":fill");o.type="gradient",o.method="linear",o.angle="180";var u=document.createElement(e._vmlNS+":rect");u.style.position="absolute",u.style.left="-1px",u.style.top="-1px",u.stroked=!1,u.appendChild(o),s.appendChild(u);var i=function(e,t,n,r){s.style.width=e+"px",s.style.height=t+"px",u.style.width=e+1+"px",u.style.height=t+1+"px",o.color=n,o.color2=r};t.elm=s,t.draw=i}return t},leaveValue:1,leaveStyle:2,leavePad:4,leaveSld:8,BoxShadow:function(){var e=function(e,t,n,r,i,s){this.hShadow=e,this.vShadow=t,this.blur=n,this.spread=r,this.color=i,this.inset=!!s};return e.prototype.toString=function(){var e=[Math.round(this.hShadow)+"px",Math.round(this.vShadow)+"px",Math.round(this.blur)+"px",Math.round(this.spread)+"px",this.color];return this.inset&&e.push("inset"),e.join(" ")},e}(),jscolor:function(t,n){function i(e,t,n){e/=255,t/=255,n/=255;var r=Math.min(Math.min(e,t),n),i=Math.max(Math.max(e,t),n),s=i-r;if(s===0)return[null,0,100*i];var o=e===r?3+(n-t)/s:t===r?5+(e-n)/s:1+(t-e)/s;return[60*(o===6?0:o),100*(s/i),100*i]}function s(e,t,n){var r=255*(n/100);if(e===null)return[r,r,r];e/=60,t/=100;var i=Math.floor(e),s=i%2?e-i:1-(e-i),o=r*(1-t),u=r*(1-t*s);switch(i){case 6:case 0:return[r,u,o];case 1:return[u,r,o];case 2:return[o,r,u];case 3:return[o,u,r];case 4:return[u,o,r];case 5:return[r,o,u]}}function o(){e.unsetClass(d.targetElement,d.activeClass),e.picker.wrap.parentNode.removeChild(e.picker.wrap),delete e.picker.owner}function u(){function l(){var e=d.insetColor.split(/\s+/),n=e.length<2?e[0]:e[1]+" "+e[0]+" "+e[0]+" "+e[1];t.btn.style.borderColor=n}d._processParentElementsInDOM(),e.picker||(e.picker={owner:null,wrap:document.createElement("div"),box:document.createElement("div"),boxS:document.createElement("div"),boxB:document.createElement("div"),pad:document.createElement("div"),padB:document.createElement("div"),padM:document.createElement("div"),padPal:e.createPalette(),cross:document.createElement("div"),crossBY:document.createElement("div"),crossBX:document.createElement("div"),crossLY:document.createElement("div"),crossLX:document.createElement("div"),sld:document.createElement("div"),sldB:document.createElement("div"),sldM:document.createElement("div"),sldGrad:e.createSliderGradient(),sldPtrS:document.createElement("div"),sldPtrIB:document.createElement("div"),sldPtrMB:document.createElement("div"),sldPtrOB:document.createElement("div"),btn:document.createElement("div"),btnT:document.createElement("span")},e.picker.pad.appendChild(e.picker.padPal.elm),e.picker.padB.appendChild(e.picker.pad),e.picker.cross.appendChild(e.picker.crossBY),e.picker.cross.appendChild(e.picker.crossBX),e.picker.cross.appendChild(e.picker.crossLY),e.picker.cross.appendChild(e.picker.crossLX),e.picker.padB.appendChild(e.picker.cross),e.picker.box.appendChild(e.picker.padB),e.picker.box.appendChild(e.picker.padM),e.picker.sld.appendChild(e.picker.sldGrad.elm),e.picker.sldB.appendChild(e.picker.sld),e.picker.sldB.appendChild(e.picker.sldPtrOB),e.picker.sldPtrOB.appendChild(e.picker.sldPtrMB),e.picker.sldPtrMB.appendChild(e.picker.sldPtrIB),e.picker.sldPtrIB.appendChild(e.picker.sldPtrS),e.picker.box.appendChild(e.picker.sldB),e.picker.box.appendChild(e.picker.sldM),e.picker.btn.appendChild(e.picker.btnT),e.picker.box.appendChild(e.picker.btn),e.picker.boxB.appendChild(e.picker.box),e.picker.wrap.appendChild(e.picker.boxS),e.picker.wrap.appendChild(e.picker.boxB));var t=e.picker,n=!!e.getSliderComponent(d),r=e.getPickerDims(d),i=2*d.pointerBorderWidth+d.pointerThickness+2*d.crossSize,s=e.getPadToSliderPadding(d),o=Math.min(d.borderRadius,Math.round(d.padding*Math.PI)),u="crosshair";t.wrap.style.clear="both",t.wrap.style.width=r[0]+2*d.borderWidth+"px",t.wrap.style.height=r[1]+2*d.borderWidth+"px",t.wrap.style.zIndex=d.zIndex,t.box.style.width=r[0]+"px",t.box.style.height=r[1]+"px",t.boxS.style.position="absolute",t.boxS.style.left="0",t.boxS.style.top="0",t.boxS.style.width="100%",t.boxS.style.height="100%",e.setBorderRadius(t.boxS,o+"px"),t.boxB.style.position="relative",t.boxB.style.border=d.borderWidth+"px solid",t.boxB.style.borderColor=d.borderColor,t.boxB.style.background=d.backgroundColor,e.setBorderRadius(t.boxB,o+"px"),t.padM.style.background=t.sldM.style.background="#FFF",e.setStyle(t.padM,"opacity","0"),e.setStyle(t.sldM,"opacity","0"),t.pad.style.position="relative",t.pad.style.width=d.width+"px",t.pad.style.height=d.height+"px",t.padPal.draw(d.width,d.height,e.getPadYComponent(d)),t.padB.style.position="absolute",t.padB.style.left=d.padding+"px",t.padB.style.top=d.padding+"px",t.padB.style.border=d.insetWidth+"px solid",t.padB.style.borderColor=d.insetColor,t.padM._jscInstance=d,t.padM._jscControlName="pad",t.padM.style.position="absolute",t.padM.style.left="0",t.padM.style.top="0",t.padM.style.width=d.padding+2*d.insetWidth+d.width+s/2+"px",t.padM.style.height=r[1]+"px",t.padM.style.cursor=u,t.cross.style.position="absolute",t.cross.style.left=t.cross.style.top="0",t.cross.style.width=t.cross.style.height=i+"px",t.crossBY.style.position=t.crossBX.style.position="absolute",t.crossBY.style.background=t.crossBX.style.background=d.pointerBorderColor,t.crossBY.style.width=t.crossBX.style.height=2*d.pointerBorderWidth+d.pointerThickness+"px",t.crossBY.style.height=t.crossBX.style.width=i+"px",t.crossBY.style.left=t.crossBX.style.top=Math.floor(i/2)-Math.floor(d.pointerThickness/2)-d.pointerBorderWidth+"px",t.crossBY.style.top=t.crossBX.style.left="0",t.crossLY.style.position=t.crossLX.style.position="absolute",t.crossLY.style.background=t.crossLX.style.background=d.pointerColor,t.crossLY.style.height=t.crossLX.style.width=i-2*d.pointerBorderWidth+"px",t.crossLY.style.width=t.crossLX.style.height=d.pointerThickness+"px",t.crossLY.style.left=t.crossLX.style.top=Math.floor(i/2)-Math.floor(d.pointerThickness/2)+"px",t.crossLY.style.top=t.crossLX.style.left=d.pointerBorderWidth+"px",t.sld.style.overflow="hidden",t.sld.style.width=d.sliderSize+"px",t.sld.style.height=d.height+"px",t.sldGrad.draw(d.sliderSize,d.height,"#000","#000"),t.sldB.style.display=n?"block":"none",t.sldB.style.position="absolute",t.sldB.style.right=d.padding+"px",t.sldB.style.top=d.padding+"px",t.sldB.style.border=d.insetWidth+"px solid",t.sldB.style.borderColor=d.insetColor,t.sldM._jscInstance=d,t.sldM._jscControlName="sld",t.sldM.style.display=n?"block":"none",t.sldM.style.position="absolute",t.sldM.style.right="0",t.sldM.style.top="0",t.sldM.style.width=d.sliderSize+s/2+d.padding+2*d.insetWidth+"px",t.sldM.style.height=r[1]+"px",t.sldM.style.cursor="default",t.sldPtrIB.style.border=t.sldPtrOB.style.border=d.pointerBorderWidth+"px solid "+d.pointerBorderColor,t.sldPtrOB.style.position="absolute",t.sldPtrOB.style.left=-(2*d.pointerBorderWidth+d.pointerThickness)+"px",t.sldPtrOB.style.top="0",t.sldPtrMB.style.border=d.pointerThickness+"px solid "+d.pointerColor,t.sldPtrS.style.width=d.sliderSize+"px",t.sldPtrS.style.height=m+"px",t.btn.style.display=d.closable?"block":"none",t.btn.style.position="absolute",t.btn.style.left=d.padding+"px",t.btn.style.bottom=d.padding+"px",t.btn.style.padding="0 15px",t.btn.style.height=d.buttonHeight+"px",t.btn.style.border=d.insetWidth+"px solid",l(),t.btn.style.color=d.buttonColor,t.btn.style.font="12px sans-serif",t.btn.style.textAlign="center";try{t.btn.style.cursor="pointer"}catch(c){t.btn.style.cursor="hand"}t.btn.onmousedown=function(){d.hide()},t.btnT.style.lineHeight=d.buttonHeight+"px",t.btnT.innerHTML="",t.btnT.appendChild(document.createTextNode(d.closeText)),a(),f(),e.picker.owner&&e.picker.owner!==d&&e.unsetClass(e.picker.owner.targetElement,d.activeClass),e.picker.owner=d,e.isElementType(v,"body")?e.redrawPosition():e._drawPosition(d,0,0,"relative",!1),t.wrap.parentNode!=v&&v.appendChild(t.wrap),e.setClass(d.targetElement,d.activeClass)}function a(){switch(e.getPadYComponent(d)){case"s":var t=1;break;case"v":var t=2}var n=Math.round(d.hsv[0]/360*(d.width-1)),r=Math.round((1-d.hsv[t]/100)*(d.height-1)),i=2*d.pointerBorderWidth+d.pointerThickness+2*d.crossSize,o=-Math.floor(i/2);e.picker.cross.style.left=n+o+"px",e.picker.cross.style.top=r+o+"px";switch(e.getSliderComponent(d)){case"s":var u=s(d.hsv[0],100,d.hsv[2]),a=s(d.hsv[0],0,d.hsv[2]),f="rgb("+Math.round(u[0])+","+Math.round(u[1])+","+Math.round(u[2])+")",l="rgb("+Math.round(a[0])+","+Math.round(a[1])+","+Math.round(a[2])+")";e.picker.sldGrad.draw(d.sliderSize,d.height,f,l);break;case"v":var c=s(d.hsv[0],d.hsv[1],100),f="rgb("+Math.round(c[0])+","+Math.round(c[1])+","+Math.round(c[2])+")",l="#000";e.picker.sldGrad.draw(d.sliderSize,d.height,f,l)}}function f(){var t=e.getSliderComponent(d);if(t){switch(t){case"s":var n=1;break;case"v":var n=2}var r=Math.round((1-d.hsv[n]/100)*(d.height-1));e.picker.sldPtrOB.style.top=r-(2*d.pointerBorderWidth+d.pointerThickness)-Math.floor(m/2)+"px"}}function l(){return e.picker&&e.picker.owner===d}function c(){d.importColor()}this.value=null,this.valueElement=t,this.styleElement=t,this.required=!0,this.refine=!0,this.hash=!1,this.uppercase=!0,this.onFineChange=null,this.activeClass="jscolor-active",this.minS=0,this.maxS=100,this.minV=0,this.maxV=100,this.hsv=[0,0,100],this.rgb=[255,255,255],this.width=181,this.height=101,this.showOnClick=!0,this.mode="HSV",this.position="bottom",this.smartPosition=!0,this.sliderSize=16,this.crossSize=8,this.closable=!1,this.closeText="Close",this.buttonColor="#000000",this.buttonHeight=18,this.padding=12,this.backgroundColor="#FFFFFF",this.borderWidth=1,this.borderColor="#BBBBBB",this.borderRadius=8,this.insetWidth=1,this.insetColor="#BBBBBB",this.shadow=!0,this.shadowBlur=15,this.shadowColor="rgba(0,0,0,0.2)",this.pointerColor="#4C4C4C",this.pointerBorderColor="#FFFFFF",this.pointerBorderWidth=1,this.pointerThickness=2,this.zIndex=1e6,this.container=null;for(var r in n)n.hasOwnProperty(r)&&(this[r]=n[r]);this.hide=function(){l()&&o()},this.show=function(){u()},this.redraw=function(){l()&&u()},this.importColor=function(){this.valueElement?e.isElementType(this.valueElement,"input")?this.refine?!this.required&&/^\s*$/.test(this.valueElement.value)?(this.valueElement.value="",this.styleElement&&(this.styleElement.style.backgroundImage=this.styleElement._jscOrigStyle.backgroundImage,this.styleElement.style.backgroundColor=this.styleElement._jscOrigStyle.backgroundColor,this.styleElement.style.color=this.styleElement._jscOrigStyle.color),this.exportColor(e.leaveValue|e.leaveStyle)):this.fromString(this.valueElement.value)||this.exportColor():this.fromString(this.valueElement.value,e.leaveValue)||(this.styleElement&&(this.styleElement.style.backgroundImage=this.styleElement._jscOrigStyle.backgroundImage,this.styleElement.style.backgroundColor=this.styleElement._jscOrigStyle.backgroundColor,this.styleElement.style.color=this.styleElement._jscOrigStyle.color),this.exportColor(e.leaveValue|e.leaveStyle)):this.exportColor():this.exportColor()},this.exportColor=function(t){if(!(t&e.leaveValue)&&this.valueElement){var n=this.toString();this.uppercase&&(n=n.toUpperCase()),this.hash&&(n="#"+n),e.isElementType(this.valueElement,"input")?this.valueElement.value=n:this.valueElement.innerHTML=n}t&e.leaveStyle||this.styleElement&&(this.styleElement.style.backgroundImage="none",this.styleElement.style.backgroundColor="#"+this.toString(),this.styleElement.style.color=this.isLight()?"#000":"#FFF"),!(t&e.leavePad)&&l()&&a(),!(t&e.leaveSld)&&l()&&f()},this.fromHSV=function(e,t,n,r){if(e!==null){if(isNaN(e))return!1;e=Math.max(0,Math.min(360,e))}if(t!==null){if(isNaN(t))return!1;t=Math.max(0,Math.min(100,this.maxS,t),this.minS)}if(n!==null){if(isNaN(n))return!1;n=Math.max(0,Math.min(100,this.maxV,n),this.minV)}this.rgb=s(e===null?this.hsv[0]:this.hsv[0]=e,t===null?this.hsv[1]:this.hsv[1]=t,n===null?this.hsv[2]:this.hsv[2]=n),this.exportColor(r)},this.fromRGB=function(e,t,n,r){if(e!==null){if(isNaN(e))return!1;e=Math.max(0,Math.min(255,e))}if(t!==null){if(isNaN(t))return!1;t=Math.max(0,Math.min(255,t))}if(n!==null){if(isNaN(n))return!1;n=Math.max(0,Math.min(255,n))}var o=i(e===null?this.rgb[0]:e,t===null?this.rgb[1]:t,n===null?this.rgb[2]:n);o[0]!==null&&(this.hsv[0]=Math.max(0,Math.min(360,o[0]))),o[2]!==0&&(this.hsv[1]=o[1]===null?null:Math.max(0,this.minS,Math.min(100,this.maxS,o[1]))),this.hsv[2]=o[2]===null?null:Math.max(0,this.minV,Math.min(100,this.maxV,o[2]));var u=s(this.hsv[0],this.hsv[1],this.hsv[2]);this.rgb[0]=u[0],this.rgb[1]=u[1],this.rgb[2]=u[2],this.exportColor(r)},this.fromString=function(e,t){var n;if(n=e.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i))return n[1].length===6?this.fromRGB(parseInt(n[1].substr(0,2),16),parseInt(n[1].substr(2,2),16),parseInt(n[1].substr(4,2),16),t):this.fromRGB(parseInt(n[1].charAt(0)+n[1].charAt(0),16),parseInt(n[1].charAt(1)+n[1].charAt(1),16),parseInt(n[1].charAt(2)+n[1].charAt(2),16),t),!0;if(n=e.match(/^\W*rgba?\(([^)]*)\)\W*$/i)){var r=n[1].split(","),i=/^\s*(\d*)(\.\d+)?\s*$/,s,o,u;if(r.length>=3&&(s=r[0].match(i))&&(o=r[1].match(i))&&(u=r[2].match(i))){var a=parseFloat((s[1]||"0")+(s[2]||"")),f=parseFloat((o[1]||"0")+(o[2]||"")),l=parseFloat((u[1]||"0")+(u[2]||""));return this.fromRGB(a,f,l,t),!0}}return!1},this.toString=function(){return(256|Math.round(this.rgb[0])).toString(16).substr(1)+(256|Math.round(this.rgb[1])).toString(16).substr(1)+(256|Math.round(this.rgb[2])).toString(16).substr(1)},this.toHEXString=function(){return"#"+this.toString().toUpperCase()},this.toRGBString=function(){return"rgb("+Math.round(this.rgb[0])+","+Math.round(this.rgb[1])+","+Math.round(this.rgb[2])+")"},this.isLight=function(){return.213*this.rgb[0]+.715*this.rgb[1]+.072*this.rgb[2]>127.5},this._processParentElementsInDOM=function(){if(this._linkedElementsProcessed)return;this._linkedElementsProcessed=!0;var t=this.targetElement;do{var n=e.getStyle(t);n&&n.position.toLowerCase()==="fixed"&&(this.fixed=!0),t!==this.targetElement&&(t._jscEventsAttached||(e.attachEvent(t,"scroll",e.onParentScroll),t._jscEventsAttached=!0))}while((t=t.parentNode)&&!e.isElementType(t,"body"))};if(typeof t=="string"){var h=t,p=document.getElementById(h);p?this.targetElement=p:e.warn("Could not find target element with ID '"+h+"'")}else t?this.targetElement=t:e.warn("Invalid target element: '"+t+"'");if(this.targetElement._jscLinkedInstance){e.warn("Cannot link jscolor twice to the same element. Skipping.");return}this.targetElement._jscLinkedInstance=this,this.valueElement=e.fetchElement(this.valueElement),this.styleElement=e.fetchElement(this.styleElement);var d=this,v=this.container?e.fetchElement(this.container):document.getElementsByTagName("body")[0],m=3;if(e.isElementType(this.targetElement,"button"))if(this.targetElement.onclick){var g=this.targetElement.onclick;this.targetElement.onclick=function(e){return g.call(this,e),!1}}else this.targetElement.onclick=function(){return!1};if(this.valueElement&&e.isElementType(this.valueElement,"input")){var y=function(){d.fromString(d.valueElement.value,e.leaveValue),e.dispatchFineChange(d)};e.attachEvent(this.valueElement,"keyup",y),e.attachEvent(this.valueElement,"input",y),e.attachEvent(this.valueElement,"blur",c),this.valueElement.setAttribute("autocomplete","off")}this.styleElement&&(this.styleElement._jscOrigStyle={backgroundImage:this.styleElement.style.backgroundImage,backgroundColor:this.styleElement.style.backgroundColor,color:this.styleElement.style.color}),this.value?this.fromString(this.value)||this.exportColor():this.importColor()}};return e.jscolor.lookupClass="jscolor",e.jscolor.installByClassName=function(t){var n=document.getElementsByTagName("input"),r=document.getElementsByTagName("button");e.tryInstallOnElements(n,t),e.tryInstallOnElements(r,t)},e.register(),e.jscolor}());
    </script>
    <script>
var modalOverlay = document.getElementById("modal_overlay");
var modalOverlaySelected = false;

modalOverlay.onmousedown = function(e) {
  if(e.target == modalOverlay) {
    modalOverlaySelected = true;
  } else {
    modalOverlaySelected = false;
  }
}

modalOverlay.onmouseup = function(e) {
  if(modalOverlaySelected && e.target == modalOverlay) {
    if(Modal.current) {
      Modal.current.close();
    }
  }
  modalOverlaySelected = false;
}

function updateModalCheckboxField(list, parent) {
  if(parent) {
    if(!parent.cbElm.checked || parent.cbElm.disabled) {
      for(var i = 0; i < list.length; i++) {
        list[i].cbElm.disabled = true;
      }
    } else {
      for(var i = 0; i < list.length; i++) {
        list[i].cbElm.disabled = false;
      }
    }
  }
  for(var i = 0; i < list.length; i++) {
    updateModalCheckboxField(list[i].children, list[i]);
  }
}

function Modal() {
  this.inputField = null;
  this.formTitle = null;
  this.formField = null;
  this.formInputs = [];

  this.footerCont = [];
  this.footerField = null;

  this.isOpen = false;
  this.hasSubmitted = false;

  this.submitFn = null;
  this.openFn = null;
  this.closeFn = null;
  this.tabChangeFn = null;

  this.cbField = null;
  this.cbList = [];
  this.cbCallback = null;

  this.tabList = [];
  this.tabIndex = {};
  this.currentTabCtx = null;

  var frame = document.createElement("div");
  frame.className = "modal_frame";
  frame.style.flexDirection = "column";
  frame.style.display = "none";
  frame.style.position = "absolute";
  frame.style.minWidth = "16px";
  frame.style.minHeight = "16px";

  var fClient = document.createElement("div");
  fClient.className = "modal_client";
  fClient.style.flex = "1";
  fClient.style.margin = "6px";
  fClient.style.padding = "12px";
  fClient.style.position = "relative";

  var tField = document.createElement("div");
  tField.className = "modal_tab_field";
  tField.style.display = "none";
  tField.style.margin = "6px";
  tField.style.marginBottom = "0px";
  tField.style.paddingLeft = "4px";
  tField.style.display = "none"; // TODO
  tField.style.alignItems = "flex-end";

  frame.appendChild(tField);
  frame.appendChild(fClient)
  modalOverlay.appendChild(frame);

  this.frame = frame;
  this.client = fClient;
  this.tabField = tField;

  Modal.list.push(this);
  return this;
}

Modal.closeAll = function() {
  for(var i = 0; i < Modal.list.length; i++) {
    var modal = Modal.list[i];
    modal.close();
  }
}
Modal.isOpen = false;
Modal.current = null;
Modal.list = [];

/*
  Creates a form section in the modal.
  Modals are currently limited to one form only.
*/
Modal.prototype.createForm = function() {
  if(this.formField) return;
  var self = this;
  var formField = document.createElement("div");
  var inputField = document.createElement("div");
  var title = document.createElement("div");
  var subField = document.createElement("div");

  inputField.style.display = "grid";
  inputField.style.gap = "2px";
  inputField.style.marginBottom = "2px";

  var subm = document.createElement("button");
  subm.innerText = "Go";
  subm.style.paddingLeft = "11px";
  subm.style.paddingRight = "11px";
  subm.onclick = function() {
    self.submitForm();
  }
  var canc = document.createElement("span");
  canc.innerText = "cancel";
  canc.style.color = "blue";
  canc.style.textDecoration = "underline";
  canc.style.cursor = "pointer";
  canc.onclick = function() {
    self.cancelForm();
  }
  subField.appendChild(subm);
  subField.append(" or ");
  subField.appendChild(canc);

  formField.appendChild(title);
  formField.appendChild(inputField);
  formField.appendChild(subField);
  this.formTitle = title;
  this.formField = formField;
  this.inputField = inputField;
  this.subField = subField;
  this.client.appendChild(formField);
  this.alignForm();
}

/*
  Validates, processes, and submits the form.
  This triggers the onSubmit callback.
*/
Modal.prototype.submitForm = function() {
  if(this.hasSubmitted) return;

  // validation
  var formFailed = false;
  for(var i = 0; i < this.formInputs.length; i++) {
    var fInput = this.formInputs[i];
    var val = fInput.input.value;
    var failed = false;
    if(fInput.validation == "number") {
      var num = parseFloat(val);
      if(!isFinite(num) || isNaN(num)) {
        failed = true;
      }
    } else if(fInput.validation == "required") {
      failed = !val;
    }
    if(failed) {
      fInput.validationFailed = true;
      fInput.input.style.border = "1px solid red";
      formFailed = true;
    } else if(fInput.validationFailed) {
      fInput.validationFailed = false;
      fInput.input.style.border = "";
    }
  }
  if(formFailed) {
    return;
  }

  this.hasSubmitted = true;
  if(this.submitFn) {
    var argList = {};
    for(var i = 0; i < this.formInputs.length; i++) {
      var fInput = this.formInputs[i];
      argList[fInput.label] = fInput.input.value;
      argList[i] = fInput.input.value;
    }
    argList.length = this.formInputs.length;
    this.submitFn(argList);
  }
  if(this.isOpen) {
    this.close();
  }
}

/*
  Revert the form and close the modal.
*/
Modal.prototype.cancelForm = function() {
  // revert the form values
  this.close(true);
}

/*
  Line up all form labels.
  The form labels are set to the left and the inputs are set to the right.
*/
Modal.prototype.alignForm = function() {
  if(!this.formField) {
    throw "No form exists";
  }
  this.inputField.style.gridTemplateColumns = "0fr 1fr";
}

/*
  Set each form label on its own line.
*/
Modal.prototype.unalignForm = function() {
  if(!this.formField) {
    throw "No form exists";
  }
  this.inputField.style.gridTemplateColumns = "";
}

/*
  Add an input entry to the form.
  label: The label to be shown next to the input.
  type (optional): 'text' or 'color'.
  validation (optional): 'number'. Check if the entry contains a valid value.
*/
Modal.prototype.addEntry = function(label, type, validation) {
  if(!this.formField) {
    throw "No form exists";
  }
  var self = this;
  var lab = document.createElement("label");
  lab.innerText = label + ":";
  lab.style.marginRight = "3px";
  lab.style.whiteSpace = "nowrap";
  var inp = document.createElement("input");
  inp.style.width = "150px";
  var isColor = false;
  if(!type) {
    type = "text";
  }
  if(type == "color") {
    inp.className = "jscolor";
    isColor = true;
  }
  inp.onkeydown = function(e) {
    if(e.key == "Enter") {
      self.submitForm();
    }
  }
  this.inputField.appendChild(lab);
  this.inputField.appendChild(inp);
  if(isColor) {
    window.jscolor.installByClassName("jscolor");
  }
  this.formInputs.push({
    input: inp,
    value: inp.value,
    validation: validation,
    validationFailed: false,
    type: type,
    label: label
  });
  return {
    input: inp
  };
}

/*
  Sets the fixed size of the modal.
  Any overflown content will be hidden.
  Setting either dimension to zero will reset that dimension.
*/
Modal.prototype.setSize = function(width, height) {
  if(width) {
    this.frame.style.width = width + "px";
  } else {
    this.frame.style.width = "";
  }
  if(height) {
    this.frame.style.height = height + "px";
  } else {
    this.frame.style.height = "";
  }
}

/*
  Sets the minimum size of the modal.
  The modal cannot be smaller than this size.
  Setting either dimension to zero will reset that dimension.
*/
Modal.prototype.setMinimumSize = function(width, height) {
  if(width) {
    this.frame.style.minWidth = width + "px";
  } else {
    this.frame.style.minWidth = "";
  }
  if(height) {
    this.frame.style.minHeight = height + "px";
  } else {
    this.frame.style.minHeight = "";
  }
}

/*
  Sets the maximum size of the modal.
  The modal cannot be bigger than this size. Overflown content will be hidden.
  Setting either dimension to zero will reset that dimension.
*/
Modal.prototype.setMaximumSize = function(width, height) {
  if(width) {
    this.frame.style.maxWidth = width + "px";
  } else {
    this.frame.style.maxWidth = "";
  }
  if(height) {
    this.frame.style.maxHeight = height + "px";
  } else {
    this.frame.style.maxHeight = "";
  }

  // ensure client area doesn't overflow
  if(width && height) {
    this.client.style.overflow = "hidden";
  } else if(width) {
    this.client.style.overflowX = "hidden";
    this.client.style.overflowY = "";
  } else if(height) {
    this.client.style.overflowX = "";
    this.client.style.overflowY = "hidden";
  } else {
    this.client.style.overflow = "";
  }
}

/*
  Set a title or description at the top of the modal.
*/
Modal.prototype.setFormTitle = function(title, opts) {
  if(title == void 0) {
    title = "";
  }
  title += "";
  if(title[title.length - 1] == "\n" && title.length > 1) {
    title += "\n"; // add an extra newline due to html behavior
  }
  this.formTitle.innerText = title;
  if(opts) {
    if("bold" in opts) {
      if(opts.bold) {
        this.formTitle.style.fontWeight = "bold";
        this.formTitle.style.marginBottom = "4px";
      } else {
        this.formTitle.style.fontWeight = "";
        this.formTitle.style.marginBottom = "";
      }
    }
    if("center" in opts) {
      if(opts.center) {
        this.formTitle.style.textAlign = "center";
      } else {
        this.formTitle.style.textAlign = "";
      }
    }
  }
}

/*
  Add a footer to the bottom of the modal.
  The footer is split into three parts (left, center, right).
*/
Modal.prototype.setFooter = function() {
  if(this.footerField) return;
  var footer = document.createElement("div");
  footer.style.margin = "6px";
  footer.style.minHeight = "18px";
  footer.style.display = "flex";
  footer.style.justifyContent = "space-between";

  var cLeft = document.createElement("div");
  var cMid = document.createElement("div");
  var cRight = document.createElement("div");
  cLeft.style.display = "flex";
  cLeft.style.alignItems = "center";
  cMid.style.display = "flex";
  cMid.style.alignItems = "center";
  cRight.style.display = "flex";
  cRight.style.alignItems = "center";

  this.footerCont = [cLeft, cMid, cRight];
  footer.appendChild(cLeft);
  footer.appendChild(cMid);
  footer.appendChild(cRight);
  this.client.style.marginBottom = "0px";
  this.frame.appendChild(footer);
  this.footerField = footer;
}

/*
  Removes the footer from the modal.
*/
Modal.prototype.removeFooter = function() {
  if(!this.footerField) return;
  this.frame.removeChild(this.footerField);
  this.footerCont = [];
}

/*
  Adds a checkbox to the left section of the footer.
  labelName: name of the checkbox.
  callback: to be called when the checkbox is checked (parameter: checked)
*/
Modal.prototype.setFooterCheckbox = function(labelName, callback, defaultState) {
  if(!this.footerField) {
    this.setFooter();
  }
  var lab = document.createElement("label");
  lab.className = "modal_corner_checkbox_label";
  var cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = Boolean(defaultState);
  cb.oninput = function() {
    if(callback) {
      callback(cb.checked);
    }
  }
  lab.appendChild(cb);
  lab.append(" " + labelName);
  this.footerCont[0].appendChild(lab);
}

/*
  Adds content to a section of the footer.
*/
Modal.prototype.setFooterContentLeft = function(data) {
  if(!this.footerField) throw "No footer exists";
  this.footerCont[0].appendChild(data);
}
Modal.prototype.setFooterContentCenter = function(data) {
  if(!this.footerField) throw "No footer exists";
  this.footerCont[1].appendChild(data);
}
Modal.prototype.setFooterContentRight = function(data) {
  if(!this.footerField) throw "No footer exists";
  this.footerCont[2].appendChild(data);
}

/*
  Clears a section of the footer.
*/
Modal.prototype.removeFooterContentLeft = function() {
  if(!this.footerField) return;
  this.footerCont[0].innerHTML = "";
}
Modal.prototype.removeFooterContentCenter = function() {
  if(!this.footerField) return;
  this.footerCont[1].innerHTML = "";
}
Modal.prototype.removeFooterContentRight = function() {
  if(!this.footerField) return;
  this.footerCont[2].innerHTML = "";
}

/*
  Set event callbacks.
  onSubmit: to be called whenever the form is submitted.
  onOpen: to be called whenever the modal is opened.
  onClose: to be called whenever the modal is closed.
  onTabChange: to be called whenever another tab is selected.
*/
Modal.prototype.onSubmit = function(callback) {
  this.submitFn = callback;
}
Modal.prototype.onOpen = function(callback) {
  this.openFn = callback;
}
Modal.prototype.onClose = function(callback) {
  this.closeFn = callback;
}
Modal.prototype.checkboxFieldOnInput = function(callback) {
  this.cbCallback = callback;
}
Modal.prototype.onTabChange = function(callback) {
  this.tabChangeFn = callback;
}

/*
  Display the modal.
  All parameters will be passed to the onOpen event.
*/
Modal.prototype.open = function(...params) {
  if(Modal.isOpen) {
    Modal.closeAll();
  }
  Modal.isOpen = true;
  Modal.current = this;
  modalOverlay.style.display = "";
  this.hasSubmitted = false;
  this.isOpen = true;
  this.frame.style.display = "flex"; // make visible
  if(this.formInputs.length) {
    var firstForm = this.formInputs[0].input;
    firstForm.focus();
  }
  for(var i = 0; i < this.formInputs.length; i++) {
    var fInput = this.formInputs[i];
    fInput.value = fInput.input.value;
  }
  if(this.openFn) {
    this.openFn(...params);
  }
}

/*
  Hide the modal.
  canceled: This modal has closed as a result of form cancelation. This will revert the values of the form inputs.
*/
Modal.prototype.close = function(canceled) {
  if(!this.isOpen) return;
  this.isOpen = false;
  this.frame.style.display = "none";
  Modal.isOpen = false;
  Modal.current = null;
  modalOverlay.style.display = "none";
  // revert all values if canceled, otherwise record them
  for(var i = 0; i < this.formInputs.length; i++) {
    var fInput = this.formInputs[i];
    if(canceled) {
      if(fInput.type == "color") {
        fInput.input.jscolor.fromString(fInput.value);
      } else {
        fInput.input.value = fInput.value;
      }
    } else {
      fInput.value = fInput.input.value;
    }
  }
  if(this.closeFn) {
    this.closeFn(canceled);
  }
}

/*
  Add a checkbox section to the modal.
  The checkbox section contains a nestable list of checkbox inputs.
  Only one checkbox field is currently supported.
*/
Modal.prototype.createCheckboxField = function() {
  if(this.cbField) return;
  var field = document.createElement("div");
  this.cbField = field;
  this.client.appendChild(field);
}

/*
  Adds a checkbox to the checkbox field.
  label: The name of the checkbox.
  parent (optional): The parent checkbox. Nested checkboxes will be indented.
*/
Modal.prototype.addCheckbox = function(label, parent) {
  if(!this.cbField) {
    throw "No checkbox field exists";
  }
  var self = this;
  var cbTitle = label;
  var cbParent = null;
  if(parent) {
    cbParent = parent;
  }

  var label = document.createElement("label");
  var cb = document.createElement("input");
  cb.type = "checkbox";
  label.style.display = "block";
  label.style.userSelect = "none";
  label.appendChild(cb);
  label.append(" " + cbTitle);

  var threshold = 0;
  var cbObj = {
    elm: label,
    cbElm: cb,
    children: []
  };
  if(cbParent) {
    threshold = cbParent.level + 1;
    label.style.marginLeft = (20 * threshold) + "px";
    if(cbParent.children.length) {
      var lastChild = cbParent.children[cbParent.children.length - 1];
      var nextElm = lastChild.nextSibling;
      if(nextElm) {
        lastChild.elm.insertBefore(label, nextElm);
      } else {
        this.cbField.appendChild(label);
      }
    } else {
      var nextElm = cbParent.elm.nextSibling;
      if(nextElm) {
        cbParent.elm.insertBefore(label, nextElm);
      } else {
        this.cbField.appendChild(label);
      }
    }
    cbObj.level = threshold;
    cbParent.children.push(cbObj);
  } else {
    this.cbField.appendChild(label);
    cbObj.level = threshold;
    this.cbList.push(cbObj);
  }

  cb.onclick = function() {
    if(self.cbCallback) {
      self.cbCallback(cbObj, cb.checked);
    }
    updateModalCheckboxField(cbObj.children, cbObj);
  }

  updateModalCheckboxField(this.cbList);

  return cbObj;
}

/*
  Insert a new tab to the modal along with a new client area.
  If no tab exists, the current client area becomes part of the first tab.
*/
Modal.prototype.addTab = function(id, title) {
  if(this.tabIndex[id]) {
    throw "Tab already exists with the same id ('" + id + "')";
  }
  var self = this;
  var tabBtn = document.createElement("div");
  tabBtn.className = "modal-tab-btn";
  tabBtn.innerText = title;
  tabBtn.style.display = "inline-block";

  var tabContext = null;
  if(this.tabList.length == 0) { // initial tab
    tabBtn.style.backgroundColor = "#E5E5FF";
    tabBtn.style.height = "24px";

    tabContext = {
      id: id,
      tabButton: tabBtn,
      client: this.client,
      inputField: this.inputField,
      formTitle: this.formTitle,
      formField: this.formField,
      formInputs: this.formInputs,
      hasSubmitted: this.hasSubmitted,
      cbField: this.cbField,
      cbList: this.cbList,
      cbCallback: this.cbCallback
    };

    this.currentTabCtx = tabContext;
  } else { // extra tabs
    tabBtn.style.height = "18px";

    var fClient = document.createElement("div");
    fClient.className = "modal_client";
    fClient.style.flex = "1";
    fClient.style.margin = "6px";
    fClient.style.padding = "12px";
    fClient.style.position = "relative";
    fClient.style.marginTop = "0px";
    fClient.style.display = "none";

    if(this.footerField) {
      fClient.style.marginBottom = "0px";
      this.frame.removeChild(this.footerField);
    }
    this.frame.appendChild(fClient);
    if(this.footerField) {
      this.frame.appendChild(this.footerField);
    }

    tabContext = {
      id: id,
      tabButton: tabBtn,
      client: fClient,
      inputField: null,
      formTitle: null,
      formField: null,
      formInputs: [],
      hasSubmitted: false,
      cbField: null,
      cbList: [],
      cbCallback: null
    };
  }
  tabBtn.style.paddingLeft = "4px";
  tabBtn.style.paddingRight = "4px";
  tabBtn.style.paddingTop = "2px";
  tabBtn.style.paddingBottom = "2px";
  tabBtn.style.fontSize = "1em";
  this.tabField.style.display = "flex";

  tabBtn.onclick = function() {
    self.focusTab(id);
  }

  this.client.style.marginTop = "0px";

  this.tabField.appendChild(tabBtn);

  this.tabList.push(tabContext);
  this.tabIndex[id] = tabContext;
}

/*
  Make the tab the current visible tab.
*/
Modal.prototype.focusTab = function(id) {
  if(this.currentTabCtx == this.tabIndex[id]) {
    return;
  }

  if(this.tabChangeFn) {
    this.tabChangeFn({
      id: id
    });
  }

  var prev = this.currentTabCtx;
  var curr = this.tabIndex[id];
  this.currentTabCtx = this.tabIndex[id];

  prev.client.style.display = "none";
  prev.tabButton.style.height = "18px";
  prev.tabButton.style.backgroundColor = "";

  curr.client.style.display = "";
  curr.tabButton.style.height = "24px";
  curr.tabButton.style.backgroundColor = "#E5E5FF";

  // transfer context
  this.client = curr.client;
  this.inputField = curr.inputField;
  this.formTitle = curr.formTitle;
  this.formField = curr.formField;
  this.formInputs = curr.formInputs;
  this.hasSubmitted = curr.hasSubmitted;
  this.cbField = curr.cbField;
  this.cbList = curr.cbList;
  this.cbCallback = curr.cbCallback;
}

/*
  If there are any defined tabs, return the ID of the currently active tab.
*/
Modal.prototype.getCurrentTabId = function() {
  if(!this.currentTabCtx) return null;
  return this.currentTabCtx.id;
}

/*
  Hide tab from the tab bar. This will not bring you to the next available tab.
*/
Modal.prototype.hideTab = function(id) {
  if(!this.tabIndex[id]) return;
  this.tabIndex[id].tabButton.style.display = "none";
}

/*
  Show tab on the tab bar.
*/
Modal.prototype.showTab = function(id) {
  if(!this.tabIndex[id]) return;
  this.tabIndex[id].tabButton.style.display = "";
}

/*
  Return raw tab data.
*/
Modal.prototype.getTabData = function(id) {
  return this.tabIndex[id] || null;
}

/*
  Insert content to the modal.
*/
Modal.prototype.append = function(elm) {
  this.client.appendChild(elm);
}

/*
  Adds a close caption to the bottom right of the modal.
*/
Modal.prototype.createClose = function() {
  var span = document.createElement("span");
  span.className = "modal_close";
  span.innerText = "Close";
  var self = this;
  span.onclick = function() {
    self.close();
  }
  this.client.appendChild(span);
}

    </script>
    <script>
function Menu(titleEl, menuEl) {
  var _this = this;
  this.titleEl = titleEl;
  this.menuEl = menuEl;
  this.pinEl = null;
  this._SPEED = 250;
  this.entries = [];
  this.pinned = false;
  this.visible = false;
  this.lastEntryId = 1;
  this.entriesById = {};
  this.addOption = function(text, action) {
    var s = document.createElement("div");
    s.innerText = text;
    s.onclick = function() {
      action();
      _this.hideNow();
    }
    return _this.addEntry(s);
  }
  this.addCheckboxOption = function(text, checkedAction, uncheckedAction, checked) {
    var s = document.createElement("div");
    if(text.charAt(0) == " ") {
      text = text.substr(1);
    }
    s.innerText = " " + text;
    var i = document.createElement("input");
    i.type = "checkbox";
    i.checked = !!checked;
    s.insertBefore(i, s.firstChild);
    s.checked = !!checked;
    s.onclick = function(e) {
      if(e.target !== i) {
        i.checked = !i.checked;
      }
      if(i.checked) {
        checkedAction();
      } else {
        uncheckedAction();
      }
    }
    return _this.addEntry(s);
  }
  this.hideNow = function() {
    if(_this.pinned) return;
    _this.visible = false;
    slideMenu("up", _this.menuEl, _this._SPEED);
    _this.titleEl.classList.remove("hover");
  }
  this.cancelHide = false;
  this.hide = function() {
    if(_this.pinned) return;
    _this.cancelHide = false;
    setTimeout((function() {
      if (!_this.cancelHide) {
        _this.hideNow();
      }
    }), 500);
  }
  this.show = function() {
    _this.visible = true;
    _this.cancelHide = true;
    slideMenu("down", _this.menuEl, _this._SPEED);
    _this.titleEl.classList.add("hover");
  }
  this.getEntryContainer = function() {
    var mainUl = _this.menuEl.getElementsByTagName("ul");
    var entryLi = null;
    if(mainUl.length) {
      entryLi = document.createElement("li");
      mainUl[0].appendChild(entryLi);
    }
    return entryLi;
  }
  this.addEntry = function(liContents) {
    var entryLi = _this.getEntryContainer();
    if(!entryLi) {
      throw "Cannot locate space for new entry";
    }
    if(typeof liContents == "string") {
      var lcDiv = document.createElement("div");
      lcDiv.innerHTML = liContents;
      var ch = lcDiv.children;
      var len = ch.length;
      for(var r = 0; r < len; r++) {
        var elm = ch[0];
        entryLi.appendChild(elm);
      }
    } else {
      entryLi.appendChild(liContents);
    }
    var entryData = {
      element: entryLi,
      content: liContents
    };
    _this.entries.push(entryData);
    entryLi.onmouseenter = function() {
      this.classList.add("hover");
    }
    entryLi.onmouseleave = function() {
      this.classList.remove("hover");
    }
    var eid = _this.lastEntryId++;
    _this.entriesById[eid] = entryData;
    return eid;
  }
  this.hideEntry = function(id) {
    var entry = _this.entriesById[id];
    if(!entry) return;
    var elm = entry.element;
    elm.style.display = "none";
  }
  this.showEntry = function(id) {
    var entry = _this.entriesById[id];
    if(!entry) return;
    var elm = entry.element;
    elm.style.display = "";
  }
  this.setEntryVisibility = function(id, visible) {
    if(visible) {
      _this.showEntry(id);
    } else {
      _this.hideEntry(id);
    }
  }
  this.moveEntryLast = function(id) {
    var entry = _this.entriesById[id];
    if(!entry) return;
    var elm = entry.element;
    var mainUl = _this.menuEl.getElementsByTagName("ul")[0];
    if(!mainUl) {
      throw "Entry container not found";
    }
    elm.remove();
    mainUl.appendChild(elm);
  }
  this.pin = function() {
    _this.pinned = true;
    _this.show();
    if(!_this.pinEl) {
      var pin = _this.titleEl.getElementsByClassName("menuPin");
      if(pin.length) {
        _this.pinEl = pin[0];
      }
    }
    if(_this.pinEl) {
      _this.pinEl.style.display = "";
    }
  }
  this.unpin = function(noHide) {
    _this.pinned = false;
    if(!noHide) {
      _this.hide();
    }
    if(_this.pinEl) {
      _this.pinEl.style.display = "none";
    }
  }
  this.titleEl.style.display = "";

  this.menuEl.style.top = (this.titleEl.getBoundingClientRect().top + document.body.scrollTop) + this.titleEl.offsetHeight + "px";

  // "Menu" button
  this.titleEl.onmouseenter = this.show;
  this.titleEl.onmouseleave = this.hide;

  // menu list
  this.menuEl.onmouseenter = this.show;
  this.menuEl.onmouseleave = this.hide;

  this.titleEl.onclick = function() {
    if(!_this.visible) {
      _this.show();
      return;
    }
    if(_this.pinned) {
      _this.unpin(true);
    } else {
      _this.pin();
    }
  }
}

var menuAnimationState = "up";
var menuAnimationActive = false;
function slideMenu(direction, element, speed) {
  if(menuAnimationActive) return;
  var interval = 13;
  var menuMargin = 2;
  if(menuAnimationState == "up" && direction == "up") return;
  if(menuAnimationState == "down" && direction == "down") return;

  menuAnimationActive = true;
  menuAnimationState = direction;

  element.style.overflow = "hidden";
  element.style.marginTop = "0px";
  element.style.marginBottom = "0px";

  element.style.display = "block";
  var destHeight = element.offsetHeight - menuMargin * 2;
  if(direction == "down") element.style.height = "0px";
  var start = getDate();
  var end = start + speed;
  var lapse = end - start;
  var menu_int = setInterval(function() {
    element.style.display = "block";
    var duration = getDate() - start;
    if(duration >= lapse) {
      menuAnimationActive = false;
      clearInterval(menu_int);
      if(direction == "down") {
        element.style.display = "";
      } else if(direction == "up") {
        element.style.display = "none";
      }
      element.style.overflow = "";
      element.style.marginTop = "";
      element.style.marginBottom = "";
      element.style.height = "";
      element.style.paddingTop = "";
      element.style.paddingBottom = "";
      return;
    }
    var multiply = easeOutQuad(duration, 0, 1, speed);

    var currentHeight = multiply * destHeight;
    var currentPadding = multiply * menuMargin;

    if(direction == "up") {
      currentHeight = destHeight - currentHeight;
      currentPadding = menuMargin - currentPadding;
    }
    element.style.height = currentHeight + "px";
    element.style.paddingTop = currentPadding + "px";
    element.style.paddingBottom = currentPadding + "px";
  }, interval);
}
    </script>
    <script>
var PERM = {
  ADMIN: 2,
  MEMBERS: 1,
  PUBLIC: 0
};
var Permissions = {
  can_admin: function(user) {
    return user.is_owner;
  },
  can_coordlink: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.feature_coord_link);
  },
  can_edit_tile: function(user, world, tile, charX, charY) {
    if(!tile) {
      throw new Error("Can't check perms on un-initted tile");
    }
    if(!Permissions.can_read(user, world)) {
      return false;
    }
    var targetWritability;
    if(tile.char) {
      targetWritability = tile.char[charY * tileC + charX];
      if(targetWritability == null) targetWritability = tile.writability; // inherit from tile
      if(targetWritability == null) targetWritability = world.writability; // inherit from world
    } else {
      targetWritability = tile.writability;
      if(targetWritability == null) targetWritability = world.writability;
    }
    return Permissions.user_matches_perm(user, world, targetWritability);
  },
  can_go_to_coord: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.feature_go_to_coord);
  },
  can_paste: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.feature_paste);
  },
  can_protect_tiles: function(user, world) {
    if(user.is_owner) return true;
    return world.feature_membertiles_addremove && user.is_member;
  },
  can_read: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.readability);
  },
  can_urllink: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.feature_url_link);
  },
  can_write: function(user, world) {
    if(!Permissions.can_read(user, world)) {
      return false;
    }
    return Permissions.user_matches_perm(user, world, world.writability);
  },
  can_chat: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.chat_permission);
  },
  can_show_cursor: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.show_cursor);
  },
  can_color_text: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.color_text);
  },
  can_color_cell: function(user, world) {
    return Permissions.user_matches_perm(user, world, world.color_cell);
  },
  user_matches_perm: function(user, world, perm) {
    if(perm == -1) { // no one
      return false;
    }
    if(perm == PERM.PUBLIC) { // anyone
      return true;
    }
    if(user.is_owner) {
      return true;
    }
    if(perm == PERM.ADMIN) {
      return false;
    }
    if(perm == PERM.MEMBERS && user.is_member) {
      return true;
    }
    return false;
  }
};

    </script>
    <script>
var selectedChatTab      = 0; // 0 is the page chat, 1 is the global chat
var chatOpen             = 0;
var chatPageUnread       = 0;
var chatGlobalUnread     = 0;
var initPageTabOpen      = false;
var initGlobalTabOpen    = false;
var chatWriteHistory     = []; // history of user's chats
var chatRecordsPage      = [];
var chatRecordsGlobal    = [];
var chatWriteHistoryMax  = 100; // maximum size of chat write history length
var chatHistoryLimit     = 3500;
var chatWriteHistoryIdx  = -1; // location in chat write history
var chatLimitCombChars   = true;
var chatWriteTmpBuffer   = "";
var defaultChatColor     = window.localStorage ? parseInt(localStorage.getItem("chatcolor")) : null; // 24-bit Uint
var chatPageUnreadBar    = null;
var chatGlobalUnreadBar  = null;
var chatGreentext        = true;
var chatEmotes           = true;
var acceptChatDeletions  = true;

if(isNaN(defaultChatColor)) {
  defaultChatColor = null;
} else {
  if(defaultChatColor < 0) defaultChatColor = 0;
  if(defaultChatColor > 16777215) defaultChatColor = 16777215;
}

defineElements({ // elm[<name>]
  chat_window: byId("chat_window"),
  chat_open: byId("chat_open"),
  chatsend: byId("chatsend"),
  chatbar: byId("chatbar"),
  chat_close: byId("chat_close"),
  page_chatfield: byId("page_chatfield"),
  global_chatfield: byId("global_chatfield"),
  chat_page_tab: byId("chat_page_tab"),
  chat_global_tab: byId("chat_global_tab"),
  usr_online: byId("usr_online"),
  total_unread: byId("total_unread"),
  page_unread: byId("page_unread"),
  global_unread: byId("global_unread"),
  chat_upper: byId("chat_upper")
});

if(Permissions.can_chat(state.userModel, state.worldModel)) {
  OWOT.on("chat", function(e) {
    w.emit("chatMod", e);
    if(e.hide) return;
    event_on_chat(e);
  });
}

if(state.userModel.is_staff) {
  elm.chatbar.maxLength = 3030;
} else {
  elm.chatbar.maxLength = 400;
}

var canChat = Permissions.can_chat(state.userModel, state.worldModel);
if(!canChat) {
  selectedChatTab = 1;
  elm.chat_window.style.display = "none";
} else {
  elm.chat_open.style.display = "";
}

if(state.worldModel.no_chat_global) {
  elm.chat_page_tab.style.display = "none";
  elm.chat_global_tab.style.display = "none";
  elm.usr_online.style.paddingLeft = "0px";
  elm.chat_upper.style.textAlign = "center";
}

function api_chat_send(message, opts) {
  if(!message) return;
  if(!opts) opts = {};
  var exclude_commands = opts.exclude_commands;
  var nick = opts.nick || YourWorld.Nickname || state.userModel.username;
  var location = opts.location ? opts.location : (selectedChatTab == 0 ? "page" : "global");

  var msgLim = state.userModel.is_staff ? 3030 : 400;

  message = message.trim();
  if(!message.length) return;
  message = message.slice(0, msgLim);
  chatWriteHistory.push(message);
  if(chatWriteHistory.length > chatWriteHistoryMax) {
    chatWriteHistory.shift();
  }
  chatWriteHistoryIdx = -1;
  chatWriteTmpBuffer = "";

  var chatColor;
  if(!opts.color) {
    if(!YourWorld.Color) {
      chatColor = assignColor(nick);
    } else {
      chatColor = "#" + ("00000" + YourWorld.Color.toString(16)).slice(-6);
    }
  } else {
    chatColor = opts.color;
  }

  if(!exclude_commands && message.startsWith("/")) {
    var args = message.substr(1).split(" ");
    var command = args[0].toLowerCase();
    args.shift();
    if(client_commands.hasOwnProperty(command)) {
      client_commands[command](args);
      return;
    }
  }

  network.chat(message, location, nick, chatColor);
}

function clientChatResponse(message) {
  addChat(null, 0, "user", "[ Client ]", message, "Client", false, false, false, null, getDate());
}

var client_commands = {
  nick: function (args) {
    var newDisplayName = args.join(" ");
    if(!newDisplayName) {
      newDisplayName = "";
    }
    var nickLim = state.userModel.is_staff ? Infinity : 40;
    newDisplayName = newDisplayName.slice(0, nickLim);
    YourWorld.Nickname = newDisplayName;
    storeNickname();
    var nickChangeMsg;
    if(newDisplayName) {
      nickChangeMsg = "Set nickname to `" + newDisplayName + "`";
    } else {
      nickChangeMsg = "Nickname reset";
    }
    clientChatResponse(nickChangeMsg);
  },
  ping: function() {
    var pingTime = getDate();
    network.ping(function(resp, err) {
      if(err) {
        return clientChatResponse("Ping failed");
      }
      var pongTime = getDate();
      var pingMs = pongTime - pingTime;
      clientChatResponse("Ping: " + pingMs + " MS");
    });
  },
  gridsize: function (args) {
    var size = args[0];
    if(!size) size = "10x18";
    size = size.split("x");
    var width = parseInt(size[0]);
    var height = parseInt(size[1]);
    if(!width || isNaN(width) || !isFinite(width)) width = 10;
    if(!height || isNaN(height) || !isFinite(height)) height = 18;
    if(width < 4) width = 4;
    if(width > 160) width = 160;
    if(height < 4) height = 4;
    if(height > 144) height = 144;
    defaultSizes.cellW = width;
    defaultSizes.cellH = height;
    updateScaleConsts();
    w.reloadRenderer();
    clientChatResponse("Changed grid size to " + width + "x" + height);
  },
  color: function(args) {
    var color = args.join(" ");
    color = resolveColorValue(color);
    YourWorld.Color = color;
    clientChatResponse("Changed text color to #" + ("00000" + YourWorld.Color.toString(16)).slice(-6).toUpperCase());
  },
  chatcolor: function(args) {
    var color = args.join(" ");
    if(!color) {
      localStorage.removeItem("chatcolor");
      defaultChatColor = null;
      clientChatResponse("Chat color reset");
    } else {
      defaultChatColor = resolveColorValue(color);
      localStorage.setItem("chatcolor", defaultChatColor);
      clientChatResponse("Changed chat color to #" + ("00000" + defaultChatColor.toString(16)).slice(-6).toUpperCase());
    }
  },
  warp: function(args) {
    var address = args[0];
    if(!address) address = "";
    positionX = 0;
    positionY = 0;
    if(address.charAt(0) == "/") address = address.substr(1);
    state.worldModel.pathname = "/" + address;
    ws_path = createWsPath();
    w.changeSocket(ws_path, true);
    getWorldProps(address, "style", function(style, error) {
      if(!error) {
        styles.member = style.member;
        styles.owner = style.owner;
        styles.public = style.public;
        styles.text = style.text;
      }
      menu_color(styles.menu);
      w.redraw();
    });
    clientChatResponse("Switching to world: \"" + address + "\"");
  },
  night: function() {
    w.night();
  },
  day: function() {
    w.day(true);
  }
}

function sendChat() {
  var chatText = elm.chatbar.value;
  elm.chatbar.value = "";
  var opts = {};
  if(defaultChatColor != null) {
    opts.color = "#" + ("00000" + defaultChatColor.toString(16)).slice(-6);
  }
  api_chat_send(chatText, opts);
}

function updateUnread() {
  var total = elm.total_unread;
  var page = elm.page_unread;
  var global = elm.global_unread;
  var totalCount = chatPageUnread + chatGlobalUnread;
  total.style.display = "none";
  global.style.display = "none";
  page.style.display = "none";
  if(totalCount) {
    total.style.display = "";
    total.innerText = totalCount > 99 ? "99+" : "(" + totalCount + ")";
  }
  if(chatPageUnread) {
    page.style.display = "";
    page.innerText = chatPageUnread > 99 ? "99+" : "(" + chatPageUnread + ")";
  }
  if(chatGlobalUnread) {
    global.style.display = "";
    global.innerText = chatGlobalUnread > 99 ? "99+" : "(" + chatGlobalUnread + ")";
  }
}

function event_on_chat(data) {
  if((!chatOpen || selectedChatTab == 1) && data.location == "page") {
    chatPageUnread++;
  }
  if((!chatOpen || selectedChatTab == 0) && data.location == "global" && !state.worldModel.no_chat_global) {
    chatGlobalUnread++;
  }
  updateUnread();
  addChat(data.location, data.id, data.type,
    data.nickname, data.message, data.realUsername, data.op, data.admin, data.staff, data.color, data.date || Date.now(), data.dataObj);
}

elm.chatsend.addEventListener("click", function() {
  sendChat();
});

elm.chatbar.addEventListener("keypress", function(e) {
  var keyCode = e.keyCode;
  if(keyCode == 13) { // Enter
    sendChat();
  }
});

function moveCaretEnd(elm) {
  if(elm.selectionStart != void 0) {
    elm.selectionStart = elm.value.length;
    elm.selectionEnd = elm.value.length;
  } else if(elm.createTextRange != void 0) {
    elm.focus();
    var range = elm.createTextRange();
    range.collapse(false);
    range.select();
  }
}

elm.chatbar.addEventListener("keydown", function(e) {
  var keyCode = e.keyCode;
  // scroll through chat history that the client sent
  if(keyCode == 38) { // up
    // history modified
    if(chatWriteHistoryIdx > -1 && elm.chatbar.value != chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1]) {
      chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1] = elm.chatbar.value;
    }
    if(chatWriteHistoryIdx == -1 && elm.chatbar.value) {
      chatWriteTmpBuffer = elm.chatbar.value;
    }
    chatWriteHistoryIdx++;
    if(chatWriteHistoryIdx >= chatWriteHistory.length) chatWriteHistoryIdx = chatWriteHistory.length - 1;
    var upVal = chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1];
    if(!upVal) return;
    elm.chatbar.value = upVal;
    // pressing up will move the cursor all the way to the left by default
    e.preventDefault();
    moveCaretEnd(elm.chatbar);
  } else if(keyCode == 40) { // down
    // history modified
    if(chatWriteHistoryIdx > -1 && elm.chatbar.value != chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1]) {
      chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1] = elm.chatbar.value;
    }
    chatWriteHistoryIdx--;
    if(chatWriteHistoryIdx < -1) {
      chatWriteHistoryIdx = -1;
      return;
    }
    var str = "";
    if(chatWriteHistoryIdx != -1) {
      str = chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1];
    } else {
      if(chatWriteTmpBuffer) {
        str = chatWriteTmpBuffer;
        e.preventDefault();
        moveCaretEnd(elm.chatbar);
      }
    }
    elm.chatbar.value = str;
    e.preventDefault();
    moveCaretEnd(elm.chatbar);
  }
});

elm.chat_close.addEventListener("click", function() {
  w.emit("chatClose");
  elm.chat_window.style.display = "none";
  elm.chat_open.style.display = "";
  chatOpen = false;
});

elm.chat_open.addEventListener("click", function() {
  w.emit("chatOpen");
  elm.chat_window.style.display = "";
  elm.chat_open.style.display = "none";
  chatOpen = true;
  if(selectedChatTab == 0) {
    chatPageUnread = 0;
    updateUnread();
    if(!initPageTabOpen) {
      initPageTabOpen = true;
      elm.page_chatfield.scrollTop = elm.page_chatfield.scrollHeight;
    }
  } else {
    chatGlobalUnread = 0;
    updateUnread();
    if(!initGlobalTabOpen) {
      initGlobalTabOpen = true;
      elm.global_chatfield.scrollTop = elm.global_chatfield.scrollHeight;
    }
  }
  var chatWidth = chat_window.offsetWidth - 2;
  var chatHeight = chat_window.offsetHeight - 2;
  var screenRatio = window.devicePixelRatio;
  if(!screenRatio) screenRatio = 1;
  var virtWidth = owotWidth / screenRatio;
  if(chatWidth > virtWidth) {
    resizeChat(virtWidth - 2, chatHeight);
  }
});

elm.chat_page_tab.addEventListener("click", function() {
  elm.chat_page_tab.classList.add("chat_tab_selected");
  elm.chat_global_tab.classList.remove("chat_tab_selected");

  elm.global_chatfield.style.display = "none";
  elm.page_chatfield.style.display = "";
  selectedChatTab = 0;
  chatPageUnread = 0;
  updateUnread();
  if(!initPageTabOpen) {
    initPageTabOpen = true;
    elm.page_chatfield.scrollTop = elm.page_chatfield.scrollHeight;
  }
});

elm.chat_global_tab.addEventListener("click", function() {
  elm.chat_global_tab.classList.add("chat_tab_selected");
  elm.chat_page_tab.classList.remove("chat_tab_selected");

  elm.global_chatfield.style.display = "";
  elm.page_chatfield.style.display = "none";
  selectedChatTab = 1;
  chatGlobalUnread = 0;
  updateUnread();
  if(!initGlobalTabOpen) {
    initGlobalTabOpen = true;
    elm.global_chatfield.scrollTop = elm.global_chatfield.scrollHeight;
  }
});

function resizable_chat() {
  var state = 0;
  var isDown = false;
  var downX = 0;
  var downY = 0;
  var elmX = 0;
  var elmY = 0;
  var chatWidth = 0;
  var chatHeight = 0;
  chat_window.addEventListener("mousemove", function(e) {
    if(isDown) return;
    var posX = e.pageX - chat_window.offsetLeft;
    var posY = e.pageY - chat_window.offsetTop;
    var top = (posY) <= 4;
    var left = (posX) <= 3;
    var right = (chat_window.offsetWidth - posX) <= 4;
    var bottom = (chat_window.offsetHeight - posY) <= 5;
    var cursor = "";
    if(left || right) cursor = "ew-resize";
    if(top || bottom) cursor = "ns-resize";
    if((top && left) || (right && bottom)) cursor = "nwse-resize";
    if((bottom && left) || (top && right)) cursor = "nesw-resize";
    chat_window.style.cursor = cursor;
    state = bottom << 3 | right << 2 | left << 1 | top;
  });
  chat_window.addEventListener("mousedown", function(e) {
    downX = e.pageX;
    downY = e.pageY;
    if(state) {
      // subtract 2 for the borders
      chatWidth = chat_window.offsetWidth - 2;
      chatHeight = chat_window.offsetHeight - 2;
      elmX = chat_window.offsetLeft;
      elmY = chat_window.offsetTop;
      isDown = true;
      chatResizing = true;
    }
  });
  document.addEventListener("mouseup", function() {
    isDown = false;
    chatResizing = false;
  });
  document.addEventListener("mousemove", function(e) {
    if(!isDown) return;
    var offX = e.pageX - downX;
    var offY = e.pageY - downY;
    var resize_bottom = state >> 3 & 1;
    var resize_right = state >> 2 & 1;
    var resize_left = state >> 1 & 1;
    var resize_top = state & 1;

    var width_delta = 0;
    var height_delta = 0;
    var abs_top = chat_window.offsetTop;
    var abs_left = chat_window.offsetLeft;
    var snap_bottom = chat_window.style.bottom == "0px";
    var snap_right = chat_window.style.right == "0px";

    if(resize_top) {
      height_delta = -offY;
    } else if(resize_bottom) {
      height_delta = offY;
    }
    if(resize_left) {
      width_delta = -offX;
    } else if(resize_right) {
      width_delta = offX;
    }
    var res = resizeChat(chatWidth + width_delta, chatHeight + height_delta);
    if(resize_top && !snap_bottom) {
      chat_window.style.top = (elmY + (chatHeight - res[1])) + "px";
    }
    if(resize_bottom && snap_bottom) {
      chat_window.style.bottom = "";
      chat_window.style.top = abs_top + "px";
    }
    if(resize_right && snap_right) {
      chat_window.style.right = "";
      chat_window.style.left = abs_left + "px";
    }
    if(resize_left && !snap_right) {
      chat_window.style.left = (elmX + (chatWidth - res[0])) + "px";
    }
  });
}

function evaluateChatfield(chatfield) {
  var field;
  if(chatfield == "page") {
    field = elm.page_chatfield;
  } else if(chatfield == "global") {
    field = elm.global_chatfield;
  } else {
    field = getChatfield();
  }
  return field;
}

// a lookup table between the emote name and its atlas location
var emoteList = {
    "403": [0, 19],
    "OHHELLNO": [19, 16],
    "aaaHD": [35, 16],
    "aha": [51, 16],
    "areyoukidding": [67, 16],
    "awesome": [83, 16],
    "awesome2": [99, 16],
    "bad": [115, 16],
    "beepboop": [131, 16],
    "bootiful": [147, 16],
    "bruh": [163, 16],
    "catthinkaaa": [179, 22],
    "chaos": [201, 16],
    "ded": [217, 16],
    "derp": [233, 16],
    "dislike": [249, 15],
    "durr": [264, 16],
    "erhb": [280, 16],
    "failwhale": [296, 35],
    "fpthinkaaa": [331, 16],
    "huh": [347, 16],
    "karp": [363, 17],
    "lenny": [380, 16],
    "like": [396, 15],
    "lol": [411, 16],
    "mad": [427, 16],
    "meh": [443, 16],
    "mmm": [459, 16],
    "neat": [475, 16],
    "no": [491, 16],
    "notcool": [507, 16],
    "oOoo": [523, 16],
    "ohno": [539, 16],
    "okthen": [555, 16],
    "omg": [571, 16],
    "ouch": [587, 16],
    "sad": [603, 16],
    "sadsmug": [619, 16],
    "scruffy": [635, 19],
    "smug": [654, 16],
    "stahp": [670, 16],
    "teef": [686, 16],
    "thinq": [702, 16],
    "thunk": [718, 16],
    "tri": [734, 17],
    "troll1": [751, 16],
    "void": [767, 16],
    "what": [783, 16],
    "yeesh": [799, 16],
    "zzz": [815, 16]
};

/*
  [type]:
  * "user"    :: registered non-renamed nick
  * "anon_nick" :: unregistered nick
  * "anon"    :: unregistered
  * "user_nick" :: registered renamed nick
*/
function addChat(chatfield, id, type, nickname, message, realUsername, op, admin, staff, color, date, dataObj) {
  if(!dataObj) dataObj = {};
  if(!message) message = "";
  if(!realUsername) realUsername = "";
  if(!nickname) nickname = realUsername;
  if(!color) color = assignColor(nickname);
  var dateStr = "";
  if(date) dateStr = convertToDate(date);
  var field = evaluateChatfield(chatfield);
  var pm = dataObj.privateMessage;
  var isGreen = false;

  if(chatGreentext && message[0] == ">" && !(":;_-".includes(message[1]))) { // exception to some emoticons
    message = message.substr(1);
    isGreen = true;
  }

  if(chatLimitCombChars) {
    message = filterChatMessage(message);
    nickname = filterChatMessage(nickname);
  }

  if(!op) {
    message = html_tag_esc(message);
    nickname = html_tag_esc(nickname);
  }

  // do not give the tag to [ Server ]
  var hasTagDom = (op || admin || staff || dataObj.rankName) && !(!id && op);

  var tagDom;
  var nickTitle = [];
  var usernameHasSpecialChars = false;

  for(var i = 0; i < realUsername.length; i++) {
    if(realUsername.charCodeAt(i) > 256) {
      usernameHasSpecialChars = true;
      break;
    }
  }

  if(type == "user" || type == "user_nick") {
    nickTitle.push("ID " + id);
  }

  if(hasTagDom) {
    tagDom = document.createElement("span");
    if(dataObj.rankName) {
      tagDom.innerHTML = "(" + dataObj.rankName + ")";
      tagDom.style.color = dataObj.rankColor;
      tagDom.style.fontWeight = "bold";
      nickTitle.push(dataObj.rankName);
    } else if(op) {
      tagDom.innerHTML = "(OP)";
      tagDom.style.color = "#0033cc";
      tagDom.style.fontWeight = "bold";
      nickTitle.push("Operator");
    } else if(admin) {
      tagDom.innerHTML = "(A)";
      tagDom.style.color = "#FF0000";
      tagDom.style.fontWeight = "bold";
      nickTitle.push("Administrator");
    } else if(staff) {
      tagDom.innerHTML = "(M)";
      tagDom.style.color = "#009933";
      tagDom.style.fontWeight = "bold";
      nickTitle.push("Staff");
    }
    tagDom.innerHTML += "&nbsp;";
  }

  var idTag = "";

  var nickDom = document.createElement("a");
  nickDom.style.textDecoration = "underline";

  if(type == "user") {
    nickDom.style.color = color;
    if(!usernameHasSpecialChars) {
      nickDom.style.fontWeight = "bold";
    }
    nickDom.style.pointerEvents = "default";
    if(state.userModel.is_operator) idTag = "[" + id + "]";
  }
  if(type == "anon_nick") {
    idTag = "[*" + id + "]"
  }
  if(type == "anon") {
    idTag = "[" + id + "]"
  }
  if(type == "user_nick") {
    nickDom.style.color = color;
    var impersonationWarning = "";
    if(usernameHasSpecialChars) {
      impersonationWarning = " (Special chars)";
    }
    nickTitle.push("Username \"" + realUsername + "\"" + impersonationWarning);
    if(state.userModel.is_operator) idTag = "[*" + id + "]";
  }

  if(state.userModel.is_operator) {
    idTag = "<span style=\"color: black; font-weight: normal;\">" + idTag + "</span>"
  }

  if(idTag && type != "anon") idTag += "&nbsp;"; // space between id and name

  if(id == 0) {
    idTag = "";
    nickname = "<span style=\"background-color: #e2e2e2;\">" + nickname + "</span>";
  }

  nickname = idTag + nickname;

  if(dateStr) nickTitle.push("(" + dateStr + ")");

  nickDom.innerHTML = nickname + (pm == "to_me" ? "" : ":");
  if(nickTitle.length) nickDom.title = nickTitle.join("; ");

  var pmDom = null;
  if(pm) {
    pmDom = document.createElement("div");
    pmDom.style.display = "inline";
    if(pm == "to_me") {
      pmDom.innerText = " -> Me:";
    } else if(pm == "from_me") {
      pmDom.innerText = "Me -> ";
    }
  }

  if(isGreen) {
    message = "<span style=\"color: #789922\">&gt;" + message + "</span>";
  }

  // parse emoticons
  if(chatEmotes) {
    var emoteMessage = "";
    var emoteBuffer = "";
    var emoteMode = false;
    var emoteCharset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    // emotes are case sensitive
    for(var i = 0; i < message.length; i++) {
      var chr = message[i];
      if(chr == ":") {
        if(emoteBuffer == ":" && emoteMode) { // special case: two consecutive colons
          emoteMessage += emoteBuffer;
          continue;
        }
        emoteBuffer += chr;
        if(emoteMode) {
          var emoteName = emoteBuffer.slice(1, -1);
          if(emoteList.hasOwnProperty(emoteName)) {
            var position = emoteList[emoteName];
            emoteMessage += "<div title=':" + emoteName
              + ":' class='chat_emote' style='background-position-x:-" + position[0]
              + "px;width:" + position[1] + "px'></div>";
          } else {
            emoteMessage += emoteBuffer;
          }
          emoteMode = false;
          emoteBuffer = "";
        } else {
          emoteMode = true;
        }
      } else if(emoteMode) {
        emoteBuffer += chr;
        if(!emoteCharset.includes(chr)) {
          emoteMode = false;
          emoteMessage += emoteBuffer;
          emoteBuffer = "";
          continue;
        }
      } else {
        emoteMessage += chr;
      }
    }
    if(emoteBuffer) { // leftovers
      emoteMessage += emoteBuffer;
    }
    message = emoteMessage;
  }

  var msgDom = document.createElement("span");
  msgDom.innerHTML = "&nbsp;" + message;

  var maxScroll = field.scrollHeight - field.clientHeight;
  var scroll = field.scrollTop;
  var doScrollBottom = false;
  if(maxScroll - scroll < 20) { // if scrolled at least 20 pixels above bottom
    doScrollBottom = true;
  }

  var chatGroup = document.createElement("div");
  if(!pm && hasTagDom) chatGroup.appendChild(tagDom);
  if(pmDom) {
    if(pm == "to_me") {
      if(hasTagDom) chatGroup.appendChild(tagDom);
      chatGroup.appendChild(nickDom);
      chatGroup.appendChild(pmDom);
    } else if(pm == "from_me") {
      chatGroup.appendChild(pmDom);
      if(hasTagDom) chatGroup.appendChild(tagDom);
      chatGroup.appendChild(nickDom);
    }
  } else {
    chatGroup.appendChild(nickDom);
  }
  chatGroup.appendChild(msgDom);

  field.appendChild(chatGroup);

  maxScroll = field.scrollHeight - field.clientHeight;
  if(doScrollBottom) {
    field.scrollTop = maxScroll;
  }

  var chatRec = {
    id: id, date: date,
    field: field,
    element: chatGroup
  };
  if(field == elm.page_chatfield) {
    chatRecordsPage.push(chatRec);
  } else if(field == elm.global_chatfield) {
    chatRecordsGlobal.push(chatRec);
  }
  if(chatRecordsPage.length > chatHistoryLimit) { // overflow on current page
    var rec = chatRecordsPage.shift();
    rec.element.remove();
  }
  if(chatRecordsGlobal.length > chatHistoryLimit) { // overflow on global
    var rec = chatRecordsGlobal.shift();
    rec.element.remove();
  }
}

function removeChatByIdAndDate(id, date) {
  if(!acceptChatDeletions) return;
  var records = [chatRecordsPage, chatRecordsGlobal];
  for(var r = 0; r < records.length; r++) {
    var recList = records[r];
    for(var i = 0; i < recList.length; i++) {
      var currentRec = recList[i];
      if(currentRec.id == id && currentRec.date == date) {
        var elm = currentRec.element;
        elm.remove();
      }
    }
  }
}

function addUnreadChatBar(chatfield, message, checkSituation) {
  var field = evaluateChatfield(chatfield);
  if(checkSituation) {
    var maxScroll = field.scrollHeight - field.clientHeight;
    var scroll = field.scrollTop;
    var remScroll = maxScroll - scroll;
    if(chatfield == "page") {
      if(chatPageUnreadBar || selectedChatTab == 0) return;
    }
    if(chatfield == "global") {
      if(chatGlobalUnreadBar || selectedChatTab == 1) return;
    }
  }
  var msg = "New messages";
  if(message) msg = message;
  var bar = document.createElement("div");
  var barText = document.createElement("span");
  bar.className = "unread_bar";
  barText.className = "unread_bar_msg";
  barText.innerText = msg;
  bar.appendChild(barText);
  field.appendChild(bar);
  return bar;
}

function isLongWidthChar(x) {
  switch(x) {
    case 0x0BF5: return true;
    case 0x2E3B: return true;
    case 0xA9C5: return true;
    case 0xFDFD: return true;
    case 0x12219: return true;
    case 0x1242B: return true;
  }
  return false;
}

function filterChatMessage(str) {
  if(typeof str != "string") return "";
  var res = "";
  var longWidthLimit = 1;
  var diacriticLength = 0;
  var longWidthCount = 0;
  str = [...str];
  for(var i = 0; i < str.length; i++) {
    var chr = str[i];
    var code = chr.codePointAt();
    var isLong = isLongWidthChar(code);
    if(isLong) {
      if(longWidthCount >= longWidthLimit) {
        res += ".";
      } else {
        res += chr;
        longWidthCount++;
      }
    } else {
      res += chr;
    }
    diacriticLength = 0;
  }
  return res;
}

function getChatfield() {
  if(selectedChatTab == 0) {
    return elm.page_chatfield;
  } else if(selectedChatTab == 1) {
    return elm.global_chatfield;
  }
}

function updateUserCount() {
  var count = w.userCount;
  if(count == void 0) {
    elm.usr_online.innerText = "";
    return;
  }
  var unit = "user";
  var units = "users";
  var current_unit;
  if(count == 1) {
    current_unit = unit;
  } else {
    current_unit = units;
  }
  elm.usr_online.innerText = count + " " + current_unit + " online";
}

function chatType(registered, nickname, realUsername) {
  var nickMatches = (nickname + "").toUpperCase() == (realUsername + "").toUpperCase();
  var hasSpecialChars = false;
  if(realUsername == "[ Server ]") return "user";
  if(nickname) {
    for(var i = 0; i < nickname.length; i++) {
      if(nickname.charCodeAt(i) > 256) {
        hasSpecialChars = true;
        break;
      }
    }
  }
  if(registered && (nickMatches || !nickname)) {
    if(hasSpecialChars) {
      return "user_nick";
    } else {
      return "user";
    }
  }
  if(registered && !nickMatches) return "user_nick";
  if(!registered && !nickname) return "anon";
  if(!registered && nickname) return "anon_nick";
  return type;
}

    </script>
    <script>
var tilePixelCache = {};
var tileCanvasPool = [];
var renderQueue = [];
var renderQueueMap = new Map();
var canBypassRenderDefer = true;
var renderSerial = 1;

function isTileQueued(x, y) {
  var pos = y + "," + x;
  return renderQueueMap.has(pos);
}
function queueTile(x, y, highPriority) {
  if(isTileQueued(x, y)) return;
  var pos = y + "," + x;
  renderQueueMap.set(pos, true);
  if(highPriority) {
    renderQueue.unshift([x, y]);
  } else {
    renderQueue.push([x, y]);
  }
}

function createTilePool() {
  var pCanv = document.createElement("canvas");
  var pDims = getPoolDimensions(tileWidth, tileHeight);
  var pWidth = pDims[0] * tileWidth;
  var pHeight = pDims[1] * tileHeight;
  pCanv.width = pWidth;
  pCanv.height = pHeight;
  var pCtx = pCanv.getContext("2d");
  var pMap = {};
  var pool = {
    canv: pCanv,
    ctx: pCtx,
    map: pMap,
    tileWidth: tileWidth,
    tileHeight: tileHeight,
    maxWidth: pDims[0],
    maxHeight: pDims[1],
    width: 1,
    height: 1,
    size: 0
  };
  tileCanvasPool.push(pool);
  return pool;
}

function expandPool(pool) {
  if(pool.width < pool.maxWidth) {
    pool.width *= 2;
    if(pool.width > pool.maxWidth) {
      pool.width = pool.maxWidth;
    }
  } else if(pool.height < pool.maxHeight) {
    pool.height *= 2;
    if(pool.height > pool.maxHeight) {
      pool.height = pool.maxHeight;
    }
  } else {
    return;
  }
  
  var pCanv = document.createElement("canvas");
  var pWidth = pool.width * tileWidth;
  var pHeight = pool.height * tileHeight;
  pCanv.width = pWidth;
  pCanv.height = pHeight;
  var pCtx = pCanv.getContext("2d");
  pCtx.drawImage(pool.canv, 0, 0);

  pool.canv.height = 0;
  pool.canv = pCanv;
  pool.ctx = pCtx;
}

function locateAvailablePool() {
  var pObj, pTilePos;
  var pLocated = false;
  for(var i = 0; i < tileCanvasPool.length; i++) {
    var pool = tileCanvasPool[i];
    if(pool.tileWidth != tileWidth || pool.tileHeight != tileHeight) continue;
    var maxArea = pool.maxWidth * pool.maxHeight;
    if(pool.size >= maxArea) continue;
    var currentArea = pool.width * pool.height;
    if(pool.size >= currentArea) {
      // expand canvas
      expandPool(pool);
      currentArea = pool.width * pool.height;
    }
    var map = pool.map;
    for(var t = 0; t < currentArea; t++) {
      if(map[t]) continue;
      pLocated = true;
      pObj = pool;
      pTilePos = t;
      break;
    }
    if(pLocated) break;
  }
  if(!pLocated) {
    return null;
  }
  return {
    pool: pObj,
    index: pTilePos
  }
}

function allocateTile() {
  var pool, index;
  var poolObj = locateAvailablePool();
  if(poolObj) {
    pool = poolObj.pool;
    index = poolObj.index;
  } else {
    pool = createTilePool();
    index = 0;
  }
  var pMap = pool.map;
  pool.size++;
  var mapX = index % pool.width;
  var mapY = Math.floor(index / pool.width);
  var tileObj = {
    pool: pool,
    x: mapX,
    y: mapY,
    idx: index,
    poolX: mapX * tileWidth,
    poolY: mapY * tileHeight,
    clampW: tileWidth,
    clampH: tileHeight
  };
  pMap[index] = tileObj;
  return tileObj;
}

function deallocateTile(obj) {
  var pool = obj.pool;
  var idx = obj.idx;
  if(pool.map[idx]) {
    delete pool.map[idx];
    pool.size--;
  }
}

function reallocateTile(obj) {
  var pX = obj.poolX;
  var pY = obj.poolY;
  var pool = obj.pool;
  deallocateTile(obj);
  var newObj = allocateTile();
  var newPool = newObj.pool;
  var newPX = newObj.poolX;
  var newPY = newObj.poolY;
  // transfer rendered text data if it has moved to a new spot
  if(pX != newPX || pY != newPY || pool != newPool) {
    newPool.ctx.clearRect(newPX, newPY, tileWidth, tileHeight);
    newPool.ctx.drawImage(pool.canv, pX, pY, tileWidth, tileHeight, newPX, newPY, tileWidth, tileHeight);
  }
  return newObj;
}

function deletePool(pool) {
  var canv = pool.canv;
  canv.height = 0;
  delete pool.canv;
  for(var t in pool.map) {
    delete pool.map[t];
  }
}

function deleteEmptyPools() {
  for(var i = 0; i < tileCanvasPool.length; i++) {
    var pool = tileCanvasPool[i];
    if(pool.size == 0) {
      deletePool(pool);
      tileCanvasPool.splice(i, 1);
      i--;
    }
  }
}

function deleteAllPools() {
  for(var i = 0; i < tileCanvasPool.length; i++) {
    var pool = tileCanvasPool[i];
    deletePool(pool);
    tileCanvasPool.splice(i, 1);
    i--;
  }
}

function countTotalPoolPixels() {
  var pixels = 0;
  for(var i = 0; i < tileCanvasPool.length; i++) {
    var pool = tileCanvasPool[i];
    pixels += pool.canv.width * pool.canv.height;
  }
  return pixels;
}

function cleanupDirtyTiles() {
  for(var t in tilePixelCache) {
    var pos = getPos(t);
    var tileX = pos[1];
    var tileY = pos[0];
    var tileImage = loadTileFromPool(tileX, tileY, true);
    if(!Tile.visible(tileX, tileY)) {
      if(tileImage && (tileImage.pool.tileWidth != tileWidth || tileImage.pool.tileHeight != tileHeight)) {
        removeTileFromPool(tileX, tileY);
      }
      if(tileImage === null) {
        delete tilePixelCache[t];
      }
    }
  }
}

function markTileFromPoolAsEmpty(tileX, tileY) {
  var pos = tileY + "," + tileX;
  var poolTile = tilePixelCache[pos];
  if(poolTile) {
    removeTileFromPool(tileX, tileY);
  }
  tilePixelCache[pos] = null;
}

function loadTileFromPool(tileX, tileY, doNotCreate) {
  var pos = tileY + "," + tileX;
  var poolTile = tilePixelCache[pos];
  if(doNotCreate) {
    return poolTile;
  }
  if(poolTile && poolTile.pool.tileWidth == tileWidth && poolTile.pool.tileHeight == tileHeight) {
    return poolTile;
  }
  if(poolTile) {
    deallocateTile(poolTile);
    w.periodDeletedTiles++; // important for forcing cleanup
  }
  var newTile = allocateTile();
  tilePixelCache[pos] = newTile;
  return newTile;
}

function shiftAllTilesInPools() {
  if(tileCanvasPool.length <= 1) return;
  for(var tile in tilePixelCache) {
    var tp = tilePixelCache[tile];
    if(tp == null) continue;
    if(tp.pool.tileWidth == tileWidth && tp.pool.tileHeight == tileHeight) {
      tilePixelCache[tile] = reallocateTile(tp);
    }
  }
  deleteEmptyPools();
}

function removeTileFromPool(tileX, tileY) {
  var pos = tileY + "," + tileX;
  var tileObj = tilePixelCache[pos];
  delete tilePixelCache[pos];
  if(!tileObj) return;
  deallocateTile(tileObj);
  w.periodDeletedTiles++;
}

function removeAllTilesFromPools() {
  for(var tile in tilePixelCache) {
    var tileObj = tilePixelCache[tile];
    delete tilePixelCache[tile];
    if(tileObj) {
      deallocateTile(tileObj);
    }
  }
}

function getPoolDimensions(tileWidth, tileHeight) {
  var sizeX = Math.floor(1024 / tileWidth);
  var sizeY = Math.floor(1024 / tileHeight);
  if(sizeX < 1) sizeX = 1;
  if(sizeY < 1) sizeY = 1;
  return [sizeX, sizeY];
}

function getTileCoordsFromMouseCoords(x, y) {
  var tileX = 0;
  var tileY = 0;
  var charX = 0;
  var charY = 0;
  var mpX = x - positionX - Math.trunc(owotWidth / 2);
  var mpY = y - positionY - Math.trunc(owotHeight / 2);
  // add global cell position
  charX = Math.floor(mpX / cellW);
  charY = Math.floor(mpY / cellH);
  // add tile position
  tileX = Math.floor(charX / tileC);
  tileY = Math.floor(charY / tileR);
  // add in-tile cell position
  charX = charX - (Math.floor(charX / tileC) * tileC);
  charY = charY - (Math.floor(charY / tileR) * tileR);
  return [tileX, tileY, charX, charY];
}

function getTileScreenPosition(tileX, tileY) {
  var offsetX = tileX * tileW + Math.trunc(owotWidth / 2) + Math.floor(positionX);
  var offsetY = tileY * tileH + Math.trunc(owotHeight / 2) + Math.floor(positionY);
  return [offsetX, offsetY];
}

function getVisibleTileRange(margin) {
  if(!margin) margin = 0;
  var A = getTileCoordsFromMouseCoords(0 - margin, 0 - margin);
  var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, owotHeight - 1 + margin);
  var startX = clipIntMax(A[0]);
  var startY = clipIntMax(A[1]);
  var endX = clipIntMax(B[0]);
  var endY = clipIntMax(B[1]);
  if(startX > endX || startY > endY || (B[0] - A[0] + 1) > 100000 || (B[1] - A[1] + 1) > 100000) {
    throw "Invalid ranges";
  }
  return [[startX, startY], [endX, endY]];
}

function getVisibleTiles(margin) {
  if(!margin) margin = 0;
  var A = getTileCoordsFromMouseCoords(0 - margin, 0 - margin);
  var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, owotHeight - 1 + margin);
  return getRange(A[0], A[1], B[0], B[1]);
}

function getWidth(margin) {
  if(!margin) margin = 0;
  var A = getTileCoordsFromMouseCoords(0 - margin, 0);
  var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, 0);
  return B[0] - A[0] + 1;
}

function getHeight(margin) {
  if(!margin) margin = 0;
  var A = getTileCoordsFromMouseCoords(0, 0 - margin);
  var B = getTileCoordsFromMouseCoords(0, owotHeight - 1 + margin);
  return B[1] - A[1] + 1;
}

function getArea(margin) {
  if(!margin) margin = 0;
  var A = getTileCoordsFromMouseCoords(0 - margin, 0 - margin);
  var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, owotHeight - 1 + margin);
  return (B[0] - A[0] + 1) * (B[1] - A[1] + 1);
}

function tileAndCharsToWindowCoords(tileX, tileY, charX, charY) {
  var x = tileX * tileW;
  var y = tileY * tileH;
  x += charX * cellW;
  y += charY * cellH;
  x += positionX;
  y += positionY;
  x += Math.trunc(owotWidth / 2);
  y += Math.trunc(owotHeight / 2);
  return [Math.trunc(x / zoomRatio), Math.trunc(y / zoomRatio)];
}

function testCanvasForCrossOriginError() {
  if(!textRenderCtx) return;
  try {
    textRenderCtx.getImageData(0, 0, 1, 1);
    canBypassRenderDefer = true;
  } catch(e) {
    canBypassRenderDefer = false;
  }
}

var lcsShardCharVectors = [
  [[0,3],[1,4],[0,4],[0,3]],
  [[0,3],[2,4],[0,4],[0,3]],
  [[0,1],[1,4],[0,4],[0,1]],
  [[0,1],[2,4],[0,4],[0,1]],
  [[0,0],[1,4],[0,4],[0,0]],
  [[1,0],[2,0],[2,4],[0,4],[0,1],[1,0]],
  [[2,0],[2,4],[0,4],[0,1],[2,0]],
  [[1,0],[2,0],[2,4],[0,4],[0,3],[1,0]],
  [[2,0],[2,4],[0,4],[0,3],[2,0]],
  [[1,0],[2,0],[2,4],[0,4],[1,0]],
  [[2,1],[2,4],[0,4],[0,3],[2,1]],
  [[2,3],[2,4],[1,4],[2,3]],
  [[2,3],[2,4],[0,4],[2,3]],
  [[2,1],[2,4],[1,4],[2,1]],
  [[2,1],[2,4],[0,4],[2,1]],
  [[2,0],[2,4],[1,4],[2,0]],
  [[0,0],[1,0],[2,1],[2,4],[0,4],[0,0]],
  [[0,0],[2,1],[2,4],[0,4],[0,0]],
  [[0,0],[1,0],[2,3],[2,4],[0,4],[0,0]],
  [[0,0],[2,3],[2,4],[0,4],[0,0]],
  [[0,0],[1,0],[2,4],[0,4],[0,0]],
  [[0,1],[2,3],[2,4],[0,4],[0,1]],
  [[0,0],[2,0],[2,4],[1,4],[0,3],[0,0]],
  [[0,0],[2,0],[2,4],[0,3],[0,0]],
  [[0,0],[2,0],[2,4],[1,4],[0,1],[0,0]],
  [[0,0],[2,0],[2,4],[0,1],[0,0]],
  [[0,0],[2,0],[2,4],[1,4],[0,0]],
  [[0,0],[1,0],[0,1],[0,0]],
  [[0,0],[2,0],[0,1],[0,0]],
  [[0,0],[1,0],[0,3],[0,0]],
  [[0,0],[2,0],[0,3],[0,0]],
  [[0,0],[1,0],[0,4],[0,0]],
  [[0,0],[2,0],[2,1],[0,3],[0,0]],
  [[0,0],[2,0],[2,3],[1,4],[0,4],[0,0]],
  [[0,0],[2,0],[2,3],[0,4],[0,0]],
  [[0,0],[2,0],[2,1],[1,4],[0,4],[0,0]],
  [[0,0],[2,0],[2,1],[0,4],[0,0]],
  [[0,0],[2,0],[1,4],[0,4],[0,0]],
  [[1,0],[2,0],[2,1],[1,0]],
  [[0,0],[2,0],[2,1],[0,0]],
  [[1,0],[2,0],[2,3],[1,0]],
  [[0,0],[2,0],[2,3],[0,0]],
  [[1,0],[2,0],[2,4],[1,0]],
  [[0,0],[2,0],[2,3],[0,1],[0,0]],
  [[0,0],[2,0],[2,4],[0,4],[1,2],[0,0]],
  [[0,0],[1,2],[2,0],[2,4],[0,4],[0,0]],
  [[0,0],[2,0],[1,2],[2,4],[0,4],[0,0]],
  [[0,0],[2,0],[2,4],[1,2],[0,4],[0,0]],
  [[0,0],[1,2],[0,4],[0,0]],
  [[0,0],[2,0],[1,2],[0,0]],
  [[2,0],[2,4],[1,2],[2,0]],
  [[1,2],[2,4],[0,4],[1,2]],
  // skip (lcs)
  [[0,0],[2,4],[0,4],[2,0],[0,0]],
  [[2,0],[2,4],[0,0],[0,4],[2,0]],
  // box-drawing bold mode; four 90-deg, four iso
  [[2,0],[2,4],[0,4],[2,0]], // 54
  [[0,0],[2,4],[0,4],[0,0]],
  [[0,0],[2,0],[0,4],[0,0]],
  [[0,0],[2,0],[2,4],[0,0]],
  [[1,0],[2,4],[0,4],[1,0]], // 58
  [[0,0],[2,2],[0,4],[0,0]],
  [[0,0],[2,0],[1,4],[0,0]],
  [[2,0],[2,4],[0,2],[2,0]] 
];

// 2x4 octant character lookup (relative char code -> bit pattern)
// range: 0x1CD00 - 0x1CDE5
var lcsOctantCharPoints = [
  4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
  55, 56, 57, 58, 59, 60, 61, 62, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
  79, 81, 82, 83, 84, 86, 87, 88, 89, 91, 92, 93, 94, 96, 97, 98, 99, 100, 101, 102, 103,
  104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
  122, 123, 124, 125, 126, 127, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140,
  141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
  159, 161, 162, 163, 164, 166, 167, 168, 169, 171, 172, 173, 174, 176, 177, 178, 179, 180,
  181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 193, 194, 195, 196, 197, 198, 199,
  200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,
  218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235,
  236, 237, 238, 239, 241, 242, 243, 244, 246, 247, 248, 249, 251, 253, 254
];

var fracBlockTransforms = [
  // relative offset: 0x2580 (until 0x2590)
  [[2, 4/8],
  [3, 1/8],
  [3, 2/8],
  [3, 3/8],
  [3, 4/8],
  [3, 5/8],
  [3, 6/8],
  [3, 7/8],
  [0, 8/8],
  [0, 7/8],
  [0, 6/8],
  [0, 5/8],
  [0, 4/8],
  [0, 3/8],
  [0, 2/8],
  [0, 1/8],
  [1, 4/8]],

  // relative offset: 0x2594 (until 0x2595)
  [[2, 1/8],
  [1, 1/8]],
  
  // relative offset: 0x1FB82 (until 0x1FB8B)
  [[2, 2/8],
  [2, 3/8],
  [2, 5/8],
  [2, 6/8],
  [2, 7/8],
  [1, 2/8],
  [1, 3/8],
  [1, 5/8],
  [1, 6/8],
  [1, 7/8]]
];

function isValidSpecialSymbol(charCode) {
  if(charCode >= 0x2580 && charCode <= 0x2590) return true;
  if(charCode >= 0x2594 && charCode <= 0x259F) return true;
  if(charCode >= 0x25E2 && charCode <= 0x25E5) return true;
  if(charCode >= 0x1CD00 && charCode <= 0x1CDE5) return true;
  if(charCode >= 0x1FB00 && charCode <= 0x1FB3B) return true;
  if(charCode >= 0x1FB3C && charCode <= 0x1FB6F) return true;
  if(charCode >= 0x1FB82 && charCode <= 0x1FB8B) return true;

  switch(charCode) {
    case 0x25B2: return true;
    case 0x25BA: return true;
    case 0x25BC: return true;
    case 0x25C4: return true;
    case 0x1CEA0: return true;
    case 0x1CEA3: return true;
    case 0x1CEA8: return true;
    case 0x1CEAB: return true;
    case 0x1FB9A: return true;
    case 0x1FB9B: return true;
    case 0x1FBE6: return true;
    case 0x1FBE7: return true;
  }

  return false;
}

function draw2by2Char(charCode, textRender, x, y, width, height) {
  // relative offset: 0x2596 - 0x259F
  var pattern = [2, 1, 8, 11, 9, 14, 13, 4, 6, 7][charCode - 0x2596];
  textRender.beginPath();
  if(pattern & 8) textRender.rect(x, y, width / 2, height / 2);
  if(pattern & 4) textRender.rect(x + width / 2, y, width / 2, height / 2);
  if(pattern & 2) textRender.rect(x, y + height / 2, width / 2, height / 2);
  if(pattern & 1) textRender.rect(x + width / 2, y + height / 2, width / 2, height / 2);
  textRender.fill();
}

function draw2by3Char(charCode, textRender, x, y, width, height) {
  var code = 0;
  if(charCode >= 0x1FB00 && charCode <= 0x1FB13) code = charCode - 0x1FB00 + 1;
  if(charCode >= 0x1FB14 && charCode <= 0x1FB27) code = charCode - 0x1FB00 + 2;
  if(charCode >= 0x1FB28 && charCode <= 0x1FB3B) code = charCode - 0x1FB00 + 3;
  textRender.beginPath();
  for(var i = 0; i < 6; i++) {
    if(!(code >> i & 1)) continue;
    textRender.rect(x + (width / 2) * (i & 1), y + (height / 3) * (i >> 1), width / 2, height / 3);
  }
  textRender.fill();
}

function drawTriangleShardChar(charCode, textRender, x, y, width, height) {
  var is90degTri = charCode >= 0x25E2 && charCode <= 0x25E5;
  var isIsoTri = charCode == 0x25B2 || charCode == 0x25BA || charCode == 0x25BC || charCode == 0x25C4;

  var vecIndex = charCode - 0x1FB3C;
  if(charCode >= 0x1FB9A && charCode <= 0x1FB9B) {
    vecIndex -= 42;
  } else if(is90degTri) {
    vecIndex = (charCode - 0x25E2) + 54;
  } else if(isIsoTri) {
    switch(charCode) {
      case 0x25B2: vecIndex = 58; break;
      case 0x25BA: vecIndex = 59; break;
      case 0x25BC: vecIndex = 60; break;
      case 0x25C4: vecIndex = 61; break;
    }
  }
  var vecs = lcsShardCharVectors[vecIndex];
  var gpX = [0, width / 2, width];
  var gpY = [0, height / 3, height / 2, (height / 3) * 2, height];
  textRender.beginPath();
  for(var i = 0; i < vecs.length; i++) {
    var vec = vecs[i];
    var gx = gpX[vec[0]];
    var gy = gpY[vec[1]];
    if(i == 0) {
      textRender.moveTo(x + gx, y + gy);
    } else {
      textRender.lineTo(x + gx, y + gy);
    }
  }
  textRender.closePath();
  textRender.fill();
}

function draw2by4Char(charCode, textRender, x, y, width, height) {
  var code = 0;
  if(charCode >= 0x1CD00 && charCode <= 0x1CDE5) {
    code = lcsOctantCharPoints[charCode - 0x1CD00];
  } else {
    switch(charCode) {
      case 0x1CEA8: code = 1; break;
      case 0x1CEAB: code = 2; break;
      case 0x1CEA3: code = 64; break;
      case 0x1CEA0: code = 128; break;
      case 0x1FBE6: code = 20; break;
      case 0x1FBE7: code = 40; break;
    }
  }
  if(!code) return false;
  textRender.beginPath();
  for(var py = 0; py < 4; py++) {
    for(var px = 0; px < 2; px++) {
      var idx = py * 2 + px;
      if(code >> idx & 1) {
        textRender.rect(x + px * (width / 2), y + py * (height / 4), width / 2, height / 4);
      }
    }
  }
  textRender.fill();
}

function drawFractionalBlockChar(charCode, textRender, x, y, width, height) {
  var transform = null;
  // basic fractional blocks
  if(charCode >= 0x2580 && charCode <= 0x2590) {
    transform = fracBlockTransforms[0][charCode - 0x2580];
  } else if(charCode >= 0x2594 && charCode <= 0x2595) {
    transform = fracBlockTransforms[1][charCode - 0x2594];
  } else if(charCode >= 0x1FB82 && charCode <= 0x1FB8B) {
    transform = fracBlockTransforms[2][charCode - 0x1FB82];
  }
  if(!transform) return;

  var dir = transform[0];
  var frac = transform[1];
  var x2 = x + width - 1;
  var y2 = y + height - 1;

  switch(dir) {
    case 0: x2 -= width - (width * frac); break;
    case 1: x += width - (width * frac); break;
    case 2: y2 -= height - (height * frac); break;
    case 3: y += height - (height * frac); break;
  }

  textRender.fillRect(x, y, x2 - x + 1, y2 - y + 1);
}

function drawBlockChar(charCode, textRender, x, y, clampW, clampH) {
  // since the char grid varies on other zoom levels, we must account for it to avoid line artifacts
  var tmpCellW = clampW / tileC;
  var tmpCellH = clampH / tileR;
  var sx = Math.floor(x * tmpCellW);
  var sy = Math.floor(y * tmpCellH);
  var ex = Math.floor((x + 1) * tmpCellW);
  var ey = Math.floor((y + 1) * tmpCellH);
  tmpCellW = ex - sx;
  tmpCellH = ey - sy;

  var isFractionalBlock = (charCode >= 0x2580 && charCode <= 0x2590) ||
              (charCode >= 0x2594 && charCode <= 0x2595) ||
              (charCode >= 0x1FB82 && charCode <= 0x1FB8B);
  var is2by2 = charCode >= 0x2596 && charCode <= 0x259F;
  var is2by3 = charCode >= 0x1FB00 && charCode <= 0x1FB3B;
  var is2by4 = (charCode >= 0x1CD00 && charCode <= 0x1CDE5) ||
          charCode == 0x1CEA8 || charCode == 0x1CEAB || charCode == 0x1CEA3 || 
          charCode == 0x1CEA0 || charCode == 0x1FBE6 || charCode == 0x1FBE7;
  var is90degTri = charCode >= 0x25E2 && charCode <= 0x25E5;
  var isIsoTri = charCode == 0x25B2 || charCode == 0x25BA || charCode == 0x25BC || charCode == 0x25C4;
  var isTriangleShard = (charCode >= 0x1FB3C && charCode <= 0x1FB6F) ||
              (charCode >= 0x1FB9A && charCode <= 0x1FB9B) ||
              (is90degTri || isIsoTri);

  if(isFractionalBlock) { // basic fractional blocks (full, half, n/8)
    drawFractionalBlockChar(charCode, textRender, sx, sy, tmpCellW, tmpCellH);
  } else if(is2by2) { // 2x2 blocks
    draw2by2Char(charCode, textRender, sx, sy, tmpCellW, tmpCellH);
  } else if(is2by3) { // 2x3 blocks
    draw2by3Char(charCode, textRender, sx, sy, tmpCellW, tmpCellH);
  } else if(isTriangleShard) { // LCS shard characters
    drawTriangleShardChar(charCode, textRender, sx, sy, tmpCellW, tmpCellH);
  } else if(is2by4) { // 2x4 LCS octant characters
    draw2by4Char(charCode, textRender, sx, sy, tmpCellW, tmpCellH);
  }
}

function dispatchCharClientHook(cCode, textRender, str, x, y, clampW, clampH) {
  var funcs = specialClientHooks.renderchar;
  if(!funcs.length) return false;
  for(var i = 0; i < funcs.length; i++) {
    var func = funcs[i];
    var tilePos = getPos(str);
    // duplicate from drawBlockChar - needs refactoring
    var tmpCellW = clampW / tileC;
    var tmpCellH = clampH / tileR;
    var sx = Math.floor(x * tmpCellW);
    var sy = Math.floor(y * tmpCellH);
    var ex = Math.floor((x + 1) * tmpCellW);
    var ey = Math.floor((y + 1) * tmpCellH);
    tmpCellW = ex - sx;
    tmpCellH = ey - sy;
    var status = func(cCode, textRender, tilePos[1], tilePos[0], x, y, sx, sy, tmpCellW, tmpCellH);
    if(status) {
      return true;
    }
  }
  return false;
}

function renderChar(textRender, x, y, clampW, clampH, str, tile, writability, props, offsetX, offsetY, charOverflowMode) {
  var content = tile.content;
  var colors = tile.properties.color;
  var hasDrawn = false;

  // adjust baseline
  var textYOffset = cellH - (5 * zoom);

  var fontX = x * cellW + offsetX;
  var fontY = y * cellH + offsetY;

  var char = content[y * tileC + x] || " ";

  var deco = null;
  if(textDecorationsEnabled) {
    deco = getCharTextDecorations(char);
  }
  char = clearCharTextDecorations(char);
  char = resolveCharEmojiCombinations(char);

  var cCode = char.codePointAt(0);
  if(charOverflowMode) {
    if(cCode < 1024 && !deco) return;
    if(cCode == 0xFDFD) return;
    if(cCode >= 0x12427 && cCode <= 0x1242B) return;
  }

  // fill background if defined
  if(coloredChars[str] && coloredChars[str][y] && coloredChars[str][y][x]) {
    var color = coloredChars[str][y][x];
    if(Array.isArray(color)) {
      color = color[color.length - 1];
    }
    color = colorClasses[color];
    textRender.fillStyle = color;
    textRender.fillRect(fontX, fontY, cellW, cellH);
    hasDrawn = true;
  }

  var color = colors ? colors[y * tileC + x] : 0;
  // initialize link color to default text color in case there's no link to color
  var linkColor = styles.text;
  if(textColorOverride) {
    if(writability == 0 && textColorOverride & 4) linkColor = styles.public_text;
    if(writability == 1 && textColorOverride & 2) linkColor = styles.member_text;
    if(writability == 2 && textColorOverride & 1) linkColor = styles.owner_text;
  }

  var isLink = false;

  // check if this char is a link
  if(linksRendered && props[y] && props[y][x]) {
    var link = props[y][x].link;
    if(link) {
      isLink = true;
      if(link.type == "url") {
        linkColor = defaultURLLinkColor;
      } else if(link.type == "coord") {
        linkColor = defaultCoordLinkColor;
      }
    }
  }

  // if text has no color, use default text color. otherwise, colorize it
  if(color == 0 || !colorsEnabled || (isLink && !colorizeLinks)) {
    textRender.fillStyle = linkColor;
  } else {
    textRender.fillStyle = `rgb(${color >> 16 & 255},${color >> 8 & 255},${color & 255})`;
  }

  // x padding of text if the char width is > 10
  var XPadding = cellWidthPad * zoom;

  // underline link
  if(isLink) {
    textRender.fillRect(fontX, fontY + textYOffset + zoom, cellW, zoom);
    hasDrawn = true;
  }

  if(deco) {
    if(deco.under) {
      textRender.fillRect(fontX, fontY + textYOffset + zoom, cellW, zoom);
      hasDrawn = true;
    }
    if(deco.strike) {
      textRender.fillRect(fontX, fontY + Math.floor((16 * zoom) / 2), cellW, zoom);
      hasDrawn = true;
    }
  }

  if(((specialClientHookMap >> 0) & 1) && !charOverflowMode) {
    var status = dispatchCharClientHook(cCode, textRender, str, x, y, clampW, clampH);
    if(status) {
      return true;
    }
  }

  // don't render whitespaces
  if(char == "\u0020" || char == "\u00A0") return hasDrawn;

  if(!surrogateCharsEnabled || !combiningCharsEnabled) {
    char = w.split(char, !surrogateCharsEnabled, !combiningCharsEnabled);
    if(char.length) {
      char = char[0];
    } else {
      char = "?";
    }
  }

  var isBold = deco && deco.bold;
  var isItalic = deco && deco.italic;
  var isHalfShard = ((cCode >= 0x25E2 && cCode <= 0x25E5) ||
            cCode == 0x25B2 || cCode == 0x25C4 || cCode == 0x25BA || cCode == 0x25BC);
  var checkIdx = 1;
  if(char.codePointAt(0) > 65535) checkIdx = 2;
  var isSpecial = char.codePointAt(checkIdx) != void 0;
  isSpecial = isSpecial || (cCode >= 0x2500 && cCode <= 0x257F);

  if(ansiBlockFill && isValidSpecialSymbol(cCode) && !(isHalfShard && !isBold)) {
    if(!charOverflowMode) {
      drawBlockChar(cCode, textRender, x, y, clampW, clampH);
      hasDrawn = true;
    }
  } else { // character rendering
    var tempFont = null;
    var prevFont = null;
    if(isSpecial || deco) {
      prevFont = textRender.font;
      tempFont = textRender.font;
      if(isSpecial) tempFont = specialCharFont;
      if(isBold) tempFont = "bold " + tempFont;
      if(isItalic) tempFont = "italic " + tempFont;
      textRender.font = tempFont;
    }
    textRender.fillText(char, Math.round(fontX + XPadding), Math.round(fontY + textYOffset));
    hasDrawn = true;
    if(prevFont) {
      textRender.font = prevFont;
    }
  }
  return hasDrawn;
}

function drawGrid(renderCtx, gridColor, offsetX, offsetY, tileX, tileY) {
  if(subgridEnabled && zoom >= 0.3) {
    var b = 0xB9;
    if(zoom < 0.5) {
      b += (0xFF - b) * (0.5 - zoom) * 2;
    }
    b = Math.floor(b);
    renderCtx.strokeStyle = "rgb(" + b + ", " + b + ", " + b + ")";
    var dashSize = 1;
    renderCtx.setLineDash([dashSize]);
    renderCtx.lineWidth = dashSize;
    for(var x = 1; x < tileC; x++) {
      for(var y = 1; y < tileR; y++) {
        renderCtx.beginPath();
        renderCtx.moveTo(0, Math.floor(y * cellH) + 0.5);
        renderCtx.lineTo(tileW, Math.floor(y * cellH) + 0.5);
        renderCtx.stroke();
      }
      renderCtx.beginPath();
      renderCtx.moveTo(Math.floor(x * cellW) + 0.5, 0);
      renderCtx.lineTo(Math.floor(x * cellW) + 0.5, tileH);
      renderCtx.stroke();
    }
  }
  renderCtx.fillStyle = gridColor;
  renderCtx.fillRect(Math.floor(offsetX), Math.floor(offsetY), tileWidth, 1);
  renderCtx.fillRect(Math.floor(offsetX), Math.floor(offsetY), 1, tileHeight);
}

function drawObstructedCursor(renderCtx, content, curX, curY, offsetX, offsetY) {
  var idx = curY * tileC + curX;
  // if the char is a full block, force the cursor over it.
  if(content) {
    if(content[idx] == "\u2588") {
      renderCtx.fillStyle = styles.cursor;
      renderCtx.fillRect(offsetX + curX * cellW, offsetY + curY * cellH, cellW, cellH);
    }
  }
}

function getTileBackgroundColor(tile) {
  var writability = tile.properties.writability;
  if(writability == null) writability = state.worldModel.writability;
  
  if(tile.backgroundColor) {
    return tile.backgroundColor;
  }
  if(writability == 0) return styles.public;
  if(writability == 1) return styles.member;
  if(writability == 2) return styles.owner;
}

function renderTileBackground(renderCtx, offsetX, offsetY, tile, tileX, tileY, cursorVisibility) {
  var hasDrawn = false;
  renderCtx.fillStyle = getTileBackgroundColor(tile);

  var clamp, clampW, clampH;
  if(transparentBackground) {
    clamp = getTileScreenPosition(tileX + 1, tileY + 1);
    clampW = Math.floor(clamp[0]) - offsetX;
    clampH = Math.floor(clamp[1]) - offsetY;
  } else {
    // in opaque mode, the offsets are always (0, 0) within the text-render tile
    // in transparent mode, backgrounds are placed directly on the main canvas
    clampW = tileWidth;
    clampH = tileHeight;
  }

  // fill tile background color
  // in this case, we don't mark 'hasDrawn' as true since the bg drawing can be outsourced to a different component
  renderCtx.fillRect(offsetX, offsetY, clampW, clampH);

  // render char protections
  if(tile.properties.char && !tile.backgroundColor) {
    for(var p = 0; p < tileArea; p++) {
      var code = tile.properties.char[p]; // writability
      var cX = p % tileC;
      var cY = Math.floor(p / tileC);
      if(code != null) {
        if(code == 0) renderCtx.fillStyle = styles.public;
        if(code == 1) renderCtx.fillStyle = styles.member;
        if(code == 2) renderCtx.fillStyle = styles.owner;
        if(cellW >= 1 && cellH >= 1) {
          // clamp to next position in axis
          var tmpCellW = clampW / tileC;
          var tmpCellH = clampH / tileR;
          var sx = Math.floor(cX * tmpCellW);
          var sy = Math.floor(cY * tmpCellH);
          var x2 = Math.floor((cX + 1) * tmpCellW);
          var y2 = Math.floor((cY + 1) * tmpCellH);
          renderCtx.fillRect(offsetX + sx, offsetY + sy, x2 - sx, y2 - sy);
          hasDrawn = true;
        } else {
          renderCtx.fillRect(offsetX + cX * cellW, offsetY + cY * cellH, cellW, cellH);
          hasDrawn = true;
        }
      }
    }
  }

  if(guestCursorsEnabled) {
    var dCursor = renderGuestCursors(renderCtx, offsetX, offsetY, tile, tileX, tileY);
    if(dCursor) {
      hasDrawn = true;
    }
  }

  // render cursor
  if(cursorVisibility) {
    var charX = cursorCoords[2];
    var charY = cursorCoords[3];
    renderCtx.fillStyle = styles.cursor;
    renderCtx.fillRect(offsetX + charX * cellW, offsetY + charY * cellH, cellW, cellH);
    hasDrawn = true;
  }

  var highlight = highlightFlash[tileY + "," + tileX];
  if(highlight) { // highlighted edits
    for(var y = 0; y < tileR; y++) {
      for(var x = 0; x < tileC; x++) {
        if(highlight[y]) {
          if(highlight[y][x] !== void 0) {
            var flashRGB = highlight[y][x][1];
            renderCtx.fillStyle = "rgb(" + flashRGB[0] + "," + flashRGB[1] + "," + flashRGB[2] + ")";
            renderCtx.fillRect(offsetX + x * cellW, offsetY + y * cellH, cellW, cellH);
            hasDrawn = true;
          }
        }
      }
    }
  }
  return hasDrawn;
}

function renderTileBackgroundImage(renderCtx, tileX, tileY, ctxOffX, ctxOffY) {
  var startX = tileX * tileWidth;
  var startY = tileY * tileHeight;
  
  var backRatioW = tileWidth / dTileW;
  var backRatioH = tileHeight / dTileH;

  var imgWidth = backgroundPatternSize[0];
  var imgHeight = backgroundPatternSize[1];

  var repeat = w.backgroundInfo.rmod;
  var offX = w.backgroundInfo.x;
  var offY = w.backgroundInfo.y;
  var patWidth = w.backgroundInfo.w;
  var patHeight = w.backgroundInfo.h;
  var alpha = w.backgroundInfo.alpha;

  if(!patWidth) patWidth = imgWidth;
  if(!patHeight) patHeight = imgHeight;

  startX += offX * backRatioW;
  startY += offY * backRatioH;

  backRatioW *= patWidth / imgWidth;
  backRatioH *= patHeight / imgHeight;

  /*
    0: repeat
    1: center
    2: singular
  */
  if(repeat == 0) {
    if(!window.DOMMatrix || !backgroundPattern) return false;
    backgroundPattern.setTransform(new DOMMatrix([backRatioW, 0, 0, backRatioH, -startX, -startY]));
    renderCtx.fillStyle = backgroundPattern;
    renderCtx.globalAlpha = alpha;
    renderCtx.fillRect(ctxOffX, ctxOffY, tileWidth, tileHeight);
    renderCtx.globalAlpha = 1;
    return true;
  } else if(repeat == 1 || repeat == 2) {
    if(!backgroundImage) return false;
    if(repeat == 1) {
      startX += Math.floor(imgWidth / 2) * backRatioW;
      startY += Math.floor(imgHeight / 2) * backRatioH;
    }
    renderCtx.globalAlpha = alpha;
    renderCtx.drawImage(backgroundImage, -startX + ctxOffX, -startY + ctxOffY, imgWidth * backRatioW, imgHeight * backRatioH);
    renderCtx.globalAlpha = 1;
    return true;
  }
  return false;
}

function clearTile(tileX, tileY) {
  if(!Tile.visible(tileX, tileY)) return;
  var tileScreenPos = getTileScreenPosition(tileX, tileY);
  var offsetX = Math.floor(tileScreenPos[0]);
  var offsetY = Math.floor(tileScreenPos[1]);

  var clamp = getTileScreenPosition(tileX + 1, tileY + 1);
  var clampW = Math.floor(clamp[0]) - offsetX;
  var clampH = Math.floor(clamp[1]) - offsetY;

  owotCtx.clearRect(offsetX, offsetY, clampW, clampH);
}

function renderContent(textRenderCtx, tileX, tileY, clampW, clampH, offsetX, offsetY, bounds, charOverflowMode) {
  var str = tileY + "," + tileX;
  var tile = Tile.get(tileX, tileY);
  if(!tile) return;
  var props = tile.properties.cell_props || {};
  var writability = tile.writability;
  var x1 = 0;
  var y1 = 0;
  var x2 = tileC - 1;
  var y2 = tileR - 1;
  if(bounds) {
    x1 = bounds[0];
    y1 = bounds[1];
    x2 = bounds[2];
    y2 = bounds[3];
  }
  var hasDrawn = false;
  for(var y = y1; y <= y2; y++) {
    for(var x = x1; x <= x2; x++) {
      var protValue = writability;
      if(tile.properties.char) {
        protValue = tile.properties.char[y * tileC + x];
      }
      if(protValue == null) protValue = tile.properties.writability;
      if(protValue == null) protValue = state.worldModel.writability;
      var dChar = renderChar(textRenderCtx, x, y, clampW, clampH, str, tile, protValue, props, offsetX, offsetY, charOverflowMode);
      if(dChar) {
        hasDrawn = true;
      }
    }
  }
  return hasDrawn;
}

function renderCellBgColors(textRenderCtx, tileX, tileY, clampW, clampH) {
  var tile = Tile.get(tileX, tileY);
  if(!tile) return;
  var containsCursor = cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY;
  var bgcolors = tile.properties.bgcolor;
  var hasDrawn = false;
  if(!bgcolors) return;
  for(var y = 0; y < tileR; y++) {
    for(var x = 0; x < tileC; x++) {
      var bgColor = bgcolors[y * tileC + x];
      if(bgColor == -1) continue;
      if(containsCursor && cursorCoords && cursorCoords[2] == x && cursorCoords[3] == y) continue;
      var tmpCellW = clampW / tileC;
      var tmpCellH = clampH / tileR;
      var sx = Math.floor(x * tmpCellW);
      var sy = Math.floor(y * tmpCellH);
      var ex = Math.floor((x + 1) * tmpCellW);
      var ey = Math.floor((y + 1) * tmpCellH);
      textRenderCtx.fillStyle = `rgb(${bgColor >> 16 & 255},${bgColor >> 8 & 255},${bgColor & 255})`;
      textRenderCtx.fillRect(sx, sy, ex - sx, ey - sy);
      hasDrawn = true;
    }
  }
  return hasDrawn;
}

function drawTile(tileX, tileY) {
  var tile = Tile.get(tileX, tileY);
  if(!tile) return;

  var hasDrawn = false;

  var tileScreenPos = getTileScreenPosition(tileX, tileY);
  var offsetX = Math.floor(tileScreenPos[0]);
  var offsetY = Math.floor(tileScreenPos[1]);

  var clamp = getTileScreenPosition(tileX + 1, tileY + 1);
  var clampW = Math.floor(clamp[0]) - offsetX;
  var clampH = Math.floor(clamp[1]) - offsetY;

  if(transparentBackground) {
    textRenderCtx.clearRect(0, 0, textRenderCanvas.width, textRenderCanvas.height);
  } else {
    var cursorVisibility = cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY;
    var dBack = renderTileBackground(textRenderCtx, 0, 0, tile, tileX, tileY, cursorVisibility);
    if(dBack) {
      hasDrawn = true;
    }
  }

  if(backgroundEnabled) {
    var dImage = renderTileBackgroundImage(textRenderCtx, tileX, tileY, 0, 0);
    if(dImage) {
      hasDrawn = true;
    }
  }

  if(colorsEnabled) {
    var dCell = renderCellBgColors(textRenderCtx, tileX, tileY, clampW, clampH);
    if(dCell) {
      hasDrawn = true;
    }
  }

  if(!bufferLargeChars) {
    var dCont = renderContent(textRenderCtx, tileX, tileY, clampW, clampH, 0, 0);
    if(dCont) {
      hasDrawn = true;
    }
  } else {
    var d1 = renderContent(textRenderCtx, tileX - 1, tileY, clampW, clampH, clampW * -1, 0, [tileC - 1, 0, tileC - 1, tileR - 1], true); // left
    var d2 = renderContent(textRenderCtx, tileX, tileY, clampW, clampH, 0, 0); // main
    var d3 = renderContent(textRenderCtx, tileX - 1, tileY + 1, clampW, clampH, clampW * -1, clampH * 1, [tileC - 1, 0, tileC - 1, 0], true); // bottom-left corner
    var d4 = renderContent(textRenderCtx, tileX, tileY + 1, clampW, clampH, 0, clampH * 1, [0, 0, tileC - 1, 0], true); // bottom
    if(d1 || d2 || d3 || d4) {
      hasDrawn = true;
    }
  }

  if(gridEnabled) {
    var gridColor = int_to_hexcode(0xFFFFFF - resolveColorValue(getTileBackgroundColor(tile)));
    drawGrid(textRenderCtx, gridColor, 0, 0);
    hasDrawn = true;
  }

  if(hasDrawn) {
    var tileImage = loadTileFromPool(tileX, tileY);
    var poolCtx = tileImage.pool.ctx;
    var poolCanv = tileImage.pool.canv;
    var poolX = tileImage.poolX;
    var poolY = tileImage.poolY;

    tileImage.clampW = clampW;
    tileImage.clampH = clampH;

    if(bgImageHasChanged) {
      testCanvasForCrossOriginError();
      bgImageHasChanged = false;
    }

    // we read a single pixel to force the browser to draw immediately,
    // since we want to precisely control the timing for the queue
    if(canBypassRenderDefer) {
      textRenderCtx.getImageData(0, 0, 1, 1);
    }

    poolCtx.clearRect(poolX, poolY, tileWidth, tileHeight);
    poolCtx.drawImage(textRenderCanvas, 0, 0, tileWidth, tileHeight, poolX, poolY, tileWidth, tileHeight);
  } else {
    markTileFromPoolAsEmpty(tileX, tileY);
  }
}

function renderTile(tileX, tileY) {
  if(!Tile.loaded(tileX, tileY)) return;
  var tileScreenPos = getTileScreenPosition(tileX, tileY);
  var offsetX = Math.floor(tileScreenPos[0]);
  var offsetY = Math.floor(tileScreenPos[1]);

  var tile = Tile.get(tileX, tileY);

  if(!Tile.visible(tileX, tileY)) return;

  var clamp = getTileScreenPosition(tileX + 1, tileY + 1);
  var clampW = Math.floor(clamp[0]) - offsetX;
  var clampH = Math.floor(clamp[1]) - offsetY;

  var cursorVisibility = cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY;

  if(transparentBackground) {
    renderTileBackground(owotCtx, offsetX, offsetY, tile, tileX, tileY, cursorVisibility);
  } else {
    var backgroundUpdated = false;
    var hasHighlightFlash = highlightFlash[tileY + "," + tileX];
    if(hasHighlightFlash) {
      backgroundUpdated = true;
      tile.tp_highlight = true;
    } else {
      if(tile.tp_highlight) {
        backgroundUpdated = true;
        delete tile.tp_highlight;
      }
    }
    if(cursorVisibility) {
      backgroundUpdated = true;
      tile.tp_cursor = true;
    } else if(tile.tp_cursor) {
      backgroundUpdated = true;
      delete tile.tp_cursor;
    }
    if(backgroundUpdated) {
      tile.redraw = true;
    }
  }

  if(tile.redraw || (tile.serial && tile.serial != renderSerial)) {
    tile.redraw = false;
    tile.serial = renderSerial;
    if(!isTileQueued(tileX, tileY)) {
      queueTile(tileX, tileY);
    }
  }

  var tileImage = loadTileFromPool(tileX, tileY, true);
  if(tileImage) {
    // render text data from cache
    var pCanv = tileImage.pool.canv;
    var pX = tileImage.poolX;
    var pY = tileImage.poolY;
    if(tileImage.pool.tileWidth == tileWidth && tileImage.pool.tileHeight == tileHeight) {
      owotCtx.drawImage(pCanv, pX, pY, clampW, clampH, offsetX, offsetY, clampW, clampH);
    } else {
      owotCtx.drawImage(pCanv, pX, pY, tileImage.clampW, tileImage.clampH, offsetX, offsetY, clampW, clampH);
    }
    if(cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY) {
      if(unobstructCursor) {
        drawObstructedCursor(owotCtx, tile.content, cursorCoords[2], cursorCoords[3], offsetX, offsetY);
      }
      if(cursorOutlineEnabled) {
        renderCursorOutline(owotCtx, offsetX, offsetY, tileX, tileY);
      }
    }
  } else {
    var isEmpty = tileImage === null;
    if(!isTileQueued(tileX, tileY) && !isEmpty) {
      queueTile(tileX, tileY);
    }
    if(isEmpty) {
      // tile has no cached image, so render a background
      if(!transparentBackground) {
        owotCtx.fillStyle = getTileBackgroundColor(tile);
        owotCtx.fillRect(offsetX, offsetY, clampW, clampH);
      }
    } else {
      // tile has no cached image, and rendering is in progress
      if(transparentBackground) {
        if(shiftOptimization) {
          owotCtx.fillStyle = "#C0C0C0";
          owotCtx.fillRect(offsetX, offsetY, clampW, clampH);
        } else {
          clearTile(tileX, tileY);
        }
      }
    }
  }

  if(cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY) {
    if(unobstructCursor) {
      drawObstructedCursor(owotCtx, tile.content, cursorCoords[2], cursorCoords[3], offsetX, offsetY);
    }
    if(cursorOutlineEnabled) {
      renderCursorOutline(owotCtx, offsetX, offsetY, tileX, tileY);
    }
  }

  if(w.events.tilerendered) w.emit("tileRendered", {
    tileX: tileX, tileY: tileY,
    startX: offsetX, startY: offsetY,
    endX: offsetX + clampW - 1, endY: offsetY + clampH - 1
  });
}

function renderNextTilesInQueue() {
  var start = performance.now();
  var size = renderQueue.length;
  var fastQueue = true;
  for(var i = 0; i < size; i++) {
    var tileCoords = renderQueue.shift();
    if(tileCoords) {
      var tileX = tileCoords[0];
      var tileY = tileCoords[1];
      var tile = Tile.get(tileX, tileY);
      renderQueueMap.delete(tileY + "," + tileX);
      if(Tile.visible(tileX, tileY)) {
        drawTile(tileX, tileY);
        renderTile(tileX, tileY);
      } else if(tile) {
        tile.redraw = true;
      }
      if(tile && tile.fastQueue) {
        tile.fastQueue = false;
      } else {
        fastQueue = false;
      }
    } else {
      break;
    }
    var end = performance.now();
    var diff = end - start;
    if(diff >= 16 && (!fastQueue || diff > 700)) break;
  }
}

// the 'redraw' parameter is deprecated
function renderTiles(redraw) {
  w.emit("beforeTilesRendered");
  updateCoordDisplay();
  if(unloadedPatternPanning) {
    elm.owot.style.backgroundPosition = positionX + "px " + positionY + "px";
  }
  var optShifted = false;
  var canOptimizeShift = shiftOptimization && zoom <= 0.5 && shiftOptState.zoom == zoom;
  if(!canOptimizeShift) {
    owotCtx.clearRect(0, 0, owotWidth, owotHeight);
  } else {
    owotCtx.drawImage(owot, Math.floor(positionX) - shiftOptState.prevX, Math.floor(positionY) - shiftOptState.prevY);
    optShifted = true;
  }
  if(redraw) w.redraw();
  // render all visible tiles
  var visibleRange = getVisibleTileRange(1.0);
  var startX = visibleRange[0][0];
  var startY = visibleRange[0][1];
  var endX = visibleRange[1][0];
  var endY = visibleRange[1][1];
  for(var y = startY; y <= endY; y++) {
    for(var x = startX; x <= endX; x++) {
      var tile = Tile.get(x, y);
      var shouldRender = false;
      if(tile) {
        shouldRender = tile.redraw || tile.rerender || (tile.serial && tile.serial != renderSerial);
      }
      if(optShifted && !shouldRender) {
        // at really far zooms, we can just shift the whole screen and only blit the tiles beyond the edges
        if(!(shiftOptState.x1 < x && x < shiftOptState.x2 && shiftOptState.y1 < y && y < shiftOptState.y2)) {
          renderTile(x, y);
        }
      } else {
        renderTile(x, y);
      }
      if(optShifted && !Tile.loaded(x, y)) {
        clearTile(x, y);
      }
    }
  }
  if(shiftOptimization) {
    shiftOptState.prevX = Math.floor(positionX);
    shiftOptState.prevY = Math.floor(positionY);
    shiftOptState.x1 = startX;
    shiftOptState.y1 = startY;
    shiftOptState.x2 = endX;
    shiftOptState.y2 = endY;
    shiftOptState.zoom = zoom;
  }
  w.emit("tilesRendered");
}

// re-render only tiles that have changed to the screen
function renderTilesSelective() {
  var visibleRange = getVisibleTileRange(1.0);
  var startX = visibleRange[0][0];
  var startY = visibleRange[0][1];
  var endX = visibleRange[1][0];
  var endY = visibleRange[1][1];
  for(var y = startY; y <= endY; y++) {
    for(var x = startX; x <= endX; x++) {
      var tile = Tile.get(x, y);
      if(!tile) continue;
      if(tile.rerender) {
        delete tile.rerender;
        renderTile(x, y);
      } else if(tile.redraw || (tile.serial && tile.serial != renderSerial)) {
        renderTile(x, y);
      }
    }
  }
}

function setRedrawPatterned(pattern) {
  var visibleRange = getVisibleTileRange(1.0);
  var startX = visibleRange[0][0];
  var startY = visibleRange[0][1];
  var endX = visibleRange[1][0];
  var endY = visibleRange[1][1];
  if(pattern == "square") {
    var midX = Math.floor((startX + endX) / 2);
    var midY = Math.floor((startY + endY) / 2);
    queueTile(midX, midY);
    var dist = Math.max(endY - midY, endX - midX);
    for(var i = 1; i < dist; i++) {
      var xh1 = Math.max(midX - i, startX);
      var xh2 = Math.min(midX + i, endX);
      var yv1 = Math.max(midY - i, startY);
      var yv2 = Math.min(midY + i, endY);
      for(var x = xh1; x <= xh2; x++) {
        if(x < startX || x > endX) break;
        queueTile(x, yv1);
        queueTile(x, yv2);
      }
      for(var y = yv1; y <= yv2; y++) {
        if(y < startY || y > endY) break;
        queueTile(xh1, y);
        queueTile(xh2, y);
      }
    }
  } else if(pattern == "random") {
    var tiles = getVisibleTiles(1.0);
    for(var i = tiles.length - 1; i >= 0; i--) {
      var pos = Math.floor(Math.random() * (i + 1));
      var temp = tiles[i];
      tiles[i] = tiles[pos];
      tiles[pos] = temp;
    }
    for(var i = 0; i < tiles.length; i++) {
      var pos = tiles[i];
      queueTile(pos[0], pos[1]);
    }
  }
}

function renderGuestCursors(renderCtx, offsetX, offsetY, tile, tileX, tileY) {
  var hasDrawn = false;
  var tilePos = tileY + "," + tileX;
  var list = guestCursorsByTile[tilePos];
  for(var channel in list) {
    var cursor = list[channel];
    var charX = cursor.charX;
    var charY = cursor.charY;
    renderCtx.fillStyle = styles.guestCursor;
    renderCtx.fillRect(offsetX + charX * cellW, offsetY + charY * cellH, cellW, cellH);
    hasDrawn = true;
  }
  return hasDrawn;
}

function renderCursorOutline(renderCtx, offsetX, offsetY) {
  if(!cursorCoords) return;
  var color = YourWorld.Color;
  var tileX = cursorCoords[0];
  var tileY = cursorCoords[1];
  var charX = cursorCoords[2];
  var charY = cursorCoords[3];
  renderCtx.strokeStyle = "rgb(" + (color >> 16 & 255) + "," + (color >> 8 & 255) + "," + (color & 255) + ")";
  renderCtx.lineWidth = 2;
  renderCtx.beginPath();
  renderCtx.rect(offsetX + charX * cellW + 1, offsetY + charY * cellH + 1, cellW - 2, cellH - 2);
  renderCtx.stroke();
}

    </script>
    <script>
var YourWorld = {
  Color: window.localStorage ? +localStorage.getItem("color") : 0,
  BgColor: -1,
  Nickname: state.userModel.username
};

var owot, owotCtx, textInput;
var linkElm, linkDiv;
var colorInput, colorInputBg;
var colorShortcuts, colorShortcutsBg;
function init_dom() {
  owot = document.getElementById("owot");
  owot.style.display = "block";
  owot.style.cursor = defaultCursor;
  owotCtx = owot.getContext("2d");
  textInput = document.getElementById("textInput");
  textInput.value = "";
  linkElm = elm.link_element;
  linkDiv = elm.link_div;
  updateCoordDisplay();
  initTextDecoBar();
  defineElements({
    owot: owot,
    textInput: textInput
  });
}
function getWndWidth() {
  return document.body.clientWidth || window.innerWidth;
}
function getWndHeight() {
  return document.body.clientHeight || window.innerHeight;
}
function decimal(percentage) {
  return percentage / 100;
}
function normFontSize(size) {
  return Math.floor(size / 0.1) * 0.1;
}
function deviceRatio() {
  var ratio = window.devicePixelRatio;
  if(!ratio) ratio = 1;
  return ratio;
}

var enums = {};
function makeEnum(vars) {
  var enums = {};
  for(var i = 0; i < vars.length; i++) {
    enums[vars[i]] = i;
  }
  return enums;
}

enums.edit = makeEnum(["tileY", "tileX", "charY", "charX", "time", "char", "id", "color"]);
enums.position = makeEnum(["tileX", "tileY", "charX", "charY"]);

var ws_path = createWsPath();

var menu, menuStyle;
var styles                 = defaultStyles();
var nextObjId              = 1; // Next edit ID
var owotWidth              = getWndWidth();
var owotHeight             = getWndHeight();
var js_alert_active        = false; // JS alert window is open
var worldFocused           = false;
var chatResizing           = false;
var tiles                  = {}; // All loaded tiles
var images                 = {}; // { name: [data RGBA, width, height] }
var keysPressed            = {};
var previousErase          = 0;
var verticalEnterPos       = [0, 0]; // position to go when pressing enter (tileX, charX)
var lastX                  = verticalEnterPos; // Deprecated; temp compat
var imgPatterns            = {};
var textColorOverride      = 0; // public-member-owner bitfield
var writeBuffer            = [];
var highlightFlash         = {};
var highlightCount         = 0;
var coloredChars           = {}; // highlighted chars
var shiftOptState          = { prevX: 0, prevY: 0, x1: 0, y1: 0, x2: 0, y2: 0, prevZoom: -1 };
var backgroundImage        = null;
var backgroundPattern      = null;
var backgroundPatternSize  = [0, 0];
var guestCursorsByTile     = {};
var guestCursors           = {};
var clientGuestCursorPos   = { tileX: 0, tileY: 0, charX: 0, charY: 0, hidden: false, updated: false };
var disconnectTimeout      = null;
var menuOptions            = {};
var undoBuffer             = new CircularBuffer(2048);
var textDecorationOffset   = 0x20F0;
var textDecorationModes    = { bold: false, italic: false, under: false, strike: false };
var fontTemplate           = "$px 'Courier New', monospace";
var specialFontTemplate    = "$px consolas, monospace";
var fontOrder              = ["Courier New", "monospace"];
var specialFontOrder       = ["consolas", "monospace"];
var initiallyFetched       = false;
var lastLinkHover          = null; // [tileX, tileY, charX, charY]
var lastTileHover          = null; // [type, tileX, tileY, (charX, charY)]
var regionSelections       = [];
var specialClientHooks     = {};
var specialClientHookMap   = 0; // bitfield (starts at 0): [before char rendering, (future expansion)]
var bgImageHasChanged      = false;
var remoteBoundary         = { centerX: 0, centerY: 0, minX: 0, minY: 0, maxX: 0, maxY: 0 };
var boundaryStatus         = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

// configuration
var positionX              = 0; // client position in pixels
var positionY              = 0;
var coordSizeX             = 4;
var coordSizeY             = 4;
var gridEnabled            = false;
var subgridEnabled         = false; // character-level grid
var linksEnabled           = true;
var linksRendered          = true;
var colorsEnabled          = true;
var backgroundEnabled      = true; // render backgrounds if any
var scrollingEnabled       = true;
var zoomRatio              = deviceRatio(); // browser's default zoom ratio
var ws_path                = createWsPath();
var protectPrecision       = 0; // 0 = tile, 1 = char
var checkTileFetchInterval = 300; // how often to check for unloaded tiles (ms)
var zoom                   = decimal(100); // absolute zoom value (product of zoomRatio and userZoom)
var userZoom               = decimal(100); // user zoom setting (menubar zoom)
var unloadTilesAuto        = true; // automatically unload tiles to free up memory
var useHighlight           = true; // highlight new edits
var highlightLimit         = 10; // max chars to highlight at a time
var ansiBlockFill          = true; // fill certain ansi block characters
var colorizeLinks          = true;
var brBlockFill            = false; // render individual dots in braille characters as rectangles
var tileFetchOffsetX       = 0; // offset added to tile fetching and sending coordinates
var tileFetchOffsetY       = 0;
var ignoreCanvasContext    = true; // ignore canvas context menu when right clicking
var elementSnapApprox      = 10; // snapping margin for draggable elements
var mSpecRendering         = true; // render special properties if a certain combining character is included
var combiningCharsEnabled  = true;
var surrogateCharsEnabled  = true;
var defaultCoordLinkColor  = "#008000";
var defaultURLLinkColor    = "#0000FF";
var defaultHighlightColor  = [0xFF, 0xFF, 0x99];
var secureJSLink           = true; // display warning prompt when clicking on javascript links
var secureLink             = true; // display confirmation when clicking on links in a suspicious setting
var pasteDirRight          = true; // move cursor right when writing
var pasteDirDown           = true; // move cursor down after pressing enter
var defaultCursor          = "text";
var defaultDragCursor      = "move";
var fetchClientMargin      = 200;
var classicTileProcessing  = false; // directly process utf32 only
var unloadedPatternPanning = false;
var cursorRenderingEnabled = true;
var guestCursorsEnabled    = true; // render guest cursors
var showMyGuestCursor      = true; // show my cursor to everyone if the world allows it
var unobstructCursor       = false; // render cursor on top of characters that may block it
var shiftOptimization      = false;
var transparentBackground  = true;
var writeFlushRate         = state.worldModel.write_interval;
var bufferLargeChars       = true; // prevents certain large characters from being cut off by the grid
var cursorOutlineEnabled   = false;
var showCursorCoordinates  = false; // show cursor coords in coordinate bar
var textDecorationsEnabled = true; // bold, italic, underline, and strikethrough

var keyConfig = {
  reset: "ESC",
  copyColor: "ALT+C",
  copyBgColor: "ALT+B",
  copyCharacterText: "CTRL+C",
  copyCharacterMouse: "CTRL+M",
  sidewaysScroll: "SHIFT",
  tab: "TAB",
  autoSelect: "CTRL",
  autoApply: ["CTRL+S", "ALT+S"],
  autoDeselect: "SHIFT",
  erase: "BACKSPACE+*",
  cellErase: "DELETE+*",
  cursorUp: "UP+*",
  cursorDown: "DOWN+*",
  cursorLeft: "LEFT+*",
  cursorRight: "RIGHT+*",
  copyRegion: ["ALT+G", "CTRL+A"],
  centerTeleport: "HOME",
  undo: "CTRL+Z",
  redo: ["CTRL+Y", "CTRL+SHIFT+Z"],
  showTextDeco: ["CTRL+Q", "ALT+Q", "CTRL+SHIFT+F"]
};

window.addEventListener("load", function() {
  w.emit("clientLoaded");
});

defineElements({ // elm[<name>]
  loading: byId("loading"),
  coord_Y: byId("coord_Y"),
  coord_X: byId("coord_X"),
  tile_Y: byId("tile_Y"),
  tile_X: byId("tile_X"),
  char_Y: byId("char_Y"),
  char_X: byId("char_X"),
  chatbar: byId("chatbar"),
  color_input_form_input: byId("color_input_form_input"),
  protect_precision: byId("protect_precision"),
  announce_container: byId("announce_container"),
  tile_choice: byId("tile_choice"),
  char_choice: byId("char_choice"),
  menu_elm: byId("menu"),
  nav_elm: byId("nav"),
  coords: byId("coords"),
  cursor_coords: byId("cursor_coords"),
  cursor_on: byId("cursor_on"),
  cursor_off: byId("cursor_off"),
  chat_window: byId("chat_window"),
  confirm_js: byId("confirm_js"),
  confirm_js_msg: byId("confirm_js_msg"),
  confirm_js_code: byId("confirm_js_code"),
  main_view: byId("main_view"),
  usr_online: byId("usr_online"),
  link_element: byId("link_element"),
  link_div: byId("link_div"),
  protect_selection: byId("protect_selection"),
  text_decorations: byId("text_decorations"),
  text_deco_b: byId("text_deco_b"),
  text_deco_i: byId("text_deco_i"),
  text_deco_u: byId("text_deco_u"),
  text_deco_s: byId("text_deco_s")
});

function setRGBColorPicker(r, g, b) {
  colorInput.jscolor.fromRGB(r, g, b);
}

function setRGBBgColorPicker(r, g, b) {
  colorInputBg.jscolor.fromRGB(r, g, b);
}

function setColorPickerRandom() {
  var r = Math.floor(Math.random() * 256);
  var g = Math.floor(Math.random() * 256);
  var b = Math.floor(Math.random() * 256);
  setRGBColorPicker(r, g, b);
}

function updateColorPicker() {
  var r = (YourWorld.Color >> 16) & 255;
  var g = (YourWorld.Color >> 8) & 255;
  var b = YourWorld.Color & 255;
  setRGBColorPicker(r, g, b);
}

function updateBgColorPicker() {
  var r = (YourWorld.BgColor >> 16) & 255;
  var g = (YourWorld.BgColor >> 8) & 255;
  var b = YourWorld.BgColor & 255;
  setRGBBgColorPicker(r, g, b);
}

function updateCoordDisplay() {
  var tileCoordX = -positionX / tileW;
  var tileCoordY = -positionY / tileH;
  var centerY = -Math.floor(tileCoordY / coordSizeY);
  var centerX = Math.floor(tileCoordX / coordSizeX);
  elm.coord_Y.innerText = centerY;
  elm.coord_X.innerText = centerX;

  if (showCursorCoordinates) {
    if (cursorCoords === null) {
      elm.cursor_on.style.display = "none";
      elm.cursor_off.style.display = "";
      return;
    }

    elm.cursor_on.style.display = "";
    elm.cursor_off.style.display = "none";
    [elm.tile_X.innerText,
       elm.tile_Y.innerText,
     elm.char_X.innerText,
     elm.char_Y.innerText] = [...cursorCoords];
  }
}

w.on("cursorMove", updateCoordDisplay);
w.on("cursorHide", updateCoordDisplay);

elm.coords.onclick = function() {
  showCursorCoordinates = !showCursorCoordinates;
  if(showCursorCoordinates) {
    elm.cursor_coords.style.display = "";
    updateCoordDisplay();
  } else {
    elm.cursor_coords.style.display = "none";
    updateCoordDisplay();
  }
}

function createColorButton(color, isHighlight) {
  var celm = document.createElement("span");
  var colorInt = resolveColorValue(color);
  var colorValues = int_to_rgb(colorInt);
  celm.className = "color_btn";
  var hex = int_to_hexcode(colorInt);
  celm.style.backgroundColor = hex;
  celm.title = hex.toUpperCase();
  celm.onclick = function() {
    if(!isHighlight) {
      setRGBColorPicker(colorValues[0], colorValues[1], colorValues[2]);
    } else {
      enableBgColorPicker();
      setRGBBgColorPicker(colorValues[0], colorValues[1], colorValues[2]);
    }
    w.ui.colorModal.submitForm();
  }
  return celm;
}

function addColorShortcuts() {
  var colors = [
    "#000000",
    "#FF0000",
    "#008000",
    "#0000FF",
    "#FFFFFF"
  ];
  var colors_highlight = [
    "#F49446",
    "#DCE943",
    "#07D555",
    "#529DC9",
    "#9D7DC6",
    "#EA5BB6"
  ];
  for(var i = 0; i < colors.length; i++) {
    var color = colors[i];
    colorShortcuts.appendChild(createColorButton(color));
  }
  for(var i = 0; i < colors_highlight.length; i++) {
    var color = colors_highlight[i];
    colorShortcutsBg.appendChild(createColorButton(color, true));
  }
  var rand = document.createElement("span");
  rand.className = "color_btn";
  rand.style.backgroundColor = "#FFFFFF";
  rand.innerText = "?";
  rand.title = "Random color";
  rand.onclick = setColorPickerRandom;
  colorShortcuts.appendChild(rand);

  var bgNone = document.createElement("span");
  bgNone.id = "color_btn_no_cell";
  bgNone.className = "color_btn";
  bgNone.style.backgroundColor = "#FFFFFF";
  bgNone.title = "No background color";
  bgNone.onclick = function() {
    w.ui.colorModal.close(true); // close + cancel
    disableBgColorPicker();
    YourWorld.BgColor = -1;
  }
  colorShortcutsBg.appendChild(bgNone);
}

init_dom(); // TODO: put this elsewhere

var draggable_element_mousemove = [];
var draggable_element_mouseup = [];
function draggable_element(dragger, dragged, exclusions, onDrag) {
  if(!dragged) {
    dragged = dragger;
  }
  var elmX = 0;
  var elmY = 0;
  var elmHeight = 0;
  var elmWidth = 0;
  var dragging = false;

  var clickX = 0;
  var clickY = 0;
  dragger.addEventListener("mousedown", function(e) {
    if(exclusions) {
      for(var i = 0; i < exclusions.length; i++) {
        if(closest(e.target, exclusions[i])) {
          return;
        }
      }
    }
    if(!closest(e.target, dragger)) return;
    elmX = dragged.offsetLeft;
    elmY = dragged.offsetTop;
    elmWidth = dragged.offsetWidth;
    elmHeight = dragged.offsetHeight;
    dragging = true;
    clickX = e.pageX;
    clickY = e.pageY;
  });
  // when the element is being dragged
  draggable_element_mousemove.push(function(e, arg_pageX, arg_pageY) {
    if(!dragging) return;
    if(onDrag) {
      if(onDrag() == -1) return;
    }
    dragged.style.top = "";
    dragged.style.bottom = "";
    dragged.style.left = "";
    dragged.style.right = "";

    var diffX = arg_pageX - clickX;
    var diffY = arg_pageY - clickY;

    var newY = elmY + diffY;
    var newX = elmX + diffX;

    dragged.style.top = newY + "px";
    dragged.style.left = newX + "px";
    if(newX <= elementSnapApprox) {
      dragged.style.left = "0px";
    }
    if(newX + elmWidth >= getWndWidth() - elementSnapApprox) {
      dragged.style.left = "";
      dragged.style.right = "0px";
    }
    if(newY <= elementSnapApprox) {
      dragged.style.top = "0px";
    }
    if(newY + elmHeight >= getWndHeight() - elementSnapApprox) {
      dragged.style.top = "";
      dragged.style.bottom = "0px";
    }
  });
  // when the element is released
  draggable_element_mouseup.push(function() {
    dragging = false;
  });
}

function resizeChat(width, height) {
  // default: 400 x 300
  if(width < 350) width = 350;
  if(height < 57) height = 57;
  elm.chat_window.style.width = width + "px";
  elm.chat_window.style.height = height + "px";
  return [width, height];
}

draggable_element(elm.chat_window, null, [
  elm.chatbar, elm.chatsend, elm.chat_close, elm.chat_page_tab, elm.chat_global_tab, elm.page_chatfield, elm.global_chatfield
], function() {
  if(chatResizing) {
    return -1;
  }
});
draggable_element(elm.confirm_js, null, [
  elm.confirm_js_code
]);
resizable_chat();

function getStoredNickname() {
  var nick = YourWorld.Nickname;
  if(window.localStorage && localStorage.getItem) {
    nick = localStorage.getItem("nickname");
  }
  if(!nick) nick = YourWorld.Nickname;
  YourWorld.Nickname = nick;
}
function storeNickname() {
  if(window.localStorage && localStorage.setItem) {
    localStorage.setItem("nickname", YourWorld.Nickname);
  }
}

function getStoredConfig() {
  if(!window.localStorage || !localStorage.getItem) return;
  var conf = localStorage.getItem("config");
  if(!conf) return;
  conf = JSON.parse(conf);
  cursorOutlineEnabled = conf.cursorOutline;
}
function storeConfig() {
  if(!window.localStorage || !localStorage.setItem) return;
  var conf = {
    cursorOutline: cursorOutlineEnabled
  };
  localStorage.setItem("config", JSON.stringify(conf));
}

function loadBackgroundData(cb, timeout_cb) {
  if(!backgroundEnabled || !state.background) {
    return cb();
  }
  var backPath = state.background.path;
  var backImgElm = new Image();
  var error = false;
  var timeout = false;
  var loadTimeout = setTimeout(function() {
    timeout = true;
    cb();
  }, 300);
  backImgElm.src = backPath;
  backImgElm.onload = function() {
    clearTimeout(loadTimeout);
    if(error) {
      if(!timeout) cb();
      return;
    }
    backgroundImage = backImgElm;
    backgroundPattern = owotCtx.createPattern(backImgElm, "repeat");
    backgroundPatternSize = [backImgElm.width, backImgElm.height];
    if(timeout) {
      // if it eventually loads after timing out
      if(timeout_cb) timeout_cb();
    } else {
      cb();
    }
    bgImageHasChanged = true;
  }
  backImgElm.onerror = function() {
    error = true;
    backImgElm.onload();
  }
}

function keydown_regionSelect(e) {
  if(!checkKeyPress(e, keyConfig.copyRegion) || regionSelectionsActive()) return;
  if(Modal.isOpen) return;
  if(!worldFocused) return;
  e.preventDefault();
  w.regionSelect.startSelection();
}
document.addEventListener("keydown", keydown_regionSelect);

function handleRegionSelection(coordA, coordB, regWidth, regHeight) {
  var tileX = coordA[0];
  var tileY = coordA[1];
  var charX = coordA[2];
  var charY = coordA[3];
  var reg = [];
  var colors = [];
  var bgcolors = [];
  var links = [];
  var protections = [];
  var decorations = [];
  for(var y = 0; y < regHeight; y++) {
    // rows
    var r_reg = [];
    var r_colors = [];
    var r_bgcolors = [];
    var r_links = [];
    var r_protections = [];
    var r_decorations = [];
    // contains non-default (not null) value in row?
    var c_color = false;
    var c_bgcolor = false;
    var c_link = false;
    var c_protection = false;
    var c_decoration = false;
    for(var x = 0; x < regWidth; x++) {
      var charInfo = getCharInfo(tileX, tileY, charX, charY);
      var char = charInfo.char;
      char = char.replace(/\r|\n|\x1b/g, " ");
      r_reg.push(char);
      r_colors.push(charInfo.color);
      r_bgcolors.push(charInfo.bgColor);
      if(charInfo.color) c_color = true;
      if(charInfo.bgColor != -1) c_bgcolor = true;
      var tile = Tile.get(tileX, tileY);
      var containsLink = false;
      if(tile && tile.properties && tile.properties.cell_props) {
        if(tile.properties.cell_props[charY] && tile.properties.cell_props[charY][charX]) {
          var link = tile.properties.cell_props[charY][charX];
          if(link.link) {
            link = link.link;
            containsLink = true;
            c_link = true;
            if(link.type == "url") {
              r_links.push("$u" + "\"" + escapeQuote(link.url) + "\"");
            } else if(link.type == "coord") {
              r_links.push("$c" + "[" + link.link_tileX + "," + link.link_tileY + "]");
            }
          }
        }
      }
      r_protections.push(charInfo.protection);
      if(charInfo.protection !== null) c_protection = true;
      if(!containsLink) {
        r_links.push(null);
      }
      r_decorations.push(charInfo.decoration);
      if(charInfo.decoration !== null) c_decoration = true;
      charX++;
      if(charX >= tileC) {
        charX = 0;
        tileX++;
      }
    }
    if(!c_color) r_colors = null;
    if(!c_link) r_links = null;
    if(!c_protection) r_protections = null;
    if(!c_decoration) r_decorations = null;
    if(!c_bgcolor) r_bgcolors = null;
    reg.push(r_reg);
    colors.push(r_colors);
    bgcolors.push(r_bgcolors);
    links.push(r_links);
    protections.push(r_protections);
    decorations.push(r_decorations);
    tileX = coordA[0];
    charX = coordA[2];
    charY++;
    if(charY >= tileR) {
      charY = 0;
      tileY++;
    }
  }
  w.ui.selectionModal.open(reg, colors, bgcolors, links, protections, decorations, [coordA, coordB]);
  w.emit("regionSelected", {
    a: coordA,
    b: coordB
  });
}

var defaultSizes = {
  // in pixels
  cellW: 10,
  cellH: 18,
  // assigned later
  tileW: null,
  tileH: null,
  // in characters
  tileC: 16, // columns (width)
  tileR: 8 // rows (height)
}
if(state.worldModel.square_chars) defaultSizes.cellW = 18;
if(state.worldModel.half_chars) defaultSizes.cellH = 20;
if(state.worldModel.tileCols) defaultSizes.tileC = state.worldModel.tileCols;
if(state.worldModel.tileRows) defaultSizes.tileR = state.worldModel.tileRows;

var cellWidthPad, tileW, tileH, cellW, cellH, font, specialCharFont, tileC, tileR, tileArea;
var tileWidth, tileHeight; // exact tile dimensions for determining rendering size of tiles
var dTileW, dTileH; // locked tile sizes for background image generation

function buildFontTemplate(set) {
  var str = "$px ";
  for(var i = 0; i < set.length; i++) {
    var name = set[i];
    if(i != 0) {
      str += ", ";
    }
    if(name.includes(" ")) {
      str += "'" + name + "'";
    } else {
      str += name;
    }
  }
  return str;
}

function rebuildFontTemplates() {
  fontTemplate = buildFontTemplate(fontOrder);
  specialFontTemplate = buildFontTemplate(specialFontOrder);
}

function updateScaleConsts() {
  defaultSizes.tileW = defaultSizes.cellW * defaultSizes.tileC;
  defaultSizes.tileH = defaultSizes.cellH * defaultSizes.tileR;
  dTileW = defaultSizes.tileW;
  dTileH = defaultSizes.tileH;
  cellWidthPad = Math.floor((defaultSizes.cellW - 10) / 2); // X text offset if the cell is wider

  tileW = defaultSizes.tileW * zoom;
  tileH = defaultSizes.tileH * zoom;
  cellW = defaultSizes.cellW * zoom;
  cellH = defaultSizes.cellH * zoom;

  tileWidth = Math.ceil(tileW);
  tileHeight = Math.ceil(tileH);

  var fontSize = normFontSize(16 * zoom);

  font = fontTemplate.replace("$", fontSize);
  specialCharFont = specialFontTemplate.replace("$", fontSize);

  textRenderCanvas.width = tileWidth + 5;
  textRenderCanvas.height = tileHeight + 5;
  textRenderCtx.font = font;

  tileC = defaultSizes.tileC;
  tileR = defaultSizes.tileR;
  tileArea = tileC * tileR;
}

var textRenderCanvas;
var textRenderCtx;
function setupTextRenderCtx() {
  if(!textRenderCanvas) {
    textRenderCanvas = document.createElement("canvas");
  } else {
    textRenderCanvas.remove();
    textRenderCanvas = document.createElement("canvas");
  }
  if(transparentBackground) {
    textRenderCtx = textRenderCanvas.getContext("2d", {
      willReadFrequently: true
    });
  } else {
    textRenderCtx = textRenderCanvas.getContext("2d", {
      alpha: false,
      willReadFrequently: true
    });
  }
}

setupTextRenderCtx();
updateScaleConsts();

function reloadRenderer() {
  if(tileCanvasPool.length) {
    removeAllTilesFromPools();
    deleteAllPools();
    w.redraw();
  }
}

// set absolute zoom - must not be called directly (use changeZoom)
function updateRendererZoom(percentage) {
  if(percentage < 3) percentage = 3;
  if(percentage > 1000) percentage = 1000;
  percentage = decimal(percentage);
  zoom = percentage;

  if(zoom < 0.20) {
    shiftOptimization = true;
  }
  updateScaleConsts();

  if(tileWidth * tileHeight > 100000000) {
    throw "Memory leak";
  }
  textRenderCanvas.width = tileWidth + 5;
  textRenderCanvas.height = tileHeight + 5;
  textRenderCtx.font = font;

  // change size of invisible link
  linkDiv.style.width = (cellW / zoomRatio) + "px";
  linkDiv.style.height = (cellH / zoomRatio) + "px";

  // rerender everything
  w.redraw();
}

function zoomGarbageCollect() {
  if(tileCanvasPool.length > 100 || countTotalPoolPixels() > 10000000) {
    cleanupDirtyTiles();
  }
  deleteEmptyPools();
}

// set user zoom
function changeZoom(percentage, isPartial) {
  if(!isPartial) {
    positionX /= zoom;
    positionY /= zoom;
  }
  userZoom = percentage / 100;
  if(userZoom < 0.2) userZoom = 0.2;
  if(userZoom > 10) userZoom = 10;
  updateRendererZoom(userZoom * deviceRatio() * 100);
  if(!isPartial) {
    positionX *= zoom;
    positionY *= zoom;
    positionX = Math.trunc(positionX); // remove decimals
    positionY = Math.trunc(positionY);
    w.render();
    zoomGarbageCollect();
  }
  setZoombarValue();
}

function setZoombarValue() {
  // zoombar is logarithmic. work in reverse.
  zoombar.value = fromLogZoom(userZoom) * 100;
}

function fromLogZoom(val) {
  if(val <= 1) {
    val = Math.pow(2, -1 / val); 
  } else {
    val = 1 - Math.pow(2, -val);
  }
  return val;
}

function toLogZoom(val) {
  if(val <= 0.5) {
    val = -1 / Math.log2(val);
  } else {
    val = -Math.log2(1 - val);
  }
  return val;
}

function browserZoomAdjust(initial) {
  zoomRatio = deviceRatio();
  var absZoom = zoomRatio * userZoom;
  if(zoom == absZoom && !initial) return false; // if no zoom change is detected, do nothing
  positionX /= zoom;
  positionY /= zoom;
  adjust_scaling_DOM(zoomRatio);
  updateRendererZoom(absZoom * 100);
  positionX *= zoom;
  positionY *= zoom;
  positionX = Math.trunc(positionX);
  positionY = Math.trunc(positionY);
  return true;
}

var tileProtectAuto = {
  selected: {},
  selectedTile: null,
  xPos: 0,
  yPos: 0,
  charXPos: 0,
  charYPos: 0,
  lastPos: null,
  mode: 0,
  ctrlDown: false,
  shiftDown: false,
  clearSelections: function() {
    for(var i in tileProtectAuto.selected) {
      tiles[i].backgroundColor = "";
      delete tileProtectAuto.selected[i];
    }
  },
  active: false
}

var linkAuto = {
  selected: {},
  ctrlDown: 0,
  shiftDown: 0,
  mode: 0,
  url: "",
  coordTileX: 0,
  coordTileY: 0,
  lastPos: null,
  active: false
}

var autoTotal = 0;
function updateAutoProg() {
  if(autoTotal > 0) {
    auto_prog.style.display = "";
  } else {
    auto_prog.style.display = "none";
  }
  auto_prog.innerText = autoTotal + " remaining";
}

// Fast tile protecting
function mousemove_tileProtectAuto() {
  if(!tileProtectAuto.active) return;
  var tile = Tile.get(currentPosition[0], currentPosition[1]);
  if(!tile) return;
  tileProtectAuto.selectedTile = tile;
  var tileX = currentPosition[0];
  var tileY = currentPosition[1];
  var charX = currentPosition[2];
  var charY = currentPosition[3];
  var lastPos = tileProtectAuto.lastPos;
  tileProtectAuto.xPos = tileX;
  tileProtectAuto.yPos = tileY;
  tileProtectAuto.charXPos = charX;
  tileProtectAuto.charYPos = charY;
  if(tileProtectAuto.ctrlDown) {
    var line = null;
    var absX = tileX * tileC + charX;
    var absY = tileY * tileR + charY;
    if(protectPrecision == 0) {
      absX = tileX;
      absY = tileY;
    }
    if(lastPos && lastPos[4] == protectPrecision) {
      var labsX = lastPos[0] * tileC + lastPos[2];
      var labsY = lastPos[1] * tileR + lastPos[3];
      if(protectPrecision == 0) {
        labsX = lastPos[0];
        labsY = lastPos[1];
      }
      line = lineGen(labsX, labsY, absX, absY, 1000);
    } else {
      line = [[absX, absY]];
    }
    tileProtectAuto.lastPos = [tileX, tileY, charX, charY, protectPrecision];
    var updTiles = {};
    for(var i = 0; i < line.length; i++) {
      var chr = line[i];
      var x = chr[0];
      var y = chr[1];
      var ctileX = Math.floor(x / tileC);
      var ctileY = Math.floor(y / tileR);
      var ccharX = x - ctileX * tileC;
      var ccharY = y - ctileY * tileR;
      if(protectPrecision == 0) {
        ctileX = x;
        ctileY = y;
      }
      var tempTile = Tile.get(ctileX, ctileY);
      var mode = tileProtectAuto.mode;
      if(protectPrecision == 0 && tempTile) {
        tileProtectAuto.selected[ctileY + "," + ctileX] =
          [protectPrecision, mode, tempTile];
      } else if(protectPrecision == 1 && tempTile) {
        tileProtectAuto.selected[ctileY + "," + ctileX + "," + ccharY + "," + ccharX] =
          [protectPrecision, mode, tempTile];
      }
      var colors = ["red", "green", "blue", "teal"];
      var color = colors[mode];
      if(protectPrecision == 0) {
        if(tempTile) tempTile.backgroundColor = color;
      } else if(protectPrecision == 1) {
        uncolorChar(ctileX, ctileY, ccharX, ccharY, "qprot*");
        colorChar(ctileX, ctileY, ccharX, ccharY, "qprot" + mode);
      }
      updTiles[ctileY + "," + ctileX] = 1;
    }
    for(var i in updTiles) {
      var pos = i.split(",");
      var tileX = parseInt(pos[1]);
      var tileY = parseInt(pos[0]);
      w.setTileRedraw(tileX, tileY, true);
    }
  }
  if(tileProtectAuto.shiftDown) {
    var pos = tileY + "," + tileX;
    if(protectPrecision == 1) {
      pos = tileY + "," + tileX + "," + charY + "," + charX;
    }
    if(tileProtectAuto.selected[pos] !== void 0) {
      var precision = tileProtectAuto.selected[pos][0];
      if(precision == 0) {
        tile.backgroundColor = "";
      } else if(precision == 1) {
        uncolorChar(tileX, tileY, charX, charY, "qprot*");
      }
      delete tileProtectAuto.selected[pos];
      w.setTileRender(tileX, tileY);
    }
  }
}
document.addEventListener("mousemove", mousemove_tileProtectAuto);

function keydown_tileProtectAuto(e) {
  if(!worldFocused) return;
  if(checkKeyPress(e, keyConfig.autoApply)) { // Alt/Ctrl + S to protect tiles
    var selected = tileProtectAuto.selected;
    var types = ["owner-only", "member-only", "public"];
    var keys = Object.keys(selected);
    if(keys.length == 0) return;
    e.preventDefault();
    autoTotal += keys.length;
    updateAutoProg();

    var idx = 0;
    function step() {
      var i = keys[idx];
      idx++;
      var pos = i.split(",").map(Number);
      var precision = selected[i][0];
      var prot = selected[i][1];

      var tileX = pos[1];
      var tileY = pos[0];
      var charX = pos[3];
      var charY = pos[2];

      var position = {
        tileY: tileY,
        tileX: tileX
      };
      if(precision == 1) {
        position.charX = charX;
        position.charY = charY;
      }
      var type;
      if(prot == 3) {
        type = "unprotect";
      } else {
        type = types[prot];
      }
      network.protect(position, type);

      autoTotal--;
      updateAutoProg();
      if(precision == 0) {
        selected[i][2].backgroundColor = "";
        delete selected[i];
        w.setTileRender(tileX, tileY);
      } else if(precision == 1) {
        delete selected[i];
        uncolorChar(tileX, tileY, charX, charY, "qprot*");
        w.setTileRedraw(tileX, tileY, true);
      }

      if(idx >= keys.length) return;
      //setTimeout(step, 4); // (MOD)
      step(); // (MOD)
    }
    step();
  } else {
    var ctrlState = tileProtectAuto.ctrlDown;
    tileProtectAuto.ctrlDown = checkKeyPress(e, keyConfig.autoSelect);
    tileProtectAuto.shiftDown = checkKeyPress(e, keyConfig.autoDeselect);
    if(!ctrlState && tileProtectAuto.ctrlDown) {
      tileProtectAuto.lastPos = null;
    }
  }
}
document.body.addEventListener("keydown", keydown_tileProtectAuto);

// Fast linking
function mousemove_linkAuto() {
  if(!linkAuto.active) return;
  var tile = Tile.get(currentPosition[0], currentPosition[1]);
  if(!tile) return;
  
  var tileX = currentPosition[0];
  var tileY = currentPosition[1];
  var charX = currentPosition[2];
  var charY = currentPosition[3];
  var lastPos = linkAuto.lastPos;

  if(linkAuto.ctrlDown) {
    var line = null;
    var absX = tileX * tileC + charX;
    var absY = tileY * tileR + charY;
    if(lastPos) {
      var labsX = lastPos[0] * tileC + lastPos[2];
      var labsY = lastPos[1] * tileR + lastPos[3];
      line = lineGen(labsX, labsY, absX, absY, 1000);
    } else {
      line = [[absX, absY]];
    }
    linkAuto.lastPos = [tileX, tileY, charX, charY];
    var updTiles = {};
    for(var i = 0; i < line.length; i++) {
      var chr = line[i];
      var x = chr[0];
      var y = chr[1];
      var ctileX = Math.floor(x / tileC);
      var ctileY = Math.floor(y / tileR);
      var ccharX = x - ctileX * tileC;
      var ccharY = y - ctileY * tileR;

      uncolorChar(ctileX, ctileY, ccharX, ccharY, "qlink*");
      colorChar(ctileX, ctileY, ccharX, ccharY, "qlink" + linkAuto.mode);
      updTiles[ctileY + "," + ctileX] = 1;
      var ar = [ctileX, ctileY, ccharX, ccharY, linkAuto.mode];
      if(linkAuto.mode == 0) {
        ar.push([linkAuto.url])
      } else if(linkAuto.mode == 1) {
        ar.push([linkAuto.coordTileX, linkAuto.coordTileY]);
      }
      linkAuto.selected[ctileY + "," + ctileX + "," + ccharY + "," + ccharX] = ar;
    }
    for(var i in updTiles) {
      var pos = i.split(",");
      var tileX = parseInt(pos[1]);
      var tileY = parseInt(pos[0]);
      w.setTileRedraw(tileX, tileY, true);
    }
  }
  if(linkAuto.shiftDown) {
    var elm = linkAuto.selected[tileY + "," + tileX + "," + charY + "," + charX];
    if(elm !== void 0) {
      uncolorChar(tileX, tileY, charX, charY, "qlink*");
      w.setTileRedraw(tileX, tileY, true);
      delete linkAuto.selected[tileY + "," + tileX + "," + charY + "," + charX];
    }
  }
}
document.addEventListener("mousemove", mousemove_linkAuto);

function keydown_linkAuto(e) {
  if(!worldFocused) return;
  if(checkKeyPress(e, keyConfig.autoApply)) { // Alt/Ctrl + S to add links
    var selected = linkAuto.selected;
    var keys = Object.keys(selected);
    if(keys.length == 0) return;
    e.preventDefault();
    autoTotal += keys.length;
    updateAutoProg();

    var idx = 0;
    function step() {
      var i = keys[idx];
      idx++;
      var pos = i.split(",").map(Number);
      var tileX = pos[1];
      var tileY = pos[0];
      var charX = pos[3];
      var charY = pos[2];

      var mode = selected[i][4];
      var linkData = selected[i][5];

      var data = {};
      var link_type;
      if(mode == 0) {
        data.url = w.url_input;
        link_type = "url";
        data.url = linkData[0];
      } else if(mode == 1) {
        link_type = "coord";
        data.x = linkData[0];
        data.y = linkData[1];
      }

      network.link({
        tileY: tileY,
        tileX: tileX,
        charY: charY,
        charX: charX
      }, link_type, data);

      autoTotal--;
      updateAutoProg();
      delete selected[i];
      uncolorChar(tileX, tileY, charX, charY, "qlink*");
      w.setTileRedraw(tileX, tileY, true);

      if(idx >= keys.length) return;
      //setTimeout(step, 4); // (MOD)
      step(); // (MOD)
    }
    step();
  } else {
    var ctrlState = linkAuto.ctrlDown;
    linkAuto.ctrlDown = checkKeyPress(e, keyConfig.autoSelect);
    linkAuto.shiftDown = checkKeyPress(e, keyConfig.autoDeselect);
    if(!ctrlState && linkAuto.ctrlDown) {
      linkAuto.lastPos = null;
    }
  }
}
document.body.addEventListener("keydown", keydown_linkAuto);

function onKeyUp(e) {
  var sel = checkKeyPress(e, keyConfig.autoSelect);
  var des = checkKeyPress(e, keyConfig.autoDeselect);
  linkAuto.ctrlDown = sel;
  linkAuto.shiftDown = des;
  tileProtectAuto.ctrlDown = sel;
  tileProtectAuto.shiftDown = des;

  if(checkKeyPress(e, keyConfig.cursorUp)) { // arrow up
    autoArrowKeyMoveStop("up");
  }
  if(checkKeyPress(e, keyConfig.cursorDown)) { // arrow down
    autoArrowKeyMoveStop("down");
  }
  if(checkKeyPress(e, keyConfig.cursorLeft)) { // arrow left
    autoArrowKeyMoveStop("left");
  }
  if(checkKeyPress(e, keyConfig.cursorRight)) { // arrow right
    autoArrowKeyMoveStop("right");
  }
  if(checkKeyPress(e, keyConfig.centerTeleport) && e.target == elm.textInput) { // home
    w.doGoToCoord(0, 0);
  }
}
document.body.addEventListener("keyup", onKeyUp);

function adjust_scaling_DOM(ratio) {
  var window_width = getWndWidth();
  var window_height = getWndHeight();
  // change variable sizes to the screen-width of the inner browser (same, regardless of zoom)
  owotWidth = Math.round(window_width * ratio);
  owotHeight = Math.round(window_height * ratio);
  // make size of canvas the size of the inner browser screen-size
  elm.owot.width = Math.round(window_width * ratio);
  elm.owot.height = Math.round(window_height * ratio);
  // make the display size the size of the viewport
  elm.owot.style.width = window_width + "px";
  elm.owot.style.height = window_height + "px";
  if(shiftOptimization) {
    shiftOptState.zoom = -1;
  }
}

function event_resize() {
  var ratio = deviceRatio();
  if(!ratio) ratio = 1;
  w.emit("resize", ratio);
  if(!browserZoomAdjust()) {
    adjust_scaling_DOM(ratio);
  }
  w.render();
}
window.addEventListener("resize", event_resize);

function getChar(tileX, tileY, charX, charY) {
  if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
    if(!cursorCoords) return -1;
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
    charX = cursorCoords[2];
    charY = cursorCoords[3];
  }
  var tile = Tile.get(tileX, tileY);
  if(!tile) return " ";
  var content = tile.content;
  var char = content[charY * tileC + charX];
  char = clearCharTextDecorations(char);
  char = resolveCharEmojiCombinations(char);
  return char;
}

function getCharColor(tileX, tileY, charX, charY) {
  if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
    if(!cursorCoords) return -1;
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
    charX = cursorCoords[2];
    charY = cursorCoords[3];
  }
  var tile = Tile.get(tileX, tileY);
  if(!tile) return 0;
  if(!tile.properties.color) return 0;
  return tile.properties.color[charY * tileC + charX];
}

function getCharBgColor(tileX, tileY, charX, charY) {
  if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
    if(!cursorCoords) return -1;
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
    charX = cursorCoords[2];
    charY = cursorCoords[3];
  }
  var tile = Tile.get(tileX, tileY);
  if(!tile) return -1;
  if(!tile.properties.bgcolor) return -1;
  return tile.properties.bgcolor[charY * tileC + charX];
}

function getCharProtection(tileX, tileY, charX, charY) {
  if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
    if(!cursorCoords) return -1;
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
    charX = cursorCoords[2];
    charY = cursorCoords[3];
  }
  var tile = Tile.get(tileX, tileY);
  if(!tile) return state.worldModel.writability;
  var prot = tile.properties.writability;
  if(tile.properties && tile.properties.char) {
    prot = tile.properties.char[charY * tileC + charX];
    // null indicates that it inherits writability from its parent
    if(prot == null) prot = tile.properties.writability;
  }
  if(prot == null) prot = state.worldModel.writability;
  return prot;
}

function getCharDecoration(tileX, tileY, charX, charY) {
  if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
    if(!cursorCoords) return -1;
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
    charX = cursorCoords[2];
    charY = cursorCoords[3];
  }
  var tile = Tile.get(tileX, tileY);
  if(!tile) return null;
  var content = tile.content;
  var char = content[charY * tileC + charX];
  return getCharTextDecorations(char);
}

function getCharInfo(tileX, tileY, charX, charY) {
  if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
    if(!cursorCoords) return -1;
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
    charX = cursorCoords[2];
    charY = cursorCoords[3];
  }
  return {
    loaded: isTileLoaded(tileX, tileY),
    char: getChar(tileX, tileY, charX, charY),
    color: getCharColor(tileX, tileY, charX, charY),
    bgColor: getCharBgColor(tileX, tileY, charX, charY),
    protection: getCharProtection(tileX, tileY, charX, charY),
    decoration: getCharDecoration(tileX, tileY, charX, charY)
  };
}

function getCharInfoXY(x, y) {
  var tileX = Math.floor(x / tileC);
  var tileY = Math.floor(y / tileR);
  var charX = x - tileX * tileC;
  var charY = y - tileY * tileR;
  return getCharInfo(tileX, tileY, charX, charY);
}

function getLink(tileX, tileY, charX, charY) {
  if(!Tile.get(tileX, tileY)) return null;
  var tile = Tile.get(tileX, tileY);
  if(!tile) return null;
  var props = tile.properties.cell_props;
  if(!props) return null;
  if(!props[charY]) return null;
  if(!props[charY][charX]) return null;
  if(!props[charY][charX].link) return null;
  return props[charY][charX].link;
}

function getLinkXY(x, y) {
  var tileX = Math.floor(x / tileC);
  var tileY = Math.floor(y / tileR);
  var charX = x - tileX * tileC;
  var charY = y - tileY * tileR;
  return getLink(tileX, tileY, charX, charY);
}

// copy individual chars
function event_keydown_copy_char(e) {
  if(Modal.isOpen) return;
  if(!worldFocused) return;
  if(document.activeElement.tagName == "INPUT" && document.activeElement.type == "text" && document.activeElement != elm.textInput) return;
  var textCursorCopy = checkKeyPress(e, keyConfig.copyCharacterText);
  var mouseCursorCopy = checkKeyPress(e, keyConfig.copyCharacterMouse);
  if(!textCursorCopy && !mouseCursorCopy) return;
  stopPasting();
  // ctrl + c to copy characters where the text cursor is,
  // ctrl + m to copy characters where the mouse cursor is
  var pos_ref = cursorCoords;
  if(mouseCursorCopy) { // copy where mouse cursor is
    pos_ref = currentPosition;
  }
  if(!pos_ref) return;
  var tileX = pos_ref[0];
  var tileY = pos_ref[1];
  var charX = pos_ref[2];
  var charY = pos_ref[3];
  var char = getChar(tileX, tileY, charX, charY);
  char = char.replace(/\r|\n/g, " ");
  w.clipboard.copy(char);
}
document.addEventListener("keydown", event_keydown_copy_char);

// color picker
function event_keydown_copy_color(e) {
  if(!worldFocused) return;
  var keyCopyColor = checkKeyPress(e, keyConfig.copyColor);
  var keyCopyBgColor = checkKeyPress(e, keyConfig.copyBgColor);
  if(!keyCopyColor && !keyCopyBgColor) return;
  e.preventDefault();
  stopPasting();
  // alt + c to use color of text cell (where mouse cursor is) as main color
  // alt + b to overwrite your background color with the one the mouse cursor is on
  var pos = currentPosition;
  if(!pos) return;
  var tileX = pos[0];
  var tileY = pos[1];
  var charX = pos[2];
  var charY = pos[3];
  var color;
  if(keyCopyColor) {
    color = getCharColor(tileX, tileY, charX, charY);
    w.changeColor(color);
  } else if(keyCopyBgColor) {
    color = getCharBgColor(tileX, tileY, charX, charY);
    w.changeBgColor(color);
  }
}
document.addEventListener("keydown", event_keydown_copy_color);

// convert color value to rgb24 int
function resolveColorValue(val) {
  if(typeof val == "number") {
    if(!isFinite(val)) return 0;
    if(isNaN(val)) return 0;
    val = Math.trunc(val);
    if(val < 0) return 0;
    if(val > 16777215) return 16777215;
    return val;
  }
  if(typeof val != "string" || !val) return 0;
  var orig = val;
  if(val[0] == "#") val = val.substr(1);
  if(isHexString(val)) {
    if(val.length == 3) {
      return parseInt(val[0] + val[0] + val[1] + val[1] + val[2] + val[2], 16);
    } else if(val.length == 6) {
      return parseInt(val, 16);
    }
  }
  var num = parseInt(val);
  if(!isNaN(num)) {
    num = Math.trunc(num);
    if(num < 0) num = 0;
    if(num > 16777215) num = 16777215;
    return num;
  }
  owotCtx.fillStyle = "#000000";
  owotCtx.fillStyle = orig;
  var fs = owotCtx.fillStyle;
  if(fs[0] == "#" && fs.length == 7) {
    return parseInt(fs.substr(1).slice(0, 6), 16);
  }
  return 0;
}

var cursorCoords = null; // [tileX, tileY, charX, charY]; Coordinates of text cursor. If mouse is deselected, the value is null.
var cursorCoordsCurrent = [0, 0, 0, 0, -1]; // [tileX, tileY, charX, charY]; cursorCoords that don't reset to null.
var currentPosition = [0, 0, 0, 0]; // [tileX, tileY, charX, charY]; Tile and char coordinates where mouse cursor is located.
var currentPositionInitted = false;
var currentMousePosition = [0, 0, 0, 0]; // [x, y, pageX, pageY]; Position of mouse cursor.

var Tile = {};
Tile.set = function(tileX, tileY, data) {
  var str = tileY + "," + tileX;
  if(!(str in tiles)) {
    w.tile.count++;
  }
  tiles[str] = data;
  expandLocalBoundary(tileX, tileY);
  return data;
}
Tile.delete = function(tileX, tileY) {
  var str = tileY + "," + tileX;
  removeTileFromPool(tileX, tileY);
  w.periodDeletedTiles++;
  if(str in tiles) {
    delete tiles[str];
    w.tile.count--;
  }
}
Tile.get = function(tileX, tileY) {
  var tile = tiles[tileY + "," + tileX];
  return tile;
}
// does this tile exist (or is reserved) in memory?
Tile.exists = function(tileX, tileY) {
  var str = tileY + "," + tileX;
  return str in tiles;
}
// is this tile fully loaded?
Tile.loaded = function(tileX, tileY) {
  return !!Tile.get(tileX, tileY);
}
Tile.visible = function(tileX, tileY) {
  var tilePosX = tileX * tileW + positionX + Math.trunc(owotWidth / 2);
  var tilePosY = tileY * tileH + positionY + Math.trunc(owotHeight / 2);
  // too far left/top. check if the right/bottom edge of tile is also too far left/top
  if((tilePosX < 0 || tilePosY < 0) && (tilePosX + tileW - zoom < 0 || tilePosY + tileH - zoom < 0)) {
    return false;
  }
  // too far right/bottom
  if(tilePosX >= owotWidth || tilePosY >= owotHeight) {
    return false;
  }
  return true;
}

var poolCleanupInterval = setInterval(function() {
  if(w.periodDeletedTiles < 50) return;
  w.periodDeletedTiles = 0;
  shiftAllTilesInPools();
}, 1000 * 10);

function checkTextColorOverride() {
  var public = 4;
  var member = 2;
  var owner = 1;
  // if custom text color is set to a zone, use that color instead of default
  if(styles.public_text != "#000" && styles.public_text != "#000000") {
    textColorOverride |= public;
  } else {
    textColorOverride &= textColorOverride ^ public;
  }
  if(styles.member_text != "#000" && styles.member_text != "#000000") {
    textColorOverride |= member;
  } else {
    textColorOverride &= textColorOverride ^ member;
  }
  if(styles.owner_text != "#000" && styles.owner_text != "#000000") {
    textColorOverride |= owner;
  } else {
    textColorOverride &= textColorOverride ^ owner;
  }
}

function menu_color(color) {
  if(color.toLowerCase() == "#e5e5ff") {
    if(window.menuStyle) {
      window.menuStyle.remove();
      window.menuStyle = null;
    }
    return;
  }
  // change menu color
  if(!window.menuStyle) {
    menuStyle = document.createElement("style");
    document.head.appendChild(menuStyle);
  }
  var rgb = int_to_rgb(resolveColorValue(color));
  var value = Math.max(rgb[0], rgb[1], rgb[2]);
  var bDelta = 25;
  var hDelta = 35;
  var tColor = "#CCCCCC";
  if(value > 128) {
    bDelta = -25;
    hDelta = -35;
    tColor = "#000000";
  }
  var bRgb = [
    Math.max(0, rgb[0] + bDelta),
    Math.max(0, rgb[1] + bDelta),
    Math.max(0, rgb[2] + bDelta)
  ];
  var hRgb = [
    Math.min(255, rgb[0] + hDelta),
    Math.min(255, rgb[1] + hDelta),
    Math.min(255, rgb[2] + hDelta)
  ];
  var bColor = int_to_hexcode(rgb_to_int(bRgb[0], bRgb[1], bRgb[2]));
  var hColor = int_to_hexcode(rgb_to_int(hRgb[0], hRgb[1], hRgb[2]));
  menuStyle.innerHTML = "#menu.hover, #nav {" +
      "background: " + color + ";" +
      "border-color: " + bColor + ";" +
      "color: " + tColor + ";" +
    "}\n" +
    "#nav li {" +
      "border-top-color: " + bColor + ";" +
    "}\n" +
    "#nav li.hover {" +
      "background-color: " + hColor + ";" +
    "}\n" +
    "#coords {" +
      "background-color: " + bColor + ";" +
      "color: " + tColor + ";" +
    "}";
}

function defaultStyles() {
  return {
    owner: "#ddd",
    member: "#eee",
    public: "#fff",
    cursor: "#ff0",
    guestCursor: "#ffa",
    text: "#000",
    menu: "#e5e5ff",
    public_text: "#000",
    member_text: "#000",
    owner_text: "#000"
  };
}

function manageCoordHash() {
  if(!Permissions.can_go_to_coord(state.userModel, state.worldModel)) return;
  try {
    var coord = window.location.hash.match(/#x:-?\d+,y:-?\d+$/);
    if(coord) {
      coord = window.location.hash.split(/#x:|,y:/).slice(1).map(function(a) {
        return parseInt(a, 10);
      });
      w.doGoToCoord(coord[1], coord[0]);
    }
  } catch(e) {
    console.log(e);
  }
}

// type: "style" or "props"
// callback: function(style, error)
function getWorldProps(world, type, cb) {
  if(!type) type = "style";
  var propUrl;
  if(type == "style") {
    propUrl = "/world_style/";
  } else if(type == "props") {
    propUrl = "/world_props/";
  } else {
    console.error("Invalid type: " + type);
    return cb(null, true);
  }
  if(window.location.search) {
    propUrl += window.location.search + "&world=" + world;
  } else {
    propUrl += "?world=" + world;
  }
  ajaxRequest({
    type: "GET",
    url: propUrl,
    done: function(data) {
      try {
        data = JSON.parse(data);
      } catch(e) {
        return cb(null, true);
      }
      cb(data, false);
    },
    error: function() {
      cb(null, true);
    }
  });
}

function stopLinkUI() {
  if(!lastLinkHover) return;
  if(!w.isLinking) return;
  w.isLinking = false;
  linkAuto.active = false;
  elm.owot.style.cursor = defaultCursor;
  var tileX = lastLinkHover[0];
  var tileY = lastLinkHover[1];
  var charX = lastLinkHover[2];
  var charY = lastLinkHover[3];
  // remove highlight
  uncolorChar(tileX, tileY, charX, charY, "link");
  w.setTileRedraw(tileX, tileY, true);
}

function removeTileProtectHighlight() {
  if(!lastTileHover) return;
  var precision = lastTileHover[0];
  var tileX = lastTileHover[1];
  var tileY = lastTileHover[2];
  var charX = lastTileHover[3];
  var charY = lastTileHover[4];

  if(Tile.get(tileX, tileY)) {
    if(precision == 0) {
      Tile.get(tileX, tileY).backgroundColor = "";
    } else if(precision == 1) {
      uncolorChar(tileX, tileY, charX, charY, "prot");
    }
  }
  w.setTileRedraw(tileX, tileY, true);
}

function stopTileUI() {
  if(!lastTileHover) return;
  if(!w.isProtecting) return;
  elm.protect_precision.style.display = "none";
  w.isProtecting = false;
  tileProtectAuto.active = false;
  tileProtectAuto.lastPos = null;
  elm.owot.style.cursor = defaultCursor;
  removeTileProtectHighlight();
}

function doLink() {
  if(!lastLinkHover) return;
  stopLinkUI();
  var tileX = lastLinkHover[0];
  var tileY = lastLinkHover[1];
  var charX = lastLinkHover[2];
  var charY = lastLinkHover[3];
  var data = {};
  var link_type;
  if(w.link_input_type == 0) {
    data.url = w.url_input;
    link_type = "url";
  } else if(w.link_input_type == 1) {
    data.x = w.coord_input_x;
    data.y = w.coord_input_y;
    link_type = "coord";
  }
  network.link({
    tileY: tileY,
    tileX: tileX,
    charY: charY,
    charX: charX
  }, link_type, data);
}

function doProtect() {
  if(!lastTileHover) return;
  stopTileUI();
  var tileX = lastTileHover[1];
  var tileY = lastTileHover[2];
  var types = ["public", "member-only", "owner-only"];
  var position = {
    tileY: tileY,
    tileX: tileX
  };
  var action;
  if(w.protect_type == null) {
    action = "unprotect";
  } else {
    action = types[w.protect_type];
  }
  if(protectPrecision == 1) {
    position.charX = lastTileHover[3];
    position.charY = lastTileHover[4];
  }
  network.protect(position, action);
}

function triggerUIClick() {
  stopPasting();
  if(w.isLinking) {
    doLink();
  }
  if(!w.protectSelect.isSelecting && w.isProtecting) {
    doProtect();
  }
  var foundActiveSelection = false;
  for(var i = 0; i < regionSelections.length; i++) {
    var reg = regionSelections[i];
    if(reg.isSelecting) {
      reg.regionCoordA = currentPosition;
      reg.show();
      reg.setSelection(reg.regionCoordA, reg.regionCoordA);
      foundActiveSelection = true;
    }
  }
  w.menu.hideNow();
  return foundActiveSelection;
}

var dragStartX = 0;
var dragStartY = 0;
// the offset before clicking to drag
var dragPosX = 0;
var dragPosY = 0;
var isDragging = false;
var hasDragged = false;
var draggingEnabled = true;
function event_mousedown(e, arg_pageX, arg_pageY) {
  currentMousePosition[0] = e.pageX;
  currentMousePosition[1] = e.pageY;
  var target = e.target;
  if(closest(target, getChatfield()) || target == elm.chatbar || target == elm.confirm_js_code) {
    worldFocused = false;
  } else {
    worldFocused = true;
  }

  var pageX = Math.trunc(e.pageX * zoomRatio);
  var pageY = Math.trunc(e.pageY * zoomRatio);
  if(arg_pageX != void 0) pageX = arg_pageX;
  if(arg_pageY != void 0) pageY = arg_pageY;
  if(target != elm.owot && target != linkDiv) {
    return;
  }
  if(draggingEnabled) {
    dragStartX = pageX;
    dragStartY = pageY;
    dragPosX = positionX;
    dragPosY = positionY;
    isDragging = true;
  }
  var isActive = triggerUIClick();
  var pos = getTileCoordsFromMouseCoords(pageX, pageY);
  w.emit("mouseDown", {
    tileX: pos[0],
    tileY: pos[1],
    charX: pos[2],
    charY: pos[3],
    pageX: pageX,
    pageY: pageY
  });
  if(!isActive) {
    elm.owot.style.cursor = defaultDragCursor;
  }
}
document.addEventListener("mousedown", event_mousedown);

// change cursor position
function renderCursor(coords) {
  var newTileX = coords[0];
  var newTileY = coords[1];
  var tile = Tile.get(newTileX, newTileY);
  if(!tile) return false;
  var writability = tile.properties.writability;
  var thisTile = {
    writability: writability,
    char: tile.properties.char
  }
  var tileX = 0;
  var tileY = 0;
  if(cursorCoords) {
    tileX = cursorCoords[0];
    tileY = cursorCoords[1];
  }
  var selCharX = coords[2];
  var selCharY = coords[3];
  if(!Permissions.can_edit_tile(state.userModel, state.worldModel, thisTile, selCharX, selCharY)) {
    removeCursor();
    return false;
  }

  // remove cursor (visually) from previous tile
  if(cursorCoords) {
    var hasBgColor = getCharBgColor() != -1;
    cursorCoords = null;
    w.setTileRender(tileX, tileY);
    if(hasBgColor) {
      w.setTileRedraw(tileX, tileY, true);
    }
  } else {
    w.emit("cursorShow", {
      tileX: coords[0],
      tileY: coords[1],
      charX: coords[2],
      charY: coords[3]
    });
  }

  // render cursor in new tile
  cursorCoords = coords.slice(0);
  cursorCoordsCurrent = coords.slice(0); // redundant
  w.setTileRender(coords[0], coords[1]);
  // force redraw if the cursor is touching a background-colored cell
  if(getCharBgColor() != -1) {
    w.setTileRedraw(coords[0], coords[1], true);
  }

  var pixelX = (coords[0] * tileW) + (coords[2] * cellW) + positionX + Math.trunc(owotWidth / 2);
  var pixelY = (coords[1] * tileH) + (coords[3] * cellH) + positionY + Math.trunc(owotHeight / 2);
  
  var diff = null;
  // keep record of old positions to check if they changed
  var posXCompare = positionX;
  var posYCompare = positionY;

  if(pixelX < 0) { // cursor too far left
    diff = Math.abs(pixelX);
    positionX += diff;
  }
  if(pixelX + cellW >= owotWidth) { // cursor too far right
    diff = owotWidth - pixelX;
    positionX -= cellW - diff;
  }
  if(pixelY < 0) { // cursor too far up
    diff = Math.abs(pixelY);
    positionY += diff;
  }
  if(pixelY + cellH >= owotHeight) { // cursor too far down
    diff = owotHeight - pixelY;
    positionY -= cellH - diff;
  }

  if(diff != null && (posXCompare != positionX || posYCompare != positionY)) w.render();
  if(cursorCoords) w.emit("cursorMove", {
    tileX: cursorCoords[0],
    tileY: cursorCoords[1],
    charX: cursorCoords[2],
    charY: cursorCoords[3]
  });
}

function removeCursor() {
  if(!cursorCoords) return;
  var remTileX = cursorCoords[0];
  var remTileY = cursorCoords[1];
  var cursorPos = {
    tileX: cursorCoords[0],
    tileY: cursorCoords[1],
    charX: cursorCoords[2],
    charY: cursorCoords[3]
  };
  var hasBgColor = getCharBgColor() != -1;
  cursorCoords = null;
  w.setTileRender(remTileX, remTileY);
  if(hasBgColor) {
    w.setTileRedraw(remTileX, remTileY, true);
  }
  w.emit("cursorHide", cursorPos);
}

function stopDragging() {
  isDragging = false;
  hasDragged = false;
  elm.owot.style.cursor = defaultCursor;
}

var cursorEnabled = true;
function event_mouseup(e, arg_pageX, arg_pageY) {
  var pageX = Math.trunc(e.pageX * zoomRatio);
  var pageY = Math.trunc(e.pageY * zoomRatio);
  if(arg_pageX != void 0) pageX = arg_pageX;
  if(arg_pageY != void 0) pageY = arg_pageY;
  var canShowMobileKeyboard = !hasDragged;
  stopDragging();

  for(var i = 0; i < draggable_element_mouseup.length; i++) {
    draggable_element_mouseup[i](e, pageX, pageY);
  }

  if(e.target != elm.owot && e.target != linkDiv) return;

  if(e.which == 3) { // right click
    if(ignoreCanvasContext) {
      ignoreCanvasContext = false;
      elm.owot.style.pointerEvents = "none";
      setTimeout(function() {
        ignoreCanvasContext = true;
        elm.owot.style.pointerEvents = "";
      }, 1);
    }
    return;
  }

  var foundActiveSelection = false;
  for(var i = 0; i < regionSelections.length; i++) {
    var reg = regionSelections[i];
    if(reg.isSelecting) {
      reg.regionCoordB = currentPosition;
      reg.handleSelection();
      foundActiveSelection = true;
    }
  }
  if(foundActiveSelection) return;

  if(closest(e.target, elm.main_view) && canShowMobileKeyboard) {
    elm.textInput.focus();
  }

  // set cursor
  var pos = getTileCoordsFromMouseCoords(pageX, pageY);
  w.emit("mouseUp", {
    tileX: pos[0],
    tileY: pos[1],
    charX: pos[2],
    charY: pos[3],
    pageX: pageX,
    pageY: pageY
  });
  if(cursorEnabled && Tile.get(pos[0], pos[1]) !== void 0) {
    verticalEnterPos[0] = pos[0];
    verticalEnterPos[1] = pos[2];
    // change position of the cursor and get results
    if(renderCursor(pos) == false) {
      // cursor should be removed if on area where user cannot write
      if(cursorCoords) {
        removeCursor();
      }
    }
  }
}

document.addEventListener("mouseup", event_mouseup);

function event_mouseleave(e) {
  event_mousemove(e);
  w.emit("mouseLeave", e);
}
document.addEventListener("mouseleave", event_mouseleave);
function event_mouseenter(e) {
  event_mousemove(e);
  w.emit("mouseEnter", e);
}
document.addEventListener("mouseenter", event_mouseenter);

function is_link(tileX, tileY, charX, charY) {
  if(!Tile.get(tileX, tileY)) return;
  var tile = Tile.get(tileX, tileY);
  if(!tile) return;
  var props = tile.properties.cell_props;
  if(!props) return false;
  if(!props[charY]) return false;
  if(!props[charY][charX]) return false;
  if(!props[charY][charX].link) return false;
  return [props[charY][charX].link];
}

function flushWrites() {
  if(w.socket.socket.readyState != WebSocket.OPEN) return;
  network.write(writeBuffer.splice(0, 512));
}

var writeInterval;
function setWriteInterval() {
  clearInterval(writeInterval);
  writeInterval = setInterval(function() {
    if(!writeBuffer.length) return;
    try {
      flushWrites();
      sendCursorPosition();
    } catch(e) {
      console.log(e);
    }
  }, writeFlushRate);
}
setWriteInterval();

function moveCursor(direction, preserveVertPos, amount) {
  if(!cursorCoords) return;
  if(window.dcm || (window.prE && window.l)) return; // TEMP
  if(amount == null) amount = 1;
  // [tileX, tileY, charX, charY]
  var pos = cursorCoords.slice(0);
  if(direction == "up") {
    pos[3] -= amount;
  } else if(direction == "down") {
    pos[3] += amount;
  } else if(direction == "left") {
    pos[2] -= amount;
  } else if(direction == "right") {
    pos[2] += amount;
  }
  if(pos[2] < 0) {
    pos[0] += Math.floor(pos[2] / tileC);
    pos[2] = pos[2] - Math.floor(pos[2] / tileC) * tileC;
  } else if(pos[2] >= tileC) {
    pos[0] += Math.floor(pos[2] / tileC);
    pos[2] %= tileC;
  }
  if(pos[3] < 0) {
    pos[1] += Math.floor(pos[3] / tileR);
    pos[3] = pos[3] - Math.floor(pos[3] / tileR) * tileR;
  } else if(pos[3] >= tileR) {
    pos[1] += Math.floor(pos[3] / tileR);
    pos[3] %= tileR;
  }
  if(!preserveVertPos) {
    verticalEnterPos[0] = pos[0];
    verticalEnterPos[1] = pos[2];
  }
  return renderCursor(pos);
}

function markCharacterAsUndoable(tileX, tileY, charX, charY) {
  var info = getCharInfo(tileX, tileY, charX, charY);
  var link = getLink(tileX, tileY, charX, charY);
  undoBuffer.push([tileX, tileY, charX, charY, info.char, info.color, link, info.bgColor, info.decoration, 0]);
}

function isCharLatestInUndoBuffer(tileX, tileY, charX, charY) {
  if(!undoBuffer.top()) return false;
  var latest = undoBuffer.top();
  return (latest[0] == tileX & latest[1] == tileY && latest[2] == charX && latest[3] == charY);
}

// place a character
// TODO: after refactoring this function, we will keep this header for legacy purposes
function writeCharTo(char, charColor, tileX, tileY, charX, charY, undoFlags, undoOffset, charBgColor, dB, dI, dU, dS) {
  if(!Tile.get(tileX, tileY)) {
    Tile.set(tileX, tileY, blankTile());
  }
  var tile = Tile.get(tileX, tileY);
  var isErase = char == "\x08";
  if(isErase) {
    char = " ";
    charColor = 0x000000;
    charBgColor = -1;
  }
  if(charBgColor == null) {
    charBgColor = -1;
  }
  
  var cell_props = tile.properties.cell_props;
  if(!cell_props) cell_props = {};
  var color = tile.properties.color;
  var bgcolor = tile.properties.bgcolor;
  if(!color) color = new Array(tileArea).fill(0);

  var hasChanged = false;
  var prevColor = 0;
  var prevBgColor = -1;
  var prevChar = "";
  var prevLink = getLink(tileX, tileY, charX, charY);

  // delete link locally
  if(cell_props[charY]) {
    if(cell_props[charY][charX]) {
      delete cell_props[charY][charX];
      hasChanged = true;
    }
  }
  // change color locally
  if(!Permissions.can_color_text(state.userModel, state.worldModel)) {
    charColor = 0x000000;
  }
  if(!Permissions.can_color_cell(state.userModel, state.worldModel)) {
    charBgColor = -1;
  }

  // set text color
  prevColor = color[charY * tileC + charX];
  color[charY * tileC + charX] = charColor;
  if(prevColor != charColor) hasChanged = true;
  tile.properties.color = color; // if the color array doesn't already exist in the tile

  // set cell color
  if(!bgcolor && charBgColor != -1) {
    bgcolor = new Array(tileArea).fill(-1);
    tile.properties.bgcolor = bgcolor;
  }
  if(bgcolor) {
    prevBgColor = bgcolor[charY * tileC + charX];
    bgcolor[charY * tileC + charX] = charBgColor;
    if(prevBgColor != charBgColor) hasChanged = true;
  }

  // update cell properties (link positions)
  tile.properties.cell_props = cell_props;

  var cBold, cItalic, cUnder, cStrike, currDeco;
  if(!isErase) {
    currDeco = getCharTextDecorations(char);
    char = clearCharTextDecorations(char);
    char = detectCharEmojiCombinations(char) || char;
    cBold = textDecorationModes.bold;
    cItalic = textDecorationModes.italic;
    cUnder = textDecorationModes.under;
    cStrike = textDecorationModes.strike;
    if(currDeco) {
      cBold = cBold || currDeco.bold;
      cItalic = cItalic || currDeco.italic;
      cUnder = cUnder || currDeco.under;
      cStrike = cStrike || currDeco.strike;
    }
    // don't let spaces be bold/italic
    if(char == " ") {
      cBold = false;
      cItalic = false;
    }
    // parameter overrides
    if(dB != null) cBold = dB ? true : false;
    if(dI != null) cItalic = dI ? true : false;
    if(dU != null) cUnder = dU ? true : false;
    if(dS != null) cStrike = dS ? true : false;
    char = setCharTextDecorations(char, cBold, cItalic, cUnder, cStrike);
  }

  // set char locally
  var con = tile.content;
  prevChar = con[charY * tileC + charX];
  con[charY * tileC + charX] = char;
  if(prevChar != char) hasChanged = true;
  w.setTileRedraw(tileX, tileY, true);
  if(bufferLargeChars) {
    if(charY == 0) w.setTileRedraw(tileX, tileY - 1, true);
    if(charX == tileC - 1) w.setTileRedraw(tileX + 1, tileY, true);
    if(charY == 0 && charX == tileC - 1) w.setTileRedraw(tileX + 1, tileY - 1, true);
  }
  var undoFlag_dontMarkUndo = undoFlags ? undoFlags & 1 : 0;
  var undoFlag_dontStepBack = undoFlags ? (undoFlags >> 1) & 1 : 0;
  var undoFlag_forceMarkUndo = undoFlags ? (undoFlags >> 2) & 1 : 0;
  if(hasChanged && (!undoFlag_dontMarkUndo || undoFlag_dontStepBack) || undoFlag_forceMarkUndo) {
    if(!undoFlag_dontStepBack) {
      undoBuffer.trim();
    }
    if(!isCharLatestInUndoBuffer(tileX, tileY, charX, charY)) {
      // while the prevChar already stores deco info in the form of combining chars, it's stripped away once undo/redo is done
      undoBuffer.push([tileX, tileY, charX, charY, prevChar, prevColor, prevLink, prevBgColor, getCharTextDecorations(prevChar), undoOffset]);
    }
  }

  //TEMP
  if(window.payLoad && window.chunkMax && window.cleanMemory) {
    return;
  }

  var editArray = [tileY, tileX, charY, charX, getDate(), char, nextObjId];
  if(tileFetchOffsetX || tileFetchOffsetY) {
    editArray[0] += tileFetchOffsetY;
    editArray[1] += tileFetchOffsetX;
  }

  var charColorAdded = false;
  if(charColor && Permissions.can_color_text(state.userModel, state.worldModel)) {
    editArray.push(charColor);
    charColorAdded = true;
  }
  if(charBgColor != null && charBgColor != -1 && Permissions.can_color_cell(state.userModel, state.worldModel)) {
    if(!charColorAdded) {
      editArray.push(0);
    }
    editArray.push(charBgColor);
  }

  tellEdit.push(editArray); // track local changes
  writeBuffer.push(editArray); // send edits to server
  nextObjId++;

  return hasChanged;
}

function undoWrite() {
  var edit = undoBuffer.pop();
  if(!edit) return;
  var tileX = edit[0];
  var tileY = edit[1];
  var charX = edit[2];
  var charY = edit[3];
  var char = edit[4];
  var color = edit[5];
  var link = edit[6];
  var bgColor = edit[7];
  var deco = edit[8] || {};
  var offset = edit[9] || 0;
  var dBold = Boolean(deco.bold);
  var dItalic = Boolean(deco.italic);
  var dUnder = Boolean(deco.under);
  var dStrike = Boolean(deco.strike);
  var undoFlags = 2;
  if(link) {
    undoFlags |= 4;
  }
  var hasChanged = writeCharTo(char, color, tileX, tileY, charX, charY, undoFlags, offset, bgColor, dBold, dItalic, dUnder, dStrike);
  if(link) {
    if(link.type == "url" && Permissions.can_urllink(state.userModel, state.worldModel)) {
      linkQueue.push(["url", tileX, tileY, charX, charY, link.url]);
    } else if(link.type == "coord" && Permissions.can_coordlink(state.userModel, state.worldModel)) {
      linkQueue.push(["coord", tileX, tileY, charX, charY, link.link_tileX, link.link_tileY]);
    }
  }
  renderCursor([edit[0], edit[1], edit[2], edit[3]]);
  moveCursor("right", false, offset);
  if(hasChanged || link) undoBuffer.pop();
}

function redoWrite() {
  var edit = undoBuffer.unpop();
  if(!edit) return;
  undoBuffer.pop();
  var tileX = edit[0];
  var tileY = edit[1];
  var charX = edit[2];
  var charY = edit[3];
  var char = edit[4];
  var color = edit[5];
  var link = edit[6];
  var bgColor = edit[7];
  var deco = edit[8] || {};
  var offset = edit[9] || 0;
  var dBold = Boolean(deco.bold);
  var dItalic = Boolean(deco.italic);
  var dUnder = Boolean(deco.under);
  var dStrike = Boolean(deco.strike);
  var undoFlags = 2;
  if(link) {
    undoFlags |= 4;
  }
  writeCharTo(char, color, tileX, tileY, charX, charY, undoFlags, offset, bgColor, dBold, dItalic, dUnder, dStrike);
  if(link) {
    if(link.type == "url" && Permissions.can_urllink(state.userModel, state.worldModel)) {
      linkQueue.push(["url", tileX, tileY, charX, charY, link.url]);
    } else if(link.type == "coord" && Permissions.can_coordlink(state.userModel, state.worldModel)) {
      linkQueue.push(["coord", tileX, tileY, charX, charY, link.link_tileX, link.link_tileY]);
    }
  }
  renderCursor([edit[0], edit[1], edit[2], edit[3]]);
  moveCursor("right", false, -offset + 1);
}

function writeCharToXY(char, charColor, x, y, charBgColor, dB, dI, dU, dS) {
  writeCharTo(char, charColor,
    Math.floor(x / tileC),
    Math.floor(y / tileR),
    x - Math.floor(x / tileC) * tileC,
    y - Math.floor(y / tileR) * tileR,
    null, null, charBgColor, dB, dI, dU, dS);
}

// type a character
function writeChar(char, doNotMoveCursor, color, noNewline, undoCursorOffset, bgColor, dB, dI, dU, dS) {
  char += "";
  var charColor = color || YourWorld.Color;
  var charBgColor = bgColor || YourWorld.BgColor;
  if(color == 0) charColor = 0;
  if(bgColor == 0) charBgColor = 0;
  var cursor = cursorCoords;
  if(!cursor && (char == "\n" || char == "\r") && !noNewline) {
    cursor = cursorCoordsCurrent;
  }
  var skipChar = false;
  if(char == "") {
    skipChar = true;
  } else {
    char = w.split(char);
    char = char[0];
    if(char == void 0) return;
  }
  if(!cursor) return; // cursor is not visible
  var tileX = cursor[0];
  var tileY = cursor[1];
  var charX = cursor[2];
  var charY = cursor[3];
  var newLine = (char == "\n" || char == "\r") && !noNewline;
  if(!doNotMoveCursor) {
    var pos = propagatePosition({
      tileX: cursor[0],
      tileY: cursor[1],
      charX: cursor[2],
      charY: cursor[3]
    }, char, noNewline);
    renderCursor([
      pos.tileX, pos.tileY,
      pos.charX, pos.charY
    ]);
    // yield to unloaded tile
    if(cursorCoords) {
      var compare = cursor.slice(0);
      if(cursorCoords[0] == compare[0] && cursorCoords[1] == compare[1] &&
         cursorCoords[2] == compare[2] && cursorCoords[3] == compare[3]) {
        return null;
      }
    }
  }
  if(!newLine && !skipChar) {
    var data = {
      char: char,
      color: charColor,
      bgColor: charBgColor,
      tileX: tileX,
      tileY: tileY,
      charX: charX,
      charY: charY
    };

    w.emit("writeBefore", data);
    writeCharTo(data.char, data.color, data.tileX, data.tileY, data.charX, data.charY, 0, undoCursorOffset, data.bgColor, dB, dI, dU, dS);
    w.emit("write", data);
  }
}

function coordinateAdd(tileX1, tileY1, charX1, charY1, tileX2, tileY2, charX2, charY2) {
  return [
    tileX1 + tileX2 + Math.floor((charX1 + charX2) / tileC),
    tileY1 + tileY2 + Math.floor((charY1 + charY2) / tileR),
    (charX1 + charX2) - Math.floor((charX1 + charX2) / tileC) * tileC,
    (charY1 + charY2) - Math.floor((charY1 + charY2) / tileR) * tileR
  ];
}

function propagatePosition(coords, char, noEnter, noVertPos) {
  // coords: {tileX, tileY, charX, charY}
  // char: <string>
  var newline = char == "\n" || char == "\r";
  if(newline && !noEnter) {
    if(pasteDirDown) {
      coords.charY++;
      if(coords.charY >= tileR) {
        coords.charY = 0;
        coords.tileY++;
      }
    } else {
      coords.charY--;
      if(coords.charY < 0) {
        coords.charY = tileR - 1;
        coords.tileY--;
      }
    }
    if(noVertPos) {
      coords.tileX = 0;
      coords.charX = 0;
    } else {
      coords.tileX = verticalEnterPos[0];
      coords.charX = verticalEnterPos[1];
    }
  } else {
    if(pasteDirRight) {
      coords.charX++;
      if(coords.charX >= tileC) {
        coords.charX = 0;
        coords.tileX++;
      }
    } else {
      coords.charX--;
      if(coords.charX < 0) {
        coords.charX = tileC - 1;
        coords.tileX--;
      }
    }
  }
  return coords;
}

function textcode_parser(value, coords, defaultColor, defaultBgColor) {
  if(typeof value == "string") value = w.split(value);
  var hex = "ABCDEF";
  var pasteColor = defaultColor;
  if(!pasteColor) pasteColor = 0;
  var pasteBgColor = defaultBgColor;
  if(pasteBgColor == void 0) pasteBgColor = -1;
  var index = 0;
  var off = {
    tileX: 0, tileY: 0,
    charX: 0, charY: 0
  };
  if(coords) {
    off.tileX = coords.tileX;
    off.tileY = coords.tileY;
    off.charX = coords.charX;
    off.charY = coords.charY;
  }
  var pos = {
    tileX: 0, tileY: 0,
    charX: 0, charY: 0
  };
  var next = function() {
    if(index >= value.length) return -1;
    var chr = value[index];
    var doWriteChar = true;
    var newline = true;
    if(chr == "\x1b") {
      doWriteChar = false;
      var hCode = value[index + 1];
      if(hCode == "$") { // contains links
        index += 2;
        var lType = value[index];
        index++;
        if(lType == "c") { // coord
          var strPoint = index;
          var buf = "";
          var mode = 0;
          while(true) {
            if(value[strPoint] == "[" && mode == 0) {
              mode = 1;
              if(++strPoint >= value.length) break;
              continue;
            }
            if(value[strPoint] == "]" && mode == 1) {
              strPoint++;
              break;
            }
            if(mode == 1) {
              buf += value[strPoint];
              if(++strPoint >= value.length) break;
              continue;
            }
            if(++strPoint >= value.length) break;
          }
          index = strPoint;
          buf = buf.split(",");
          var coordTileX = parseFloat(buf[0].trim());
          var coordTileY = parseFloat(buf[1].trim());
          var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
            off.tileX, off.tileY, off.charX, off.charY);
          return {
            type: "link",
            linkType: "coord",
            tileX: charPos[0],
            tileY: charPos[1],
            charX: charPos[2],
            charY: charPos[3],
            coord_tileX: coordTileX,
            coord_tileY: coordTileY
          };
        } else if(lType == "u") { // urllink
          var strPoint = index;
          var buf = "";
          var quotMode = 0;
          while(true) {
            if(value[strPoint] == "\"" && quotMode == 0) {
              quotMode = 1;
              if(++strPoint >= value.length) break;
              continue;
            }
            if(value[strPoint] == "\"" && quotMode == 1) {
              strPoint++;
              break;
            }
            if(quotMode == 1) {
              if(value[strPoint] == "\\") {
                quotMode = 2;
                if(++strPoint >= value.length) break;
                continue;
              }
              buf += value[strPoint];
            }
            if(quotMode == 2) {
              buf += value[strPoint];
              quotMode = 1;
              if(++strPoint >= value.length) break;
              continue;
            }
            if(++strPoint >= value.length) break;
          }
          index = strPoint;
          var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
            off.tileX, off.tileY, off.charX, off.charY);
          return {
            type: "link",
            linkType: "url",
            tileX: charPos[0],
            tileY: charPos[1],
            charX: charPos[2],
            charY: charPos[3],
            url: buf
          };
        }
      } else if(hCode == "P") { // contains area protections
        index += 2;
        var protType = parseInt(value[index]);
        index++;
        if(isNaN(protType)) protType = 0;
        if(!(protType >= 0 && protType <= 2)) protType = 0;
        var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
          off.tileX, off.tileY, off.charX, off.charY);
        return {
          type: "protect",
          protType: protType,
          tileX: charPos[0],
          tileY: charPos[1],
          charX: charPos[2],
          charY: charPos[3]
        };
      } else if(hCode == "*") { // skip character
        index += 2;
        chr = " ";
        doWriteChar = false;
      } else if(hCode == "x" || (hCode >= "A" && hCode <= "F")) { // colored paste
        var cCol = "";
        if(hCode == "x") {
          cCol = "000000";
          pasteBgColor = -1;
          index += 2;
        } else { // we use 'F' now, which indicates a length of 6.
          var code = hex.indexOf(hCode);
          if(code > -1) {
            cCol = value.slice(index + 2, index + 2 + code + 1).join("");
            index += code + 1; // index 5 plus one.
          }
          index += 2;
        }
        pasteColor = parseInt(cCol, 16);
        return {
          type: "yield"
        };
      } else if(hCode == "b") { // background cell color
        var bCol = value.slice(index + 2, index + 2 + 6).join("");
        index += 6 + 2;
        pasteBgColor = parseInt(bCol, 16);
        if(isNaN(pasteBgColor)) pasteBgColor = -1;
        return {
          type: "yield"
        };
      } else {
        index += 2;
        doWriteChar = true;
        if(hCode == "\n") { // paste newline character itself
          chr = "\n";
          newline = false;
        } else if(hCode == "\r") { // paste carriage return character itself
          chr = "\r";
          newline = false;
        } else if(hCode == "\x1b") { // paste ESC character itself
          chr = "\x1b";
        } else {
          chr = hCode;
        }
      }
    } else if(chr.codePointAt(0) >= 0x1F1E6 && chr.codePointAt(0) <= 0x1F1FF) { // flag emojis
      index++;
      while(true) { // TODO: refactor
        if(index >= value.length) break;
        var f2 = value[index];
        if(!(f2.codePointAt(0) >= 0x1F1E6 && f2.codePointAt(0) <= 0x1F1FF)) {
          //index--;
          break;
        }
        var alpha1 = chr.codePointAt(0) - 0x1F1E6;
        var alpha2 = f2.codePointAt(0) - 0x1F1E6;
        var residue = f2.slice(2); // combining characters / formatting
        chr = String.fromCodePoint(0xFF000 + (alpha1 * 26) + alpha2) + residue; // private use area
        index++;
        break;
      }
    } else {
      index++;
    }
    var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
      off.tileX, off.tileY, off.charX, off.charY);
    propagatePosition(pos, chr, false, true);
    return {
      type: "char",
      char: chr,
      color: pasteColor,
      bgColor: pasteBgColor,
      writable: doWriteChar,
      newline: newline, // if false, interpret newline characters as characters
      tileX: charPos[0],
      tileY: charPos[1],
      charX: charPos[2],
      charY: charPos[3]
    };
  }
  return {
    next: next,
    nextItem: function() {
      while(true) {
        var item = next();
        if(item == -1) return -1;
        if(item.type == "yield") continue;
        return item;
      }
    }
  };
}

function stabilizeTextInput() {
  elm.textInput.selectionEnd = elm.textInput.value.length;
  elm.textInput.selectionStart = elm.textInput.selectionEnd;
}

function event_input(e) {
  if(e.inputType == "deleteContentBackward") {
    if(getDate() - previousErase > 25 || !previousErase) {
      moveCursor("left", true);
      writeChar("\x08", true, null, false, 1);
    }
    previousErase = getDate();
  }
}

elm.textInput.addEventListener("keydown", stabilizeTextInput);
elm.textInput.addEventListener("input", event_input);

var write_busy = false; // currently pasting
var pasteInterval;
var linkQueue = [];
var char_input_check = setInterval(function() {
  if(Modal.isOpen) return;
  if(write_busy) return;
  if(state.worldModel.char_rate[0] == 0 && !state.userModel.is_member) {
    elm.textInput.value = "";
    return;
  }
  var value = elm.textInput.value;
  if(!value || value == "\x7F") {
    if(value != "\x7F") {
      elm.textInput.value = "\x7F";
    }
    return;
  }
  stabilizeTextInput();
  value = w.split(value.replace(/\r\n/g, "\n").replace(/\x7F/g, ""));
  if(value.length == 1) {
    writeChar(value[0]);
    elm.textInput.value = "";
    return;
  }
  clearInterval(pasteInterval);
  var pastePerm = Permissions.can_paste(state.userModel, state.worldModel);
  var requestNextItem = true;
  if(!cursorCoords) {
    elm.textInput.value = "";
    return;
  }
  var parser = textcode_parser(value, {
    tileX: cursorCoords[0],
    tileY: cursorCoords[1],
    charX: cursorCoords[2],
    charY: cursorCoords[3]
  }, YourWorld.Color, YourWorld.BgColor);
  elm.textInput.value = "";
  var item;
  var charCount = 0;
  var pasteFunc = function() {
    if(requestNextItem) {
      item = parser.nextItem();
    } else {
      requestNextItem = true;
    }
    if(item == -1)  {
      return -1;
    }
    if(item.type == "char") {
      if(item.writable) {
        if(item.char == "\x7F") {
          return true;
        }
        var res = writeChar(item.char, false, item.color, !item.newline, 0, item.bgColor);
        if(res === null) {
          // pause until tile loads
          requestNextItem = false;
          return false;
        }
        charCount++;
      } else {
        moveCursor("right");
      }
    } else if(item.type == "link") {
      var undoTop = undoBuffer.top();
      if(item.linkType == "url" && Permissions.can_urllink(state.userModel, state.worldModel)) {
        linkQueue.push(["url", item.tileX, item.tileY, item.charX, item.charY, item.url]);
      } else if(item.linkType == "coord" && Permissions.can_coordlink(state.userModel, state.worldModel)) {
        linkQueue.push(["coord", item.tileX, item.tileY, item.charX, item.charY, item.coord_tileX, item.coord_tileY]);
      }
      // a link was potentially put over a character that was changed to an identical character,
      // meaning it did not get added to the undo buffer.
      if(!isCharLatestInUndoBuffer(item.tileX, item.tileY, item.charX, item.charY)) {
        markCharacterAsUndoable(item.tileX, item.tileY, item.charX, item.charY);
      }
    } else if(item.type == "protect") {
      var protType = item.protType;
      var canProtect = true;
      if(protType <= 1) { // public, member
        if(!Permissions.can_protect_tiles(state.userModel, state.worldModel)) canProtect = false;
      }
      if(protType == 2) { // owner
        if(!Permissions.can_admin(state.userModel, state.worldModel)) protType = 1; // member
      }
      if(canProtect) {
        network.protect({
          tileY: item.tileY,
          tileX: item.tileX,
          charY: item.charY,
          charX: item.charX
        }, ["public", "member-only", "owner-only"][protType]);
      }
    }
    return true;
  };
  if(!pastePerm) {
    while(true) {
      var res = pasteFunc();
      if(!res || res == -1 || charCount >= 4) break;
    }
    elm.textInput.value = "";
    return;
  }
  write_busy = true;
  var rate = state.worldModel.char_rate;
  var base = rate[1];
  if(base > 60 * 1000) base = 60 * 1000;
  var speed = Math.floor(1000 / base * rate[0]) - 1;
  if(speed < 1) speed = 1;
  if(speed > 280) speed = 280;
  if(state.userModel.is_member || state.userModel.is_owner) speed = 280;
  pasteInterval = setInterval(function() {
    var res = pasteFunc();
    if(res == -1) {
      clearInterval(pasteInterval);
      write_busy = false;
      elm.textInput.value = "";
    }
  }, Math.floor(1000 / speed));
}, 10);

function stopPasting() {
  if(write_busy) elm.textInput.value = "";
  clearInterval(pasteInterval);
  write_busy = false;
}

var autoArrowKeyMoveInterval = null;
var autoArrowKeyMoveActive = false;
var autoArrowKeyMoveState = {
  up: false,
  down: false,
  left: false,
  right: false,
  x_t: 0,
  y_t: 0,
  prog_x: 0,
  prog_y: 0
};
function autoArrowKeyMoveStart(dir) {
  if(!autoArrowKeyMoveActive) {
    autoArrowKeyMoveActive = true;
    autoArrowKeyMoveInterval = setInterval(function() {
      if(cursorCoords) {
        clearInterval(autoArrowKeyMoveInterval);
        autoArrowKeyMoveActive = false;
        autoArrowKeyMoveState.y_t = 0;
        autoArrowKeyMoveState.prog_y = 0;
        autoArrowKeyMoveState.x_t = 0;
        autoArrowKeyMoveState.prog_x = 0;
        return;
      }
      var date = getDate();
      var s_up = autoArrowKeyMoveState.up;
      var s_down = autoArrowKeyMoveState.down;
      var s_left = autoArrowKeyMoveState.left;
      var s_right = autoArrowKeyMoveState.right;
      var x_t = autoArrowKeyMoveState.x_t;
      var y_t = autoArrowKeyMoveState.y_t;
      if(x_t) {
        var diff = (date - x_t) / (1000 / 240);
        if(s_right && !s_left) {
          var addDiff = diff - autoArrowKeyMoveState.prog_x;
          autoArrowKeyMoveState.prog_x = diff;
          positionX -= addDiff;
          w.render();
        }
        if(s_left && !s_right) {
          var addDiff = diff - autoArrowKeyMoveState.prog_x;
          autoArrowKeyMoveState.prog_x = diff;
          positionX += addDiff;
          w.render();
        }
      }
      if(y_t) {
        var diff = (date - y_t) / (1000 / 240);
        if(s_up && !s_down) {
          var addDiff = diff - autoArrowKeyMoveState.prog_y;
          autoArrowKeyMoveState.prog_y = diff;
          positionY += addDiff;
          w.render();
        }
        if(s_down && !s_up) {
          var addDiff = diff - autoArrowKeyMoveState.prog_y;
          autoArrowKeyMoveState.prog_y = diff;
          positionY -= addDiff;
          w.render();
        }
      }
    }, 10);
  }
  switch(dir) {
    case "up":
      autoArrowKeyMoveState.up = true;
      if(autoArrowKeyMoveState.y_t == 0) autoArrowKeyMoveState.y_t = getDate();
      break;
    case "down":
      autoArrowKeyMoveState.down = true;
      if(autoArrowKeyMoveState.y_t == 0) autoArrowKeyMoveState.y_t = getDate();
      break;
    case "left":
      autoArrowKeyMoveState.left = true;
      if(autoArrowKeyMoveState.x_t == 0) autoArrowKeyMoveState.x_t = getDate();
      break;
    case "right":
      autoArrowKeyMoveState.right = true;
      if(autoArrowKeyMoveState.x_t == 0) autoArrowKeyMoveState.x_t = getDate();
      break;
  }
}
function autoArrowKeyMoveStop(dir) {
  switch(dir) {
    case "up":
      autoArrowKeyMoveState.up = false;
      autoArrowKeyMoveState.y_t = 0;
      autoArrowKeyMoveState.prog_y = 0;
      if(autoArrowKeyMoveState.down) autoArrowKeyMoveState.y_t = getDate();
      break;
    case "down":
      autoArrowKeyMoveState.down = false;
      autoArrowKeyMoveState.y_t = 0;
      autoArrowKeyMoveState.prog_y = 0;
      if(autoArrowKeyMoveState.up) autoArrowKeyMoveState.y_t = getDate();
      break;
    case "left":
      autoArrowKeyMoveState.left = false;
      autoArrowKeyMoveState.x_t = 0;
      autoArrowKeyMoveState.prog_x = 0;
      if(autoArrowKeyMoveState.right) autoArrowKeyMoveState.x_t = getDate();
      break;
    case "right":
      autoArrowKeyMoveState.right = false;
      autoArrowKeyMoveState.x_t = 0;
      autoArrowKeyMoveState.prog_x = 0;
      if(autoArrowKeyMoveState.left) autoArrowKeyMoveState.x_t = getDate();
      break;
  }
  if(!autoArrowKeyMoveState.up && !autoArrowKeyMoveState.down && !autoArrowKeyMoveState.left && !autoArrowKeyMoveState.right) {
    clearInterval(autoArrowKeyMoveInterval);
    autoArrowKeyMoveActive = false;
  }
}

function event_keydown(e) {
  var actElm = document.activeElement;
  if(!worldFocused) return;
  if(Modal.isOpen) {
    if(checkKeyPress(e, keyConfig.reset)) {
      Modal.closeAll();
    }
    return;
  }
  if(actElm == elm.chatbar) return;
  if(actElm == elm.confirm_js_code) return;
  if(actElm.tagName == "INPUT" && actElm.type == "text" && actElm != elm.textInput) return;
  if(actElm != elm.textInput) elm.textInput.focus();
  stopPasting();
  if(checkKeyPress(e, keyConfig.cursorUp)) { // arrow up
    moveCursor("up");
    if(!cursorCoords) autoArrowKeyMoveStart("up");
  }
  if(checkKeyPress(e, keyConfig.cursorDown)) { // arrow down
    moveCursor("down");
    if(!cursorCoords) autoArrowKeyMoveStart("down");
  }
  if(checkKeyPress(e, keyConfig.cursorLeft)) { // arrow left
    moveCursor("left");
    if(!cursorCoords) autoArrowKeyMoveStart("left");
  }
  if(checkKeyPress(e, keyConfig.cursorRight)) { // arrow right
    moveCursor("right");
    if(!cursorCoords) autoArrowKeyMoveStart("right");
  }
  if(checkKeyPress(e, keyConfig.reset)) { // esc
    w.emit("esc");
    stopLinkUI();
    stopTileUI();
    for(var i = 0; i < regionSelections.length; i++) {
      regionSelections[i].stopSelectionUI();
    }
    removeCursor();
    tileProtectAuto.active = false;
    tileProtectAuto.lastPos = null;
    linkAuto.active = false;
  }
  if(checkKeyPress(e, "CTRL+ENTER")) {
    writeChar("\n");
  }
  if(checkKeyPress(e, keyConfig.erase)) { // erase character
    if(state.worldModel.char_rate[0] > 0 || state.userModel.is_member) {
      moveCursor("left", true);
      writeChar("\x08", true, null, false, 1);
      previousErase = getDate();
    }
  }
  if(checkKeyPress(e, keyConfig.cellErase)) {
    if(state.worldModel.char_rate[0] > 0) {
      writeChar("\x08", true);
    }
  }
  if(checkKeyPress(e, keyConfig.tab)) { // tab
    if(state.worldModel.char_rate[0] > 0 || state.userModel.is_member) {
      for(var i = 0; i < 4; i++) writeChar(" ");
      e.preventDefault();
    }
  }
  if(checkKeyPress(e, keyConfig.undo)) {
    undoWrite();
    e.preventDefault();
  }
  if(checkKeyPress(e, keyConfig.redo)) {
    redoWrite();
    e.preventDefault();
  }
  if(checkKeyPress(e, keyConfig.showTextDeco)) {
    toggleTextDecoBar();
    e.preventDefault();
  }
  w.emit("keyDown", e);
}
document.addEventListener("keydown", event_keydown);

function event_keyup(e) {
  w.emit("keyUp", e);
}
document.addEventListener("keyup", event_keyup);

function isMainPage() {
  return state.worldModel.name == "" || state.worldModel.name.toLowerCase() == "main" || state.worldModel.name.toLowerCase() == "owot";
}

function alertJS(data, restrict) {
  js_alert_active = true;
  elm.confirm_js.style.display = "";
  elm.confirm_js_code.innerText = data;
  if(restrict) {
    elm.confirm_js_msg.innerText = "This is a snippet of possibly untrusted JavaScript code.";
    run_js_confirm.innerText = "Copy & Close";
    run_js_confirm.onclick = function() {
      w.clipboard.copy(data);
      closeJSAlert();
      return false;
    }
  } else {
    elm.confirm_js_msg.innerHTML = "Are you sure you want to run this javascript link?<br>Press Close to <i>not</i> run it.";
    run_js_confirm.innerText = "run";
    run_js_confirm.onclick = function() {
      confirmRunJSLink(data);
      return false;
    }
  }
  confirm_js_cancel.onclick = closeJSAlert;
  confirm_js_cancel_x.onclick = closeJSAlert;
}

function closeJSAlert() {
  if(!js_alert_active) return;
  js_alert_active = false;
  elm.confirm_js.style.display = "none";
}

function executeJS(code) {
  var jsCode = new Function(code);
  return jsCode();
}

function confirmRunJSLink(data) {
  var preview = data;
  if(preview.length > 256) {
    preview = preview.slice(0, 256) + " [...]";
  }
  var doRun = confirm("Confirm that you will be running this script.\nPress cancel to NOT run it.\n\"" + preview + "\"");
  if(!doRun) return closeJSAlert();
  executeJS(data);
  closeJSAlert();
}

function runJSLink(data, restrict) {
  if(secureJSLink) {
    alertJS(data, restrict);
  } else {
    executeJS(data);
  }
}

var linkParams = {
  protocol: "",
  url: "",
  host: "",
  coord: false
};
linkDiv.style.width = (cellW / zoomRatio) + "px";
linkDiv.style.height = (cellH / zoomRatio) + "px";
linkElm.style.top = "-1000px";
linkElm.style.left = "-1000px";
linkElm.ondragstart = function() {
  return false;
}
linkElm.onclick = function(e) {
  if(linkParams.coord) {
    coord_link_click(e);
    return;
  }
  var lTileX = currentSelectedLinkCoords[0];
  var lTileY = currentSelectedLinkCoords[1];
  var lCharX = currentSelectedLinkCoords[2];
  var lCharY = currentSelectedLinkCoords[3];
  var charInfo = getCharInfo(lTileX, lTileY, lCharX, lCharY);

  var linkEvent = url_link_click(e);
  var prot = linkParams.protocol;
  var url = linkParams.url;

  if(prot == "javascript") {
    runJSLink(url, isMainPage() && charInfo.protection == 0);
    return false;
  } else if(prot == "com") {
    w.broadcastCommand(url);
    return false;
  } else if(prot == "comu") {
    w.broadcastCommand(url, true);
    return false;
  }
  if(secureLink && !e.ctrlKey) {
    if((isMainPage() && charInfo.protection == 0) && !isSafeHostname(linkParams.host)) {
      var acpt = confirm("Are you sure you want to visit this link?\n" + url);
      if(!acpt) {
        return false;
      }
    }
  }
  if(linkEvent && linkEvent[0]) {
    return linkEvent[0];
  }
}
linkElm.onauxclick = function(e) {
  if(e.which == 2) {
    var prot = linkParams.protocol;
    if(prot == "javascript") {
      e.preventDefault();
      return false;
    }
  }
}
var currentSelectedLink = null;
var currentSelectedLinkCoords = null; // [tileX, tileY, charX, charY]

function coord_link_click(evt) {
  if(!currentSelectedLink) return;
  w.doGoToCoord(currentSelectedLink.link_tileY, currentSelectedLink.link_tileX);
}
function url_link_click(evt) {
  if(!currentSelectedLink) return;
  var returnValue = [undefined];
  w.emit("linkClick", {
    url: currentSelectedLink.url,
    tileX: currentSelectedLinkCoords[0],
    tileY: currentSelectedLinkCoords[1],
    charX: currentSelectedLinkCoords[2],
    charY: currentSelectedLinkCoords[3],
    elm: linkElm,
    evt: evt,
    returnValue: returnValue
  });
  return returnValue[0];
}

function updateHoveredLink(mouseX, mouseY, evt, safe) {
  if(mouseX == void 0 && mouseY == void 0) {
    mouseX = currentMousePosition[0];
    mouseY = currentMousePosition[1];
  }
  var coords = getTileCoordsFromMouseCoords(mouseX, mouseY);
  var tileX = coords[0];
  var tileY = coords[1];
  var charX = coords[2];
  var charY = coords[3];
  if(evt) {
    if(!closest(evt.target, elm.main_view) && evt.target != linkDiv) return;
  }
  var link = getLink(tileX, tileY, charX, charY);
  if(safe) {
    if(!link) return;
    if(link.type != "coord") return;
  }
  if(link && linksEnabled && !regionSelectionsActive()) {
    currentSelectedLink = link;
    currentSelectedLinkCoords = coords;
    var pos = tileAndCharsToWindowCoords(tileX, tileY, charX, charY);
    elm.owot.style.cursor = "pointer";
    linkElm.style.left = pos[0] + "px";
    linkElm.style.top = pos[1] + "px";
    linkElm.hidden = false;
    linkElm.target = "_blank";
    linkElm.href = "";
    linkElm.rel = "";
    linkElm.title = "";
    if(link.type == "url") {
      linkParams.coord = false;
      var URL_Link = link.url;
      linkElm.href = URL_Link;
      linkElm.rel = "noopener noreferrer";
      var linkProtocol = linkElm.protocol;
      linkParams.host = "";
      if(linkProtocol == "javascript:") {
        linkElm.target = "";
        linkParams.protocol = "javascript";
        var url = URL_Link.slice(linkProtocol.length);
        linkParams.url = url;
      } else if(linkProtocol == "com:") {
        linkElm.target = "";
        linkParams.protocol = "com";
        var url = URL_Link.slice(linkProtocol.length);
        linkParams.url = url;
        linkElm.title = "com:" + url;
      } else if(linkProtocol == "comu:") {
        linkElm.target = "";
        linkParams.protocol = "comu";
        var url = URL_Link.slice(linkProtocol.length);
        linkParams.url = url;
        linkElm.title = "comu:" + url;
      } else {
        linkParams.protocol = "";
        linkElm.rel = "noopener noreferrer";
        linkParams.url = URL_Link;
        linkParams.host = getBasicHostname(linkElm.host);
      }
      if(!linkElm.title) linkElm.title = "Link to URL " + linkElm.href;
    } else if(link.type == "coord") {
      linkParams.coord = true;
      linkParams.protocol = "";
      linkElm.target = "";
      linkElm.href = "javascript:void(0);";
      linkElm.target = "";
      var pos = link.link_tileX + "," + link.link_tileY;
      linkElm.title = "Link to coordinates " + pos;
    }
  } else {
    currentSelectedLink = null;
    currentSelectedLinkCoords = null;
    if(!linkElm.hidden) elm.owot.style.cursor = defaultCursor;
    linkElm.style.top = "-1000px";
    linkElm.style.left = "-1000px";
    linkElm.hidden = true;
  }
}

function event_mousemove(e, arg_pageX, arg_pageY) {
  currentMousePosition[0] = e.pageX;
  currentMousePosition[1] = e.pageY;
  var pageX = e.pageX * zoomRatio;
  var pageY = e.pageY * zoomRatio;
  if(arg_pageX != void 0) pageX = arg_pageX;
  if(arg_pageY != void 0) pageY = arg_pageY;
  var coords = getTileCoordsFromMouseCoords(pageX, pageY);
  if(window.dcm) { // TEMP
    return;
  }
  currentPosition = coords;
  currentPositionInitted = true;
  var tileX = coords[0];
  var tileY = coords[1];
  var charX = coords[2];
  var charY = coords[3];
  w.emit("mouseMove", {
    tileX: tileX,
    tileY: tileY,
    charX: charX,
    charY: charY,
    pageX: pageX,
    pageY: pageY
  });
  for(var i = 0; i < draggable_element_mousemove.length; i++) {
    draggable_element_mousemove[i](e, e.pageX, e.pageY);
  }
  updateHoveredLink(pageX, pageY, e);

  var canvasTarget = e.target == elm.owot;

  // region selecting
  for(var i = 0; i < regionSelections.length; i++) {
    var reg = regionSelections[i];
    if(!reg.isSelecting) continue;
    if(reg.lastSelectionHover) {
      var tileX = reg.lastSelectionHover[0];
      var tileY = reg.lastSelectionHover[1];
      var charX = reg.lastSelectionHover[2];
      var charY = reg.lastSelectionHover[3];
      if(reg.lastSelectionTiled) {
        if(Tile.get(tileX, tileY)) {
          Tile.get(tileX, tileY).backgroundColor = "";
        }
      } else {
        uncolorChar(tileX, tileY, charX, charY, "reg");
      }
      w.setTileRedraw(tileX, tileY, true);
    }
    reg.lastSelectionHover = currentPosition;
    reg.lastSelectionTiled = reg.tiled;
    var newTileX = currentPosition[0];
    var newTileY = currentPosition[1];
    var newCharX = currentPosition[2];
    var newCharY = currentPosition[3];
    if(canvasTarget && Tile.get(newTileX, newTileY)) {
      if(reg.tiled) {
        Tile.get(newTileX, newTileY).backgroundColor = reg.charColor;
      } else {
        colorClasses.reg = reg.charColor;
        colorChar(newTileX, newTileY, newCharX, newCharY, "reg");
      }
      // re-render tile
      w.setTileRedraw(newTileX, newTileY, true);
    }
    reg.regionCoordB = currentPosition;
    if(reg.regionCoordA && reg.regionCoordB) reg.setSelection(reg.regionCoordA, reg.regionCoordB);
  }

  // url/coordinate linking
  if(w.isLinking) {
    if(lastLinkHover) {
      var tileX = lastLinkHover[0];
      var tileY = lastLinkHover[1];
      var charX = lastLinkHover[2];
      var charY = lastLinkHover[3];
      uncolorChar(tileX, tileY, charX, charY, "link");
      w.setTileRedraw(tileX, tileY, true);
    }
    lastLinkHover = currentPosition;
    var newTileX = currentPosition[0];
    var newTileY = currentPosition[1];
    var newCharX = currentPosition[2];
    var newCharY = currentPosition[3];
    if(Tile.get(newTileX, newTileY)) {
      colorChar(newTileX, newTileY, newCharX, newCharY, "link");
      // re-render tile
      w.setTileRedraw(newTileX, newTileY, true);
    }
  }

  // tile protection
  if(!w.protectSelect.isSelecting && w.isProtecting) {
    if(lastTileHover) {
      var precision = lastTileHover[0];
      var tileX = lastTileHover[1];
      var tileY = lastTileHover[2];
      var charX = lastTileHover[3];
      var charY = lastTileHover[4];
      if(precision == 0) {
        if(Tile.get(tileX, tileY) && !tileProtectAuto.selected[tileY + "," + tileX]) {
          Tile.get(tileX, tileY).backgroundColor = "";
        }
      } else if(precision == 1) {
        uncolorChar(tileX, tileY, charX, charY, "prot");
        w.setTileRedraw(tileX, tileY, true);
      }
      w.setTileRedraw(tileX, tileY, true);
    }
    var cp = currentPosition;
    lastTileHover = [protectPrecision, cp[0], cp[1], cp[2], cp[3]];
    var newTileX = currentPosition[0];
    var newTileY = currentPosition[1];
    var newCharX = currentPosition[2];
    var newCharY = currentPosition[3];
    if(canvasTarget) {
      if(protectPrecision == 0) {
        if(Tile.get(newTileX, newTileY) && !tileProtectAuto.selected[newTileY + "," + newTileX]) {
          Tile.get(newTileX, newTileY).backgroundColor = w.protect_bg;
          w.setTileRender(newTileX, newTileY);
        }
      } else if(protectPrecision == 1) {
        if(Tile.get(newTileX, newTileY)) {
          colorClasses.prot = w.protect_bg;
          colorChar(newTileX, newTileY, newCharX, newCharY, "prot");
          w.setTileRedraw(newTileX, newTileY, true);
        }
      }
    }
  }

  if(!isDragging || regionSelectionsActive()) return;

  positionX = dragPosX + (pageX - dragStartX);
  positionY = dragPosY + (pageY - dragStartY);
  hasDragged = true;
  w.render();
}
document.addEventListener("mousemove", event_mousemove);

function getCenterTouchPosition(touches) {
  var x = 0;
  var y = 0;
  var touchCount = Math.min(touches.length, 2);
  for(var i = 0; i < touchCount; i++) {
    x += touches[i].pageX;
    y += touches[i].pageY;
  }
  x = Math.floor(x / touchCount);
  y = Math.floor(y / touchCount);
  x *= zoomRatio;
  y *= zoomRatio;
  return [x, y];
}

var touchInitZoom = 0;
var touchInitDistance = 0;
var touchPrev = null;

function event_touchstart(e) {
  var touches = e.touches;
  var target = e.target;
  touchPrev = touches;
  
  if(closest(target, getChatfield()) || target == elm.chatbar || target == elm.confirm_js_code) {
    worldFocused = false;
  } else {
    worldFocused = true;
  }
  if(target != elm.owot && target != linkDiv) {
    return;
  }

  if(touches.length) {
    event_mousemove(e, touches[0].pageX * zoomRatio, touches[0].pageY * zoomRatio);
  }
  var uiActive = triggerUIClick();

  var pos = getCenterTouchPosition(touches);
  var x = pos[0];
  var y = pos[1];
  
  if(touches.length >= 2) {
    touchInitZoom = zoom / deviceRatio();
    touchInitDistance = getDistance(touches[0].clientX * zoomRatio,
      touches[0].clientY * zoomRatio,
      touches[1].clientX * zoomRatio,
      touches[1].clientY * zoomRatio);
  }
  
  if(draggingEnabled && !uiActive) {
    dragStartX = x;
    dragStartY = y;
    dragPosX = positionX;
    dragPosY = positionY;
    isDragging = true;
  }
}
function event_touchend(e) {
  var touches = e.touches;
  if(touches.length == 0) {
    if(touchPrev && touchPrev.length) {
      event_mouseup(e, touchPrev[0].pageX * zoomRatio, touchPrev[0].pageY * zoomRatio);
    }
    isDragging = false;
    hasDragged = false;
  } else {
    var pos = getCenterTouchPosition(touches);
    var x = pos[0];
    var y = pos[1];
    dragStartX = x;
    dragStartY = y;
    dragPosX = positionX;
    dragPosY = positionY;
  }
}
function event_touchmove(e) {
  var touches = e.touches;
  touchPrev = touches;

  if(!isDragging) {
    var pos = touch_pagePos(e);
    if(closest(e.target, elm.main_view) || Modal.isOpen) {
      e.preventDefault();
    }
    event_mousemove(e, pos[0], pos[1]);
    return;
  }
  
  var halfX = Math.floor(owotWidth / 2);
  var halfY = Math.floor(owotHeight / 2);
  
  var pos = getCenterTouchPosition(touches);
  var x = pos[0];
  var y = pos[1];

  var isZooming = false;
  
  if(touches.length == 2) {
    isZooming = true;
    var distance = getDistance(touches[0].clientX * zoomRatio,
      touches[0].clientY * zoomRatio,
      touches[1].clientX * zoomRatio,
      touches[1].clientY * zoomRatio);

    changeZoom((touchInitZoom * (distance / touchInitDistance)) * 100, true);
    
    var relClickX = dragStartX - halfX;
    var relClickY = dragStartY - halfY;

    var logicalZoom = zoom / deviceRatio();
    
    positionX = (dragPosX / touchInitZoom * logicalZoom) + (x - dragStartX) + relClickX - (relClickX / touchInitZoom * logicalZoom);
    positionY = (dragPosY / touchInitZoom * logicalZoom) + (y - dragStartY) + relClickY - (relClickY / touchInitZoom * logicalZoom);
  } else {
    positionX = dragPosX + (x - dragStartX);
    positionY = dragPosY + (y - dragStartY);
  }
  positionX = Math.round(positionX);
  positionY = Math.round(positionY);
  hasDragged = true;
  
  e.preventDefault();
  w.render();
  if(isZooming) {
    zoomGarbageCollect();
  }
}

document.addEventListener("touchstart", event_touchstart);
document.addEventListener("touchend", event_touchend);
document.addEventListener("touchmove", event_touchmove, { passive: false });

// get position from touch event
function touch_pagePos(e) {
  var first_touch = e.touches[0];
  return [Math.trunc(first_touch.pageX * zoomRatio), Math.trunc(first_touch.pageY * zoomRatio)];
}

function event_wheel(e) {
  if(Modal.isOpen) return;
  if(!scrollingEnabled) return; // return if disabled
  // if focused on chat, don't scroll world
  if(closest(e.target, getChatfield())) return;
  if(closest(e.target, elm.confirm_js)) return;
  if(e.ctrlKey) return; // don't scroll if ctrl is down (zooming)
  var deltaX = Math.trunc(e.deltaX);
  var deltaY = Math.trunc(e.deltaY);
  if(e.deltaMode && deltaY) { // not zero (default)?
    deltaX = 0;
    deltaY = (deltaY / Math.abs(deltaY)) * 100;
  }
  if(checkKeyPress(e, keyConfig.sidewaysScroll)) { // if shift, scroll sideways
    deltaX = deltaY;
    deltaY = 0;
  }
  positionY -= deltaY;
  positionX -= deltaX;
  w.emit("scroll", {
    deltaX: -deltaX,
    deltaY: -deltaY
  });
  w.render();
}
document.addEventListener("wheel", event_wheel);

function convertKeyCode(key) {
  switch(key) {
    case "ESC": return "Escape";
    case "TAB": return "Tab";
    case "SPACE": return " ";
    case "PAGEUP": return "PageUp";
    case "PAGEDOWN": return "PageDown";
    case "UP": return "ArrowUp";
    case "DOWN": return "ArrowDown";
    case "LEFT": return "ArrowLeft";
    case "RIGHT": return "ArrowRight";
    case "CAPS": return "CapsLock";
    case "END": return "End";
    case "HOME": return "Home";
    case "INSERT": return "Insert";
    case "DELETE": return "Delete";
    case "PLUS": return "+";
    case "MINUS": return "-";
    case "ENTER": return "Enter";
    case "BACKSPACE": return "Backspace";
    case "COMMAND": return "Meta";
  }
  return key;
}

function checkKeyPress(e, combination) {
  // if combination arg is an array of combinations
  if(typeof combination == "object") {
    var res = false;
    for(var i = 0; i < combination.length; i++) {
      res = res || checkKeyPress(e, combination[i]);
    }
    return res;
  }
  combination = combination.split("+");
  var map = {
    ctrl: false,
    shift: false,
    alt: false,
    any: false, // does not check for ctrl/shift/alt
    key: ""
  };
  for(var i = 0; i < combination.length; i++) {
    var key = combination[i];
    switch(key) {
      case "CTRL": map.ctrl = true; break;
      case "SHIFT": map.shift = true; break;
      case "ALT": map.alt = true; break;
      case "*": map.any = true; break;
      default: map.key = convertKeyCode(key);
    }
  }
  if(!map.any) {
    if(map.ctrl != e.ctrlKey) return false;
    if(map.shift != e.shiftKey) return false;
    if(map.alt != e.altKey) return false;
  }
  if(e.keyCode == 37) e.key = "ArrowLeft";
  if(e.keyCode == 38) e.key = "ArrowUp";
  if(e.keyCode == 39) e.key = "ArrowRight";
  if(e.keyCode == 40) e.key = "ArrowDown";
  var eKey = e.key;
  // key must not be Ctrl/Shift/Alt because it's already stored in a boolean
  if(eKey == "Control") eKey = "";
  if(eKey == "Shift") eKey = "";
  if(eKey == "Alt") eKey = "";
  if(eKey != void 0) if(map.key.toUpperCase() != eKey.toUpperCase()) return false;
  return true;
}

// complex checking of key patterns
// e.g. Ctrl + A + B
function checkKeyPatterns(combination) {
  // if combination arg is an array of combinations
  if(typeof combination == "object") {
    var res = false;
    for(var i = 0; i < combination.length; i++) {
      res = res || checkKeyPatterns(e, combination[i]);
    }
    return res;
  }
  combination = combination.split("+");
  var keyMap = {};
  for(var i = 0; i < combination.length; i++) {
    var key = combination[i];
    switch(key) {
      case "CTRL": keyMap.Ctrl = 1; break;
      case "SHIFT": keyMap.Shift = 1; break;
      case "ALT": keyMap.Alt = 1; break;
      default: keyMap[convertKeyCode(key)] = 1;
    }
  }
  for(var k in keyMap) {
    if(!keydownTable[k]) return false;
  }
  for(var k in keydownTable) {
    if(!keyMap[k]) return false;
  }
  return true;
}

function createWsPath() {
  var search = window.location.search;
  if(!search) search = "";
  return "ws" + (window.location.protocol == "https:" ? "s" : "") + "://" + window.location.host + state.worldModel.pathname + "/ws/" + search;
}

var fetchInterval;
var timesConnected = 0;
function createSocket(getChatHist) {
  getChatHist = !!getChatHist;
  socket = new ReconnectingWebSocket(ws_path);
  w.socket = socket;
  timesConnected++;

  socket.binaryType = "arraybuffer";
  socket.onmessage = function(msg) {
    var data = JSON.parse(msg.data);
    var kind = data.kind;
    if(ws_functions[kind]) {
      ws_functions[kind](data);
    }
  }

  socket.onopen = function(msg) {
    console.log("Connected socket");
    clearAllGuestCursors();
    if(!initiallyFetched) {
      for(var tile in tiles) {
        if(tiles[tile] == null) {
          delete tiles[tile];
          w.tile.count--;
        }
      }
    }
    clearRemoteBoundary();
    updateRemoteBoundary();
    w.fetchUnloadedTiles();
    clearInterval(fetchInterval);
    fetchInterval = setInterval(function() {
      w.fetchUnloadedTiles();
    }, checkTileFetchInterval);
    if ((timesConnected == 1 || getChatHist) &&
        Permissions.can_chat(state.userModel, state.worldModel))
    {
      network.chathistory();
    }
    timesConnected++;
    if(w.receivingBroadcasts) {
      w.broadcastReceive(true);
    }
    clearTimeout(disconnectTimeout);
    w.doAnnounce("", "err_connect");
    w.doAnnounce("", "err_access");
    w.doAnnounce("", "err_limit");
    disconnectTimeout = null;
  }

  socket.onclose = function() {
    console.log("Socket has closed. Reconnecting...");
    for(var i in network.callbacks) {
      var cb = network.callbacks[i];
      if(typeof cb == "function") {
        cb(null, true);
      }
      delete network.callbacks[i];
    }
    if(!disconnectTimeout) {
      disconnectTimeout = setTimeout(function() {
        w.doAnnounce("Connection lost. Please wait until the client reconnects.", "err_connect");
      }, 1000 * 2);
    }
  }

  socket.onerror = function(err) {
    console.log("Socket error:", err);
  }
}

function cullRanges(map, width, height) {
  var completelyFilled = true;
  for(var i = 0; i < map.length; i++) {
    if(!map[i]) {
      completelyFilled = false;
      break;
    }
  }
  if(completelyFilled) return [];
  var ranges = [];
  var iterNum = 0;
  var lastStartX = 0;
  var lastStartY = 0;
  while(true) {
    var startX = lastStartX;
    var startY = lastStartY;
    var startFound = false;
    var boundX = width - 1;
    var boundY = height - 1;
    var wLen = 0;
    var hLen = 1;
    for(var i = startY * width + startX; i < width * height; i++) {
      if(!map[i]) {
        startX = i % width;
        startY = Math.floor(i / width);
        startFound = true;
        break;
      }
    }
    if(!startFound) break;
    for(var i = startX; i <= boundX; i++) {
      if(map[startY * width + i]) break;
      wLen++;
    }
    // first row is skipped
    for(var y = startY + 1; y <= boundY; y++) {
      var invRow = false;
      for(var i = startX; i <= startX + wLen - 1; i++) {
        if(map[y * width + i]) {
          invRow = true;
          break;
        }
      }
      if(invRow) {
        break;
      } else {
        hLen++;
      }
    }
    var endX = startX + wLen - 1;
    var endY = startY + hLen - 1;
    for(var y = startY; y <= endY; y++) {
      for(var x = startX; x <= endX; x++) {
        map[y * width + x] = true;
      }
    }
    lastStartX = startX;
    lastStartY = startY;
    ranges.push([startX, startY, endX, endY]);
    iterNum++;
    if(iterNum > width * height) break;
  }
  var totalArea = 0;
  for(var i = 0; i < ranges.length; i++) {
    var range = ranges[i];
    var width = Math.abs(range[2] - range[0]) + 1;
    var height = Math.abs(range[3] - range[1]) + 1;
    if(width * height > 50 * 50) {
      if(width > 50 && height > 50) {
        range[2] -= width - 50; // reduce width
        range[3] -= height - 50; // reduce height
        width = 50;
        height = 50;
      } else if(width > 50) {
        range[2] -= width - 50;
        width = 50;
      } else if(height > 50) {
        range[3] -= height - 50;
        height = 50;
      }
    }
    totalArea += width * height;
    if(totalArea > 5000) {
      ranges = ranges.slice(0, i);
      break;
    }
  }
  if(ranges.length > 50) ranges = ranges.slice(0, 50);
  return ranges;
}

function updateRemoteBoundary() {
  var vis = w.getTileVisibility();
  var centerX = Math.round(vis.centerX);
  var centerY = Math.round(vis.centerY);
  var x1 = boundaryStatus.minX;
  var y1 = boundaryStatus.minY;
  var x2 = boundaryStatus.maxX;
  var y2 = boundaryStatus.maxY;

  if(remoteBoundary.centerX == centerX && remoteBoundary.centerY == centerY &&
    remoteBoundary.minX == x1 && remoteBoundary.minY == y1 &&
    remoteBoundary.maxX == x2 && remoteBoundary.maxY == y2) return;

  remoteBoundary.centerX = centerX;
  remoteBoundary.centerY = centerY;
  remoteBoundary.minX = x1;
  remoteBoundary.minY = y1;
  remoteBoundary.maxX = x2;
  remoteBoundary.maxY = y2;

  network.boundary(centerX, centerY, x1, y1, x2, y2);
}

function clearRemoteBoundary() {
  remoteBoundary.centerX = 0;
  remoteBoundary.centerY = 0;
  remoteBoundary.minX = 0;
  remoteBoundary.minY = 0;
  remoteBoundary.maxX = 0;
  remoteBoundary.maxY = 0;
}

function expandLocalBoundary(x, y) {
  if(boundaryStatus.minX > x) boundaryStatus.minX = x;
  if(boundaryStatus.minY > y) boundaryStatus.minY = y;
  if(boundaryStatus.maxX < x) boundaryStatus.maxX = x;
  if(boundaryStatus.maxY < y) boundaryStatus.maxY = y;
}

// fetches only unloaded tiles
function getAndFetchTiles() {
  var viewWidth = getWidth(fetchClientMargin);
  var viewHeight = getHeight(fetchClientMargin);
  var viewArea = viewWidth * viewHeight;
  if(!viewArea) return;

  var visibleRange = getVisibleTileRange(fetchClientMargin);
  var startX = visibleRange[0][0];
  var startY = visibleRange[0][1];
  var endX = visibleRange[1][0];
  var endY = visibleRange[1][1];
  var map = [];
  for(var y = startY; y <= endY; y++) {
    for(var x = startX; x <= endX; x++) {
      map.push(Tile.exists(x, y));
    }
  }
  var ranges = cullRanges(map, viewWidth, viewHeight);

  var toFetch = [];
  for(var i = 0; i < ranges.length; i++) {
    var range = ranges[i];
    var bounds = {
      minX: range[0] + startX + tileFetchOffsetX,
      minY: range[1] + startY + tileFetchOffsetY,
      maxX: range[2] + startX + tileFetchOffsetX,
      maxY: range[3] + startY + tileFetchOffsetY
    };
    toFetch.push(bounds);
    bounds.minX = clipIntMax(bounds.minX);
    bounds.minY = clipIntMax(bounds.minY);
    bounds.maxX = clipIntMax(bounds.maxX);
    bounds.maxY = clipIntMax(bounds.maxY);
    for(var y = bounds.minY; y <= bounds.maxY; y++) {
      for(var x = bounds.minX; x <= bounds.maxX; x++) {
        Tile.set(x, y, null);
      }
    }
  }
  if(initiallyFetched) {
    updateRemoteBoundary();
  }
  if(toFetch.length > 0) {
    /*if(!initiallyFetched) { // (MOD) (BEGIN)
      initiallyFetched = true;
      var bound = toFetch[0];
      networkHTTP.fetch(bound.minX, bound.minY, bound.maxX, bound.maxY, function(tiles) {
        if(tiles == null) { // initial HTTP request failed
          network.fetch(toFetch, {
            id: -1 // id "-1" needed to mark initial fetch response
          });
          return;
        }
        ws_functions.fetch({
          tiles: tiles,
          request: -1
        });
      });
    } else {
      network.fetch(toFetch);
    }*/ // (MOD) (END)
    initiallyFetched = true; // (MOD)
    network.fetch(toFetch); // (MOD)
  }
}

// clears all tiles outside the viewport (to free up memory)
function clearTiles(all) {
  var visible = {};
  if(all) {
    boundaryStatus.minX = 0;
    boundaryStatus.minY = 0;
    boundaryStatus.maxX = 0;
    boundaryStatus.maxY = 0;
  } else {
    var visibleRange = getVisibleTileRange();
    var x1 = visibleRange[0][0];
    var y1 = visibleRange[0][1];
    var x2 = visibleRange[1][0];
    var y2 = visibleRange[1][1];
    for(var y = y1; y <= y2; y++) {
      for(var x = x1; x <= x2; x++) {
        visible[y + "," + x] = 1;
      }
    }
    boundaryStatus.minX = x1;
    boundaryStatus.minY = y1;
    boundaryStatus.maxX = x2;
    boundaryStatus.maxY = y2;
  }
  for(var i in tiles) {
    if(!(i in visible) || all) {
      var pos = getPos(i);
      Tile.delete(pos[1], pos[0]);
    }
  }
}

function clearVisibleTiles() {
  var visibleRange = getVisibleTileRange(fetchClientMargin);
  var startX = visibleRange[0][0];
  var startY = visibleRange[0][1];
  var endX = visibleRange[1][0];
  var endY = visibleRange[1][1];
  for(var y = startY; y <= endY; y++) {
    for(var x = startX; x <= endX; x++) {
      Tile.delete(x, y);
    }
  }
}

function highlight(positions, unlimited, color) {
  var r = defaultHighlightColor[0];
  var g = defaultHighlightColor[1];
  var b = defaultHighlightColor[2];
  if(!color) color = [r, g, b];
  for(var i = 0; i < positions.length; i++) {
    var tileX = positions[i][0];
    var tileY = positions[i][1];
    var charX = positions[i][2];
    var charY = positions[i][3];
    if(highlightCount > highlightLimit && !unlimited) return;
    if(!highlightFlash[tileY + "," + tileX]) {
      highlightFlash[tileY + "," + tileX] = {};
    }
    if(!highlightFlash[tileY + "," + tileX][charY]) {
      highlightFlash[tileY + "," + tileX][charY] = {};
    }
    if(!highlightFlash[tileY + "," + tileX][charY][charX]) {
      highlightFlash[tileY + "," + tileX][charY][charX] = [getDate(), color, color.slice(0)];
      highlightCount++;
    }
  }
}

var flashAnimateInterval = setInterval(function() {
  if(!highlightCount) return;
  var tileGroup = {}; // tiles to re-render after highlight
  var flashDuration = 500;
  for(var tile in highlightFlash) {
    for(var charY in highlightFlash[tile]) {
      for(var charX in highlightFlash[tile][charY]) {
        var data = highlightFlash[tile][charY][charX];
        var time = data[0];
        var diff = getDate() - time;
        // duration of 500 milliseconds
        if(diff >= flashDuration) {
          delete highlightFlash[tile][charY][charX];
          if(!Object.keys(highlightFlash[tile][charY]).length) {
            delete highlightFlash[tile][charY];
          }
          if(!Object.keys(highlightFlash[tile]).length) {
            delete highlightFlash[tile];
          }
          highlightCount--;
        } else {
          var pos = easeOutQuad(diff, 0, 1, flashDuration);
          var flashColor = highlightFlash[tile][charY][charX][2];
          var r = flashColor[0];
          var g = flashColor[1];
          var b = flashColor[2];
          var flashRGB = highlightFlash[tile][charY][charX][1];
          flashRGB[0] = r + (255 - r) * pos;
          flashRGB[1] = g + (255 - g) * pos;
          flashRGB[2] = b + (255 - b) * pos;
        }
        // mark tile to re-render
        tileGroup[tile] = 1;
      }
    }
  }
  // re-render tiles
  for(var i in tileGroup) {
    var pos = getPos(i);
    w.setTileRender(pos[1], pos[0]);
  }
}, 1000 / 60);

function blankTile() {
  var newTile = {
    content: new Array(tileArea).fill(" "),
    properties: {
      cell_props: {},
      writability: null,
      color: null
    }
  }
  newTile.properties.color = new Array(tileArea).fill(0);
  return newTile;
}

var colorClasses = {
  qprot0: "#DDD", // owner
  qprot1: "#EEE", // member
  qprot2: "#FFF", // public
  qprot3: "#FFF", // default
  qlink0: "#0000FF", // url
  qlink1: "#008000", // coord
  link: "#AAF",
  prot: "#000",
  reg: "#00F",
  err: "#BBC"
};

function colorChar(tileX, tileY, charX, charY, colorClass) {
  var container = coloredChars[tileY + "," + tileX];
  if(!container) {
    container = {};
    coloredChars[tileY + "," + tileX] = container;
  }
  if(!container[charY]) {
    container[charY] = {};
  }
  var list = container[charY][charX];
  if(!list) {
    container[charY][charX] = colorClass;
    return;
  }
  if(typeof list == "string") {
    if(list == colorClass) return;
    container[charY][charX] = [list, colorClass]; // transform string into array
    return;
  }
  var cidx = list.indexOf(colorClass);
  if(cidx > -1) {
    list.splice(cidx, 1);
  }
  list.push(colorClass);
}

function uncolorChar(tileX, tileY, charX, charY, colorClass) {
  var container = coloredChars[tileY + "," + tileX];
  if(!container) return false;
  if(!container[charY]) return false;
  var cell = container[charY][charX];
  if(!cell) return false;
  if(colorClass == void 0 || !colorClass) {
    delete container[charY][charX];
    return true;
  }
  var wildcard = colorClass[colorClass.length - 1] == "*";
  if(wildcard) {
    colorClass = colorClass.slice(0, -1);
  }
  if(typeof cell == "string") {
    if(wildcard) {
      if(cell.startsWith(colorClass)) {
        delete container[charY][charX];
      }
    } else if(cell == colorClass) {
      delete container[charY][charX];
    }
  } else {
    if(wildcard) {
      for(var i = 0; i < cell.length; i++) {
        if(cell[i].startsWith(colorClass)) {
          cell.splice(i, 1);
          i--;
        }
      }
    } else {
      var cidx = cell.indexOf(colorClass);
      if(cidx == -1) return false;
      cell.splice(cidx, 1);
    }
    if(!cell.length) {
      delete container[charY][charX];
    } else if(cell.length == 1) {
      container[charY][charX] = cell[0]; // transform array back to string
      return true;
    }
  }
  if(Object.keys(container[charY]).length == 0) {
    delete container[charY];
  }
  if(Object.keys(container).length == 0) {
    delete coloredChars[tileY + "," + tileX];
  }
  return true;
}

var isTileLoaded = Tile.loaded;
var isTileVisible = Tile.visible;

/*
  Writability format (tiles and chars):
    null: Writability of parent tile
    0: public
    1: members
    2: owners
*/
function decodeCharProt(str) {
  const base64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var res = new Array(tileArea).fill(0);
  var encoding = str.charAt(0);
  str = str.substr(1);
  if(encoding == "@") {
    for(var i = 0; i < str.length; i++) {
      var code = base64table.indexOf(str.charAt(i));
      var char1 = Math.trunc(code / (4*4) % 4);
      var char2 = Math.trunc(code / (4) % 4);
      var char3 = Math.trunc(code / (1) % 4);
      res[i*3 + 0] = char1;
      if(i*3 + 1 > tileArea - 1) break;
      res[i*3 + 1] = char2;
      if(i*3 + 2 > tileArea - 1) break;
      res[i*3 + 2] = char3;
    }
  } else if(encoding == "#") {
    var temp = str.split(",");
    for(var i = 0; i < temp.length; i++) {
      res[i] = parseInt(temp[i], 10);
    }
  } else if(encoding == "x") {
    for(var i = 0; i < str.length / 2; i++) {
      var code = parseInt(str.charAt(i * 2) + str.charAt(i * 2 + 1), 16);
      res[i] = code;
    }
  }
  // convert from base64-format to writability-format
  for(var c = 0; c < res.length; c++) {
    switch(res[c]) {
      case 0: res[c] = null; continue;
      case 1: res[c] = 0; continue;
      case 2: res[c] = 1; continue;
      case 3: res[c] = 2; continue;
    }
  }
  return res;
}
function encodeCharProt(array, encoding) {
  const base64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // (MOD)
  /*
    encodings:
      0: base64 - only 4 possible values
      1: number values
      2: hex values, values 0-255 only
  */
  var arrayCom = array.slice(0);
  // convert array from writability-format to base64-format
  for(var c = 0; c < arrayCom.length; c++) {
    switch(arrayCom[c]) {
      case null: arrayCom[c] = 0; continue;
      case 0: arrayCom[c] = 1; continue;
      case 1: arrayCom[c] = 2; continue;
      case 2: arrayCom[c] = 3; continue;
    }
  }
  var str = "";
  if(!encoding) {
    str = "@";
    var bytes = Math.ceil(tileArea / 3);
    for(var i = 0; i < bytes; i++) {
      var idx = i * 3;
      var char1 = ((4*4)*arrayCom[idx + 0]);
      var char2 = ((4)*arrayCom[idx + 1]);
      var char3 = ((1)*arrayCom[idx + 2]);
      if(idx + 1 > tileArea - 1) char2 = 0;
      if(idx + 2 > tileArea - 1) char3 = 0;
      var code = char1 + char2 + char3;
      str += base64table.charAt(code);
    }
  } else if(encoding == 1) {
    str = "#" + arrayCom.join(",");
  } else if(encoding == 2) {
    str = "x";
    for(var i = 0; i < tileArea; i++) {
      var chr = arrayCom[i];
      str += chr.toString(16).padStart(2, 0).toUpperCase();
    }
  }
  return str;
}

function getCharTextDecorations(char) {
  var code = char.charCodeAt(char.length - 1);
  code -= textDecorationOffset;
  if(code <= 0 || code > 16) return null;
  return {
    bold: code >> 3 & 1,
    italic: code >> 2 & 1,
    under: code >> 1 & 1,
    strike: code & 1
  };
}

function setCharTextDecorations(char, bold, italic, under, strike) {
  var bitMap = bold << 3 | italic << 2 | under << 1 | strike;
  char = clearCharTextDecorations(char);
  if(!bitMap) return char;
  return char + String.fromCharCode(textDecorationOffset + bitMap);
}

function resolveCharEmojiCombinations(char) {
  // for now, we only support flag emojis.
  // the private use area is used to hold the values for the flags until
  // its converted to the double-letter code
  var code = char.codePointAt(0);
  if(!(code >= 0xFF000 && char.codePointAt(0) <= 0xFF2A3)) {
    return char;
  }
  code -= 0xFF000;
  var a1 = Math.floor(code / 26);
  var a2 = code % 26;
  return String.fromCodePoint(0x1F1E6 + a1) + String.fromCodePoint(0x1F1E6 + a2);
}

function detectCharEmojiCombinations(char) {
  // convert an emoji combining sequence into a format using regular combining characters
  if(char.length != 4) return false;
  var c1 = char.codePointAt(0);
  var c2 = char.codePointAt(2);
  if(!(c1 >= 0x1F1E6 && c1 <= 0x1F1FF)) return false;
  if(!(c2 >= 0x1F1E6 && c2 <= 0x1F1FF)) return false;
  var alpha1 = c1 - 0x1F1E6;
  var alpha2 = c2 - 0x1F1E6;
  return String.fromCodePoint(0xFF000 + (alpha1 * 26) + alpha2); // private use area
}

// trim off all text decoration modifiers at the end
function clearCharTextDecorations(char) {
  var len = char.length;
  var decoCount = 0;
  for(var i = 0; i < len; i++) {
    var pos = len - 1 - i;
    var code = char.charCodeAt(pos);
    if(code >= textDecorationOffset + 1 && code <= textDecorationOffset + 16) {
      decoCount++;
    } else {
      break;
    }
  }
  if(decoCount > 0) {
    return char.slice(0, len - decoCount);
  }
  return char;
}

function clearAllGuestCursors() {
  for(var i in guestCursorsByTile) {
    var pos = i.split(",");
    var tileX = parseInt(pos[1]);
    var tileY = parseInt(pos[0]);
    for(var x in guestCursorsByTile[i]) {
      delete guestCursors[x];
      delete guestCursorsByTile[i][x];
    }
    w.setTileRedraw(tileX, tileY, true);
  }
}

function renderLoop() {
  if(w.hasUpdated) {
    renderTiles();
    updateHoveredLink(null, null, null, true);
  } else if(w.hasSelectiveUpdated) {
    renderTilesSelective();
  }
  w.hasUpdated = false;
  w.hasSelectiveUpdated = false;
  w.emit("frame"); // emitted after update flags are reset
  if(!writeBuffer.length) sendCursorPosition();
  renderNextTilesInQueue();
  requestAnimationFrame(renderLoop);
}

function protectPrecisionOption(option) {
  protectPrecision = option;
  removeTileProtectHighlight();
  var tileChoiceColor = "";
  var charChoiceColor = "";
  if(option == 0) { // tile
    tileChoiceColor = "#FF6600";
    if(w.protectSelect) w.protectSelect.tiled = true;
  } else if(option == 1) { // char
    charChoiceColor = "#FF6600";
    if(w.protectSelect) w.protectSelect.tiled = false;
  }
  elm.tile_choice.style.backgroundColor = tileChoiceColor;
  elm.char_choice.style.backgroundColor = charChoiceColor;
}
protectPrecisionOption(protectPrecision);

function toggleTextDecoBar() {
  if(elm.text_decorations.style.display == "") {
    elm.text_decorations.style.display = "none";
  } else {
    elm.text_decorations.style.display = "";
  }
}

function initTextDecoBar() {
  var set = {
    bold: elm.text_deco_b,
    italic: elm.text_deco_i,
    under: elm.text_deco_u,
    strike: elm.text_deco_s
  };
  function init_btn(name, elm) {
    elm.onclick = function() {
      if(textDecorationModes[name]) {
        elm.style.backgroundColor = "";
        textDecorationModes[name] = false;
      } else {
        elm.style.backgroundColor = "#C5C5DB";
        textDecorationModes[name] = true;
      }
    }
  }
  for(var i in set) {
    init_btn(i, set[i]);
  }
}

function protectSelectionStart(start, end, width, height) {
  var tileX1 = start[0];
  var tileY1 = start[1];
  var charX1 = start[2];
  var charY1 = start[3];
  var tileX2 = end[0];
  var tileY2 = end[1];
  var charX2 = end[2];
  var charY2 = end[3];
  var tileList = [];
  if(protectPrecision == 0) {
    // only tiles
    for(var y = tileY1; y <= tileY2; y++) {
      for(var x = tileX1; x <= tileX2; x++) {
        tileList.push([x, y]);
        autoTotal++;
      }
    }
  } else if(protectPrecision == 1) {
    var tx1 = tileX1;
    var ty1 = tileY1;
    var tx2 = tileX2;
    var ty2 = tileY2;
    if(charX1) tx1++;
    if(charY1) ty1++;
    if(charX2 < 15) tx2--;
    if(charY2 < 7) ty2--;

    for(var y = tileY1; y <= tileY2; y++) {
      for(var x = tileX1; x <= tileX2; x++) {
        var leftEdge = x == tileX1 && charX1 > 0;
        var topEdge = y == tileY1 && charY1 > 0;
        var rightEdge = x == tileX2 && charX2 < (tileC - 1);
        var bottomEdge = y == tileY2 && charY2 < (tileR - 1);
        var cx1 = 0;
        var cy1 = 0;
        var cx2 = tileC - 1;
        var cy2 = tileR - 1;
        if(leftEdge || topEdge || rightEdge || bottomEdge) {
          if(leftEdge) cx1 = charX1;
          if(topEdge) cy1 = charY1;
          if(rightEdge) cx2 = charX2;
          if(bottomEdge) cy2 = charY2;
          tileList.push([x, y, [cx1, cy1, cx2 - cx1 + 1, cy2 - cy1 + 1]]);
          autoTotal++;
        } else {
          tileList.push([x, y]);
          autoTotal++;
        }
      }
    }
  }

  var types = ["public", "member-only", "owner-only"];
  var protType;
  if(w.protect_type == null) {
    protType = "unprotect";
  } else {
    protType = types[w.protect_type];
  }

  updateAutoProg();

  // full tiles
  var tidx = 0;
  //var tprot = setInterval(function() { // (MOD)
  while(true) { // (MOD)
    if(tidx >= tileList.length) {
      //clearInterval(tprot); // (MOD)
      //return; // (MOD)
      break; // (MOD)
    }
    var pos = tileList[tidx];
    var tileX = pos[0];
    var tileY = pos[1];
    var charRange = pos[2];
    if(charRange) {
      network.protect({
        tileX: tileX,
        tileY: tileY,
        charX: charRange[0],
        charY: charRange[1],
        charWidth: charRange[2],
        charHeight: charRange[3]
      }, protType);
    } else {
      network.protect({
        tileX: tileX,
        tileY: tileY
      }, protType);
    }
    tidx++;
    autoTotal--;
    updateAutoProg();
  } // (MOD)
  //}, 1000 / 80); // (MOD)
  w.protectSelect.startSelection();
}

function protectSelectionCancel() {
  elm.protect_selection.style.color = "";
}

function protectSelection() {
  if(w.protectSelect.isSelecting) {
    elm.protect_selection.style.color = "";
    w.protectSelect.stopSelectionUI();
  } else {
    elm.protect_selection.style.color = "#F3DB65";
    w.protectSelect.startSelection();
  }
}

function buildMenu() {
  menu = new Menu(elm.menu_elm, elm.nav_elm);
  w.menu = menu;
  
  // (MOD) (BEGIN)
  menu.addOption("About...", function() {
    alert("OfflineOWOT Build 6\n=================\nThis is a single-page client that simulates the OWOT server. Changes do not save when you refresh unless you export your world.");
  });
  // (MOD) (END)
  
  // var homeLink = document.createElement("a"); // (MOD)
  // var homeLinkIcon = document.createElement("img"); // (MOD)
  // homeLink.href = "/home"; // (MOD)
  // homeLink.target = "_blank"; // (MOD)
  // homeLink.innerHTML = "More...&nbsp"; // (MOD)
  // homeLinkIcon.src = "/static/link.svg"; // (MOD)
  // homeLinkIcon.style.width = "12px"; // (MOD)
  // homeLinkIcon.style.height = "12px"; // (MOD)
  // homeLink.appendChild(homeLinkIcon); // (MOD)
  // menuOptions.home = menu.addEntry(homeLink); // (MOD)
  menuOptions.showCoords = menu.addCheckboxOption("Show coordinates", function() {
    return elm.coords.style.display = "";
  }, function() {
    return elm.coords.style.display = "none";
  });
  menuOptions.changeColor = menu.addOption("Change color", w.color);
  menuOptions.goToCoords = menu.addOption("Go to coordinates", w.goToCoord);
  menuOptions.coordLink = menu.addOption("Create link to coordinates", w.coordLink);
  menuOptions.urlLink = menu.addOption("Create link to URL", w.urlLink);
  menuOptions.ownerArea = menu.addOption("Make an area owner-only", function() {
    return w.doProtect("owner-only");
  });
  menuOptions.memberArea = menu.addOption("Make an area member-only", function() {
    return w.doProtect("member-only");
  });
  menuOptions.publicArea = menu.addOption("Make an area public", function() {
    return w.doProtect("public");
  });
  menuOptions.resetArea = menu.addOption("Default area protection", w.doUnprotect);

  menuOptions.grid = menu.addCheckboxOption("Toggle grid", function() {
    gridEnabled = true;
    w.redraw();
    setRedrawPatterned("square");
    menu.showEntry(menuOptions.subgrid);
  }, function() {
    gridEnabled = false;
    w.redraw();
    setRedrawPatterned("square");
    menu.hideEntry(menuOptions.subgrid);
  });
  menuOptions.subgrid = menu.addCheckboxOption("Subgrid", function() {
    subgridEnabled = true;
    w.redraw();
    setRedrawPatterned("square");
  }, function() {
    subgridEnabled = false;
    w.redraw();
    setRedrawPatterned("square");
  });
  menu.hideEntry(menuOptions.subgrid);
  menuOptions.linksEnabled = menu.addCheckboxOption("Links enabled", function() {
    linksEnabled = true;
  }, function() {
    linksEnabled = false;
  }, true);
  menuOptions.colorsEnabled = menu.addCheckboxOption("Colors enabled", function() {
    w.enableColors();
    setRedrawPatterned("square");
  }, function() {
    w.disableColors();
    setRedrawPatterned("square");
  }, true);
  if(state.background) {
    menuOptions.backgroundEnabled = menu.addCheckboxOption("Background", function() {
      backgroundEnabled = true;
      w.redraw();
    }, function() {
      backgroundEnabled = false;
      w.redraw();
    }, true);
  }
  menu.addEntry("<div><input type=\"file\" id=\"import_world\" multiple /> Import world</div>"); // (MOD)
  menu.addOption("Export world", function() { // (MOD) (BEGIN)
    exportWorld();
  }); // (MOD) (END)
  menu.addOption("Clear world", function() { // (MOD) (BEGIN)
    var con = confirm("Are you sure you want to clear this world? This cannot be undone.");
    if (con) {
      tile_database = {};
      clearTiles(true);
      getAndFetchTiles();
    }
  }); // (MOD) (END)
  var zoomBar = document.createElement("input");
  zoomBar.oninput = function() {
    var val = this.value;
    val /= 100;
    if(val < 0 || val > 1) val = 0.5;
    val = toLogZoom(val);
    changeZoom(val * 100);
  }
  zoomBar.ondblclick = function() {
    changeZoom(100);
  }
  zoomBar.title = "Zoom";
  zoomBar.type = "range";
  zoomBar.value = 50;
  zoomBar.min = 1;
  zoomBar.max = 100;
  zoomBar.id = "zoombar";
  var zoombarId = menu.addEntry(zoomBar);
  menu.zoombarId = zoombarId;
  menuOptions.zoom = zoombarId;
}

function updateMenuEntryVisiblity() {
  var permColorText = Permissions.can_color_text(state.userModel, state.worldModel);
  var permColorCell = Permissions.can_color_cell(state.userModel, state.worldModel);
  var permGoToCoord = Permissions.can_go_to_coord(state.userModel, state.worldModel);
  var permCoordLink = Permissions.can_coordlink(state.userModel, state.worldModel);
  var permUrlLink = Permissions.can_urllink(state.userModel, state.worldModel);
  var permOwnerArea = Permissions.can_admin(state.userModel, state.worldModel);
  var permMemberArea = Permissions.can_protect_tiles(state.userModel, state.worldModel);
  w.menu.setEntryVisibility(menuOptions.changeColor, permColorText || permColorCell);
  w.menu.setEntryVisibility(menuOptions.goToCoords, permGoToCoord);
  w.menu.setEntryVisibility(menuOptions.coordLink, permCoordLink);
  w.menu.setEntryVisibility(menuOptions.urlLink, permUrlLink);
  w.menu.setEntryVisibility(menuOptions.ownerArea, permOwnerArea);
  w.menu.setEntryVisibility(menuOptions.memberArea, permMemberArea);
  w.menu.setEntryVisibility(menuOptions.publicArea, permMemberArea);
  w.menu.setEntryVisibility(menuOptions.resetArea, permMemberArea);
}

function regionSelectionsActive() {
  for(var i = 0; i < regionSelections.length; i++) {
    if(regionSelections[i].isSelecting) return true;
  }
  return false;
}
function RegionSelection() {
  this.selection = null;
  this.regionSelected = false;
  this.regionCoordA = null;
  this.regionCoordB = null;
  this.isSelecting = false;
  this.charColor = "#9999e6";
  this.color = "rgba(0, 0, 255, 0.1)";
  this.tiled = false;
  this.lastSelectionHover = null; // [tileX, tileY, charX, charY]
  this.lastSelectionTiled = this.tiled;
  this.restartSelection = false;
  this.init = function() {
    if(this.selection) return;
    var div = document.createElement("div");
    div.className = "region_selection";
    div.style.display = "none";
    div.style.backgroundColor = this.color;
    document.body.appendChild(div);
    this.selection = div;
  }
  this.setSelection = function(start, end) {
    var coordA = start.slice(0);
    var coordB = end.slice(0);
    orderRangeABCoords(coordA, coordB);
    var tileX1 = coordA[0];
    var tileY1 = coordA[1];
    var charX1 = coordA[2];
    var charY1 = coordA[3];
    var tileX2 = coordB[0];
    var tileY2 = coordB[1];
    var charX2 = coordB[2];
    var charY2 = coordB[3];
    if(this.tiled) {
      charX1 = 0;
      charY1 = 0;
      charX2 = tileC - 1;
      charY2 = tileR - 1;
    }
    var pxCoordA = tileAndCharsToWindowCoords(tileX1, tileY1, charX1, charY1);
    var pxCoordB = tileAndCharsToWindowCoords(tileX2, tileY2, charX2, charY2);
    var regWidth = pxCoordB[0] - pxCoordA[0] + Math.trunc(cellW / zoomRatio) - 2;
    var regHeight = pxCoordB[1] - pxCoordA[1] + Math.trunc(cellH / zoomRatio) - 2;
    var sel = this.selection;
    sel.style.width = regWidth + "px";
    sel.style.height = regHeight + "px";
    sel.style.top = pxCoordA[1] + "px";
    sel.style.left = pxCoordA[0] + "px";
  }
  this.show = function() {
    this.selection.style.display = "";
  }
  this.hide = function() {
    this.selection.style.display = "none";
  }
  this.deselect = function(successful) {
    this.regionSelected = false;
    this.regionCoordA = null;
    this.regionCoordB = null;
    this.hide();
    if(!successful) {
      for(var i = 0; i < oncancelEvents.length; i++) {
        var func = oncancelEvents[i];
        func();
      }
    }
  }
  this.stopSelectionUI = function(successful) {
    if(!this.lastSelectionHover) return;
    if(!this.isSelecting) return;
    this.isSelecting = false;
    elm.owot.style.cursor = defaultCursor;
    var tileX = this.lastSelectionHover[0];
    var tileY = this.lastSelectionHover[1];
    var charX = this.lastSelectionHover[2];
    var charY = this.lastSelectionHover[3];
    // remove highlight
    if(this.tiled) {
      if(Tile.get(tileX, tileY)) {
        Tile.get(tileX, tileY).backgroundColor = "";
      }
    } else {
      uncolorChar(tileX, tileY, charX, charY, "reg");
    }
    w.setTileRedraw(tileX, tileY, true);
    this.deselect(successful);
  }
  var onselectionEvents = [];
  var oncancelEvents = [];
  this.onselection = function(func) {
    onselectionEvents.push(func);
  }
  this.oncancel = function(func) {
    oncancelEvents.push(func);
  }
  this.handleSelection = function() {
    for(var i = 0; i < onselectionEvents.length; i++) {
      var func = onselectionEvents[i];
      this.regionSelected = true;
      if(!this.regionCoordA) continue;
      this.setSelection(this.regionCoordA, this.regionCoordB);
      var coordA = this.regionCoordA.slice(0);
      var coordB = this.regionCoordB.slice(0);
      orderRangeABCoords(coordA, coordB);
      var regWidth = (coordB[0] - coordA[0]) * tileC + coordB[2] - coordA[2] + 1;
      var regHeight = (coordB[1] - coordA[1]) * tileR + coordB[3] - coordA[3] + 1;
      func(coordA, coordB, regWidth, regHeight);
    }
    if(!this.restartSelection) {
      this.stopSelectionUI(true);
    } else {
      // the selection has been immediately restarted after the event has been fired
      this.regionCoordA = null;
      this.regionCoordB = null;
      this.hide();
    }
  }
  this.startSelection = function() {
    if(this.isSelecting) {
      this.restartSelection = true;
    }
    this.isSelecting = true;
    elm.owot.style.cursor = "cell";
  }
  this.destroy = function() {
    for(var i = 0; i < regionSelections.length; i++) {
      if(regionSelections[i] == this) {
        regionSelections.splice(i, 1);
        i--;
      }
    }
  }
  regionSelections.push(this);
  this.init();
  return this;
}

w.on("tilesRendered", function() {
  for(var i = 0; i < regionSelections.length; i++) {
    var reg = regionSelections[i];
    if(reg.regionCoordA && reg.regionCoordB) reg.setSelection(reg.regionCoordA, reg.regionCoordB);
  }
});

w.on("cursorMove", function(pos) {
  setClientGuestCursorPosition(pos.tileX, pos.tileY, pos.charX, pos.charY);
});

w.on("cursorHide", function() {
  setClientGuestCursorPosition(0, 0, 0, 0, true);
});

function setClientGuestCursorPosition(tileX, tileY, charX, charY, hidden) {
  var pos = clientGuestCursorPos;
  var pTileX = pos.tileX;
  var pTileY = pos.tileY;
  var pCharX = pos.charX;
  var pCharY = pos.charY;
  var pHidden = pos.hidden;
  if(tileX == pTileX && tileY == pTileY && charX == pCharX && charY == pCharY && pHidden == hidden) return;
  clientGuestCursorPos = {
    tileX: tileX,
    tileY: tileY,
    charX: charX,
    charY: charY,
    hidden: hidden,
    updated: true
  };
}

function sendCursorPosition() {
  if(!showMyGuestCursor) return;
  if(!Permissions.can_show_cursor(state.userModel, state.worldModel)) return;
  if(!w.socket) return;
  var pos = clientGuestCursorPos;
  if(!pos.updated) return;
  pos.updated = false;
  network.cursor(pos.tileX, pos.tileY, pos.charX, pos.charY, pos.hidden);
}

var networkHTTP = {
  fetch: function(x1, y1, x2, y2, opts, callback) {
    if(typeof opts == "function") {
      callback = opts;
    } else if(!opts) {
      opts = {};
    }
    var temp;
    if(x1 > x2) {
      temp = x1;
      x1 = x2;
      x2 = temp;
    }
    if(y1 > y2) {
      temp = y1;
      y1 = y2;
      y2 = temp;
    }
    var data = {
      fetch: 1,
      min_tileX: x1,
      min_tileY: y1,
      max_tileX: x2,
      max_tileY: y2
    };
    var query = getQuerystring(window.location.search);
    if(query.key) {
      data.key = query.key;
    }
    if(opts.utf16) data.utf16 = true;
    if(opts.array) data.array = true;
    if(opts.content_only) data.content_only = true;
    if(opts.concat) data.concat = true;
    ajaxRequest({
      type: "GET",
      url: window.location.pathname,
      data: data,
      done: function(data) {
        if(callback) callback(JSON.parse(data));
      },
      error: function() {
        if(callback) callback(null);
      }
    });
  },
  write: function(edits, opts, callback) {
    if(typeof opts == "function") {
      callback = opts;
    } else if(!opts) {
      opts = {};
    }
    var data = {
      edits: JSON.stringify(edits)
    };
    if(opts.public_only) data.public_only = true;
    if(opts.preserve_links) data.preserve_links = true;
    ajaxRequest({
      type: "POST",
      url: window.location.pathname,
      data: data,
      done: function(data) {
        if(callback) callback(JSON.parse(data));
      },
      error: function() {
        if(callback) callback(null);
      }
    });
  },
  urllink: function(tileX, tileY, charX, charY, url, callback) {
    ajaxRequest({
      type: "POST",
      url: "/ajax/urllink/",
      data: {
        world: state.worldModel.name,
        tileX: tileX,
        tileY: tileY,
        charX: charX,
        charY: charY,
        url: url
      },
      done: function(data) {
        if(callback) callback(data);
      },
      error: function() {
        if(callback) callback(null);
      }
    });
  },
  coordlink: function(tileX, tileY, charX, charY, link_tileX, link_tileY, callback) {
    ajaxRequest({
      type: "POST",
      url: "/ajax/coordlink/",
      data: {
        world: state.worldModel.name,
        tileX: tileX,
        tileY: tileY,
        charX: charX,
        charY: charY,
        link_tileX: link_tileX,
        link_tileY: link_tileY
      },
      done: function(data) {
        if(callback) callback(data);
      },
      error: function() {
        if(callback) callback(null);
      }
    });
  },
  protect: function(tileX, tileY, type, callback) {
    // type: unprotect, public, member-only, owner-only
    var data = {
      world: state.worldModel.name,
      tileX: tileX,
      tileY: tileY
    };
    var url = "/ajax/protect/";
    if(type == "unprotect") {
      url = "/ajax/unprotect/";
    } else {
      data.type = type;
    }
    ajaxRequest({
      type: "POST",
      url: url,
      data: data,
      done: function(data) {
        if(callback) callback(data);
      },
      error: function() {
        if(callback) callback(null);
      }
    });
  },
  protectchar: function(tileX, tileY, charX, charY, type, callback) {
    // type: unprotect, public, member-only, owner-only
    var data = {
      world: state.worldModel.name,
      tileX: tileX,
      tileY: tileY,
      charX: charX,
      charY: charY
    };
    var url = "/ajax/protect/char/";
    if(type == "unprotect") {
      url = "/ajax/unprotect/char/";
    } else {
      data.type = type;
    }
    ajaxRequest({
      type: "POST",
      url: url,
      data: data,
      done: function(data) {
        if(callback) callback(data);
      },
      error: function() {
        if(callback) callback(null);
      }
    });
  }
};

var network = {
  latestID: 1,
  callbacks: {},
  http: networkHTTP,
  transmit: function(data) {
    data = JSON.stringify(data);
    try {
      w.socket.send(data);
    } catch(e) {
      console.warn("Transmission error");
    }
  },
  protect: function(position, type) {
    // position: {tileX, tileY, [charX, charY, [width, height]]]}
    // type: <unprotect, public, member-only, owner-only>
    var isPrecise = "charX" in position && "charY" in position;
    var data = {
      tileX: position.tileX,
      tileY: position.tileY,
      type: type == "unprotect" ? void 0 : type
    };
    if(isPrecise) {
      data.charX = position.charX;
      data.charY = position.charY;
      if(!("tileX" in position || "tileY" in position)) {
        data.tileX = Math.floor(data.charX / tileC);
        data.tileY = Math.floor(data.charY / tileR);
        data.charX = data.charX - Math.floor(data.charX / tileC) * tileC;
        data.charY = data.charY - Math.floor(data.charY / tileR) * tileR;
      }
      if("charWidth" in position && "charHeight" in position) {
        data.charWidth = position.charWidth;
        data.charHeight = position.charHeight;
      }
      data.precise = true;
    }
    var protReq = {
      kind: "protect",
      data: data,
      action: type == "unprotect" ? type : "protect"
    };
    network.transmit(protReq);
  },
  link: function(position, type, args) {
    // position: {tileX, tileY, charX, charY}
    // type: <url, coord>
    // args: {url} or {x, y}
    var data = {
      tileY: position.tileY,
      tileX: position.tileX,
      charY: position.charY,
      charX: position.charX
    };
    if(!("tileX" in position || "tileY" in position)) {
      data.tileX = Math.floor(data.charX / tileC);
      data.tileY = Math.floor(data.charY / tileR);
      data.charX = data.charX - Math.floor(data.charX / tileC) * tileC;
      data.charY = data.charY - Math.floor(data.charY / tileR) * tileR;
    }
    if(type == "url") {
      data.url = args.url;
    } else if(type == "coord") {
      data.link_tileX = args.x;
      data.link_tileY = args.y;
    }
    network.transmit({
      kind: "link",
      data: data,
      type: type
    });
  },
  cmd: function(data, include_username) {
    network.transmit({
      kind: "cmd",
      data: data, // maximum length of 2048
      include_username: include_username
    });
  },
  cmd_opt: function() {
    network.transmit({
      kind: "cmd_opt"
    });
  },
  write: function(edits, opts, callback) {
    if(!opts) opts = {};
    var writeReq = {
      kind: "write",
      edits: edits,
      public_only: opts.public_only,
      preserve_links: opts.preserve_links
    };
    if(callback) {
      var id = network.latestID++;
      writeReq.request = id;
      network.callbacks[id] = callback;
    }
    network.transmit(writeReq);
  },
  chathistory: function() {
    network.transmit({
      kind: "chathistory"
    });
  },
  fetch: function(fetches, opts, callback) {
    // fetches: [{minX: <x1>, minY: <y1>, maxX: <x2>, maxY: <y2>}...]
    if(!opts) opts = {};
    if(typeof fetches == "object" && !Array.isArray(fetches)) fetches = [fetches];
    var fetchReq = {
      fetchRectangles: fetches,
      kind: "fetch",
      utf16: opts.utf16,
      array: opts.array,
      content_only: opts.content_only,
      concat: opts.concat
    };
    if(opts.id) {
      fetchReq.request = opts.id;
    }
    if(callback) {
      var id = network.latestID++;
      fetchReq.request = id;
      network.callbacks[id] = callback;
    }
    network.transmit(fetchReq);
  },
  chat: function(message, location, nickname, color) {
    network.transmit({
      kind: "chat",
      nickname: nickname,
      message: message,
      location: location,
      color: color
    });
  },
  ping: function(callback) {
    var cb_id = void 0;
    if(callback) {
      cb_id = network.latestID++;
      network.callbacks[cb_id] = callback;
    }
    network.transmit({
      kind: "ping",
      id: cb_id // optional: number
    });
  },
  clear_tile: function(x, y) {
    network.transmit({
      kind: "clear_tile",
      tileX: x,
      tileY: y
    });
  },
  cursor: function(tileX, tileY, charX, charY, hidden) {
    var data = {
      kind: "cursor"
    };
    if(hidden) {
      data.hidden = true;
    } else {
      data.position = {
        tileX: tileX,
        tileY: tileY,
        charX: charX,
        charY: charY
      }
    }
    network.transmit(data);
  },
  boundary: function(centerX, centerY, minX, minY, maxX, maxY) {
    network.transmit({
      kind: "boundary",
      centerX: centerX,
      centerY: centerY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    });
  } 
};

Object.assign(w, {
  tiles: tiles,
  periodDeletedTiles: 0,
  hasUpdated: true,
  hasSelectiveUpdated: false,
  userCount: -1,
  clientId: -1,
  net: network,
  isLinking: false,
  isProtecting: false,
  url_input: "",
  coord_input_x: 0,
  coord_input_y: 0,
  link_input_type: 0, // 0 = link, 1 = coord,
  protect_type: null, // null = unprotect, 0 = public, 1 = member, 2 = owner
  protect_bg: "",
  nightMode: 0, // 0 = normal, 1 = night, 2 = night with normal background patterns
  input: elm.textInput,
  menu: null,
  ui: {
    announcements: {},
    coordLinkModal: null,
    coordGotoModal: null,
    urlModal: null,
    colorModal: null,
    selectionModal: null
  },
  styles: styles,
  backgroundInfo: {
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    rmod: 0,
    alpha: 1
  },
  tile: {
    count: 0,
    set: Tile.set,
    delete: Tile.delete,
    get: Tile.get,
    cache: tiles,
    exists: Tile.exists,
    loaded: Tile.loaded,
    visible: Tile.visible
  },
  doAnnounce: function(text, announceClass) {
    if(!announceClass) {
      announceClass = "main";
    }
    var an = w.ui.announcements[announceClass];
    if(an) {
      if(text) {
        an.text.innerHTML = text;
        an.bar.style.display = "";
      } else {
        an.bar.style.display = "none";
      }
    } else {
      if(!text) return;
      var anBar = document.createElement("div");
      var anText = document.createElement("span");
      var anClose = document.createElement("span");
      anBar.className = "ui-vis";
      anText.className = "announce_text";
      anText.innerHTML = text;
      anClose.className = "announce_close";
      anClose.onclick = function() {
        anBar.style.display = "none";
      }
      anClose.innerText = "X";
      anBar.appendChild(anText);
      anBar.appendChild(anClose);
      elm.announce_container.appendChild(anBar);
      w.ui.announcements[announceClass] = {
        bar: anBar,
        text: anText,
        close: anClose
      };
    }
  },
  regionSelect: new RegionSelection(),
  protectSelect: new RegionSelection(),
  color: function() {
    w.ui.colorModal.open();
  },
  goToCoord: function() {
    w.ui.coordGotoModal.open();
  },
  doGoToCoord: function(y, x) {
    var maxX = Number.MAX_SAFE_INTEGER / 160 / 4;
    var maxY = Number.MAX_SAFE_INTEGER / 144 / 4;
    if(x > maxX || x < -maxX || y > maxY || y < -maxY) {
      return;
    }
    positionX = Math.floor(-x * tileW * coordSizeX);
    positionY = Math.floor(y * tileH * coordSizeY);
    w.render();
  },
  doUrlLink: function(url) {
    linkAuto.active = true;
    linkAuto.mode = 0;
    linkAuto.url = url;

    if(w.isLinking || w.isProtecting) return;
    w.url_input = url;
    elm.owot.style.cursor = "pointer";
    w.isLinking = true;
    w.link_input_type = 0;
  },
  urlLink: function() {
    w.ui.urlModal.open();
  },
  doCoordLink: function(y, x) {
    linkAuto.active = true;
    linkAuto.mode = 1;
    linkAuto.coordTileY = y;
    linkAuto.coordTileX = x;

    if(w.isLinking || w.isProtecting) return;
    w.coord_input_x = x;
    w.coord_input_y = y;
    elm.owot.style.cursor = "pointer";
    w.isLinking = true;
    w.link_input_type = 1;
  },
  coordLink: function() {
    w.ui.coordLinkModal.open();
  },
  doProtect: function(protectType, unprotect) {
    // show the protection precision menu
    elm.protect_precision.style.display = "";
    tileProtectAuto.active = true;
    if(unprotect) { // default area protection
      tileProtectAuto.mode = 3;
    } else {
      if(protectType == "owner-only") tileProtectAuto.mode = 0;
      if(protectType == "member-only") tileProtectAuto.mode = 1;
      if(protectType == "public") tileProtectAuto.mode = 2;
    }

    if(w.isLinking) return;
    elm.owot.style.cursor = "pointer";
    w.protect_bg = {
      "owner-only": "#ddd",
      "member-only": "#eee",
      "public": "#fff"
    }[protectType];
    w.isProtecting = true;
    if(unprotect) {
      w.protect_type = null;
    } else if(protectType == "owner-only") {
      w.protect_type = 2;
    } else if(protectType == "member-only") {
      w.protect_type = 1;
    } else if(protectType == "public") {
      w.protect_type = 0;
    }
  },
  doUnprotect: function() {
    w.doProtect("public", true);
  },
  typeChar: writeChar,
  getChar: getChar,
  socketChannel: null,
  moveCursor: moveCursor,
  fetchUnloadedTiles: getAndFetchTiles,
  acceptOwnEdits: false,
  receivingBroadcasts: false,
  getTileVisibility: function() {
    var minVisY = (-positionY - Math.trunc(owotHeight / 2)) / tileH;
    var minVisX = (-positionX - Math.trunc(owotWidth / 2)) / tileW;
    var numDown = owotHeight / tileH;
    var numAcross = owotWidth / tileW;
    var maxVisY = minVisY + numDown;
    var maxVisX = minVisX + numAcross;
    var centerY = minVisY + numDown / 2;
    var centerX = minVisX + numAcross / 2;
    return {
      minVisY: minVisY,
      minVisX: minVisX,
      numDown: numDown,
      numAcross: numAcross,
      maxVisY: maxVisY,
      maxVisX: maxVisX,
      centerY: centerY,
      centerX: centerX
    };
  },
  getCenterCoords: function() { // [y, x]
    return [-positionY / tileH, -positionX / tileW];
  },
  chat: {
    send: api_chat_send
  },
  broadcastReceive: function(force) {
    if(w.receivingBroadcasts && !force) return;
    w.receivingBroadcasts = true;
    network.cmd_opt();
  },
  broadcastCommand: function(data, includeUsername) {
    network.cmd(data, includeUsername);
  },
  jquery: function(callback) {
    if(window.jQuery) return;
    var jqueryURL = "https://code.jquery.com/jquery-1.7.min.js";
    w.loadScript(jqueryURL, callback);
  },
  redraw: function() {
    renderSerial++;
    w.hasUpdated = true;
  },
  reloadRenderer: function() {
    reloadRenderer();
  },
  setRedraw: function() { // deprecated
    w.redraw();
  },
  setTileRedraw: function(tileX, tileY, highPriority, fastQueue) {
    var tile = Tile.get(tileX, tileY);
    if(!tile) return;
    w.hasSelectiveUpdated = true;
    tile.redraw = true;
    queueTile(tileX, tileY, highPriority);
    if(fastQueue) tile.fastQueue = true;
  },
  setTileRender: function(tileX, tileY) {
    // render tile again on main canvas on next render loop
    var tile = Tile.get(tileX, tileY);
    if(!tile) return;
    w.hasSelectiveUpdated = true;
    tile.rerender = true;
  },
  setTransparency: function(transparent) {
    if(transparent) {
      transparentBackground = true;
      setupTextRenderCtx();
    } else {
      transparentBackground = false;
      setupTextRenderCtx();
    }
    updateScaleConsts();
    w.redraw();
  },
  render: function(redraw) {
    if(redraw) w.redraw();
    w.hasUpdated = true;
  },
  changeFont: function(fontData, nr) {
    // change the global font
    fontTemplate = fontData;
    font = fontTemplate.replace("$", normFontSize(16 * zoom));
    textRenderCtx.font = font;
    if(!nr) w.redraw();
  },
  fixFonts: function(mainType) {
    if(!window.Promise || !window.FontFace) return;
    var list = {
      "legacycomputing": "url('" + lcsURL + "')" // (MOD)
    };
    if(mainType) { // load just one specific type
      for(var i in list) {
        if(i != mainType) {
          delete list[i];
        }
      }
    }
    var promises = [];
    var fonts = {};
    for(var name in list) {
      var ff = new FontFace(name, list[name]);
      fonts[name] = ff;
      promises.push(ff.load());
    }
    if(!promises.length) return;
    Promise.all(promises).then(function() {
      var fontNames = [];
      for(var name in fonts) {
        document.fonts.add(fonts[name]);
        fontNames.push(name);
      }
      fontOrder.push(...fontNames);
      specialFontOrder.unshift(...fontNames);
      rebuildFontTemplates();
      w.changeFont(fontTemplate, true);
      w.changeSpecialCharFont(specialFontTemplate);
    });
  },
  loadFont: function(name, path, cb) {
    var fnt = new FontFace(name, "url(\"" + encodeURI(path) + "\")");
    fnt.load().then(function() {
      document.fonts.add(fnt);
      if(cb) cb(fnt);
    });
  },
  changeSpecialCharFont: function(fontData, nr) {
    specialFontTemplate = fontData;
    specialCharFont = specialFontTemplate.replace("$", normFontSize(16 * zoom));
    if(!nr) w.redraw();
  },
  enableCombining: function(nr) {
    combiningCharsEnabled = true;
    if(!nr) w.redraw();
  },
  disableCombining: function(nr) {
    combiningCharsEnabled = false;
    if(!nr) w.redraw();
  },
  enableSurrogates: function(nr) {
    surrogateCharsEnabled = true;
    if(!nr) w.redraw();
  },
  disableSurrogates: function(nr) {
    surrogateCharsEnabled = false;
    if(!nr) w.redraw();
  },
  enableColors: function(nr) {
    colorsEnabled = true;
    if(!nr) w.redraw();
  },
  disableColors: function(nr) {
    colorsEnabled = false;
    if(!nr) w.redraw();
  },
  basic: function() {
    w.disableSurrogates(1);
    w.disableCombining(1);
    w.disableColors(1);
    w.redraw();
  },
  restore: function() {
    w.enableSurrogates(1);
    w.enableCombining(1);
    w.enableColors(1);
    w.redraw();
  },
  night: function(ignoreUnloadedPattern) {
    styles.member = "#111";
    styles.owner = "#222";
    styles.public = "#000";
    styles.text = "#FFF";
    w.nightMode = 1;
    if(ignoreUnloadedPattern) {
      w.nightMode = 2;
    } else if(!elm.owot.classList.contains("nightmode")) {
      elm.owot.classList.add("nightmode");
    }
    w.redraw();
  },
  day: function(reloadStyle) {
    w.nightMode = 0;
    if(elm.owot.classList.contains("nightmode")) {
      elm.owot.classList.remove("nightmode");
    }
    if(reloadStyle) {
      // (MOD) (BEGIN)
      /*getWorldProps(state.worldModel.name, "style", function(style, error) {
        if(!error) {
          styles.member = style.member;
          styles.owner = style.owner;
          styles.public = style.public;
          styles.text = style.text;
        }
        menu_color(styles.menu);
        w.redraw();
      });*/
      styles = defaultStyles();
      menu_color(styles.menu);
      w.redraw();
      // (MOD) (END)
    } else {
      var def = defaultStyles();
      styles.member = def.member;
      styles.owner = def.owner;
      styles.public = def.public;
      styles.text = def.text;
      w.redraw();
    }
  },
  rotate: function(speed) {
    if(!speed) speed = 2;
    var rotation = 0;
    var rot = setInterval(function() {
      elm.main_view.style.transform = "perspective(900px) rotateY(" + rotation + "deg)";
      rotation += speed;
      if(rotation >= 360) {
        elm.main_view.style.transform = "";
        clearInterval(rot);
      }
    }, 10);
  },
  hideChat: function() {
    chat_open.style.display = "none";
    elm.chat_window.style.display = "none";
  },
  showChat: function() {
    chat_open.style.display = "";
    if(chatOpen) elm.chat_window.style.display = "";
  },
  disableDragging: function() {
    draggingEnabled = false;
    stopDragging();
  },
  enableDragging: function() {
    draggingEnabled = true;
  },
  disableCursor: function() {
    cursorEnabled = false;
    removeCursor();
  },
  enableCursor: function() {
    cursorEnabled = true;
  },
  disableScrolling: function() {
    scrollingEnabled = false;
  },
  enableScrolling: function() {
    scrollingEnabled = true;
  },
  setMouseCursor: function(cursor) {
    defaultCursor = cursor;
  },
  resetMouseCursor: function() {
    defaultCursor = "text";
  },
  setDragCursor: function(cursor) {
    defaultDragCursor = cursor;
  },
  resetDragCursor: function() {
    defaultDragCursor = "move";
  },
  changeSocket: function(addr, getChatHist) {
    ws_path = addr;
    socket.close();
    createSocket(getChatHist);
    clearTiles(true);
    clearInterval(fetchInterval);
  },
  changeColor: function(color) {
    color = resolveColorValue(color);
    YourWorld.Color = color;
    localStorage.setItem("color", color);
    // update color textbox in "change color" menu
    var rgb = int_to_rgb(color);
    setRGBColorPicker(rgb[0], rgb[1], rgb[2]);
    if(cursorCoords) {
      var cursorTileX = cursorCoords[0];
      var cursorTileY = cursorCoords[1];
      w.setTileRedraw(cursorTileX, cursorTileY, true);
    }
  },
  changeBgColor: function(color) {
    if(color == -1) {
      YourWorld.BgColor = -1;
      return;
    }
    color = resolveColorValue(color);
    YourWorld.BgColor = color;
    var rgb = int_to_rgb(color);
    setRGBBgColorPicker(rgb[0], rgb[1], rgb[2]);
  },
  fetchUpdates: function(margin) {
    if(!margin) margin = 0;
    var vis = getVisibleTileRange(margin);
    network.fetch({
      minX: vis[0][0],
      minY: vis[0][1],
      maxX: vis[1][0],
      maxY: vis[1][1]
    });
  },
  splitTile: function(str) {
    if(!classicTileProcessing) {
      return w.split(str);
    } else {
      return w.split(str, false, false, true);
    }
  },
  shiftZoombar: function() {
    w.menu.moveEntryLast(w.menu.zoombarId);
  },
  setFlushInterval: function(rate) {
    if(typeof rate != "number" || rate < 0 || isNaN(rate) || !isFinite(rate) || rate > 1000000) rate = 1000;
    writeFlushRate = rate;
    setWriteInterval();
  },
  registerHook: function(event, callback) {
    event = event.toLowerCase();
    if(event == "renderchar") {
      // parameters: charCode, ctx, tileX, tileY, charX, charY, offsetX, offsetY, width, height
      specialClientHookMap |= (1 << 0);
      if(!specialClientHooks[event]) {
        specialClientHooks[event] = [];
      }
      specialClientHooks[event].push(callback);
    }
  }
});

elm.owot.oncontextmenu = function() {
  if(ignoreCanvasContext) {
    ignoreCanvasContext = false;
    elm.owot.style.pointerEvents = "none";
    setTimeout(function() {
      ignoreCanvasContext = true;
      elm.owot.style.pointerEvents = "";
    }, 1);
  }
}

window.onhashchange = function(e) {
  manageCoordHash();
}

window.onbeforeunload = function() {
  if(writeBuffer.length) flushWrites();
}

document.onselectstart = function(e) {
  var target = e.target;
  if(closest(target, getChatfield()) || target == elm.chatbar || closest(target, elm.confirm_js_code) || closest(target, elm.announce_text)) {
    return true;
  }
  return Modal.isOpen;
}

function disableBgColorPicker() {
  // a crude method of "clearing"/"disabling" the color picker
  if(!colorInputBg.jscolor.refine) return;
  colorInputBg.jscolor.fromRGB(255, 255, 255);
  colorInputBg.value = "[ None ]";
  colorInputBg.jscolor.refine = false;
  colorInputBg.onclick = enableBgColorPicker;
}

function enableBgColorPicker() {
  if(colorInputBg.jscolor.refine) return;
  colorInputBg.jscolor.refine = true;
  colorInputBg.onclick = null;
  colorInputBg.jscolor.fromString("#DCE943");
}

function makeCoordLinkModal() {
  var modal = new Modal();
  modal.createForm();
  modal.setFormTitle("Enter the coordinates to create a link to. You can then click on a letter to create the link.\n");
  var coordX = modal.addEntry("X", "text", "number").input;
  var coordY = modal.addEntry("Y", "text", "number").input;
  modal.setMaximumSize(360, 300);
  modal.onSubmit(function() {
    w.doCoordLink(parseFloat(coordY.value), parseFloat(coordX.value));
  });
  w.ui.coordLinkModal = modal;
}

function makeCoordGotoModal() {
  var modal = new Modal();
  modal.createForm();
  modal.setFormTitle("Go to coordinates:\n");
  var coordX = modal.addEntry("X", "text", "number").input;
  var coordY = modal.addEntry("Y", "text", "number").input;
  modal.onSubmit(function() {
    w.doGoToCoord(parseFloat(coordY.value), parseFloat(coordX.value));
  });
  w.ui.coordGotoModal = modal;
}

function makeURLModal() {
  var modal = new Modal();
  modal.setMinimumSize(250, 120);
  modal.createForm();
  modal.setFormTitle("\n");
  var urlInput = modal.addEntry("URL", "text").input;
  urlInput.style.width = "175px";
  modal.onSubmit(function() {
    w.doUrlLink(urlInput.value);
  });
  modal.unalignForm();
  w.ui.urlModal = modal;
}

function buildBackgroundColorModal(modal) {
  modal.addTab("fg", "Text");
  modal.addTab("bg", "Cell");

  modal.focusTab("bg");

  modal.createForm();
  modal.setFormTitle("\n");
  colorInputBg = modal.addEntry("Cell color", "color").input;
  modal.setFooterContentRight(colorShortcutsBg);
  updateBgColorPicker();

  modal.focusTab("fg");
  
  disableBgColorPicker();

  modal.onTabChange(function(evt) {
    var tab = evt.id;
    if(tab == "bg") {
      colorShortcutsBg.style.display = "";
      colorShortcuts.style.display = "none";
    } else if(tab == "fg") {
      colorShortcutsBg.style.display = "none";
      colorShortcuts.style.display = "";
    }
  });
}

function resetColorModalVisibility() {
  var pText = Permissions.can_color_text(state.userModel, state.worldModel);
  var pCell = Permissions.can_color_cell(state.userModel, state.worldModel);
  if(pCell) {
    if(!w.ui.colorModal.getTabData("bg")) {
      buildBackgroundColorModal(w.ui.colorModal);
    }
    w.ui.colorModal.showTab("bg");
  } else {
    w.ui.colorModal.hideTab("bg");
    w.ui.colorModal.focusTab("fg");
  }
  if(pText) {
    w.ui.colorModal.showTab("fg");
  } else {
    w.ui.colorModal.hideTab("fg");
    w.ui.colorModal.focusTab("bg");
  }
  if(!pCell && !pText) {
    w.ui.colorModal.close();
  }
}

function makeColorModal() {
  var modal = new Modal();
  modal.setMinimumSize(290, 128);
  modal.createForm();
  modal.setFormTitle("\n");
  colorInput = modal.addEntry("Text color", "color").input;
  modal.onSubmit(function() {
    var color;
    var isBg = modal.getCurrentTabId() == "bg";
    if(!isBg) { // text color
      color = colorInput.value;
    } else { // cell color
      if(!colorInputBg.jscolor.refine) return;
      color = colorInputBg.value;
    }
    var this_color = 0;
    if(color) {
      this_color = parseInt(color, 16);
    }
    if(!this_color) {
      this_color = 0;
    }
    if(!isBg) {
      w.changeColor(this_color);
      localStorage.setItem("color", this_color);
    } else {
      w.changeBgColor(this_color);
      // we don't need to save the bg color to localStorage (if enabled for this world)
    }
  });
  modal.onClose(function(canceled) {
    if(!canceled) {
      modal.submitForm();
    }
  });
  modal.setFooter();
  modal.setFooterCheckbox("Outline", function(checked) {
    cursorOutlineEnabled = checked;
    storeConfig();
    if(!cursorCoords) return;
    var cursorTileX = cursorCoords[0];
    var cursorTileY = cursorCoords[1];
    w.setTileRedraw(cursorTileX, cursorTileY, true);
  }, cursorOutlineEnabled);

  colorShortcuts = document.createElement("div");
  colorShortcuts.id = "color_shortcuts";
  modal.setFooterContentRight(colorShortcuts);

  colorShortcutsBg = document.createElement("div");
  colorShortcutsBg.id = "color_shortcuts_bg";
  colorShortcutsBg.style.display = "none";

  if(Permissions.can_color_cell(state.userModel, state.worldModel)) {
    buildBackgroundColorModal(modal);
  }

  if(!Permissions.can_color_text(state.userModel, state.worldModel)) {
    modal.focusTab("bg");
    modal.hideTab("fg");
  }
  w.ui.colorModal = modal;
}

function makeSelectionModal() {
  var headerBar = document.createElement("div");

  var area_copy = document.createElement("button");
  area_copy.style.marginBottom = "1px";
  area_copy.innerText = "Copy to Clipboard";
  area_copy.onclick = function() {
    w.clipboard.copy(region_text.value);
  }

  var region_bounds = document.createElement("span");
  region_bounds.style.display = "none";
  region_bounds.style.marginLeft = "5px";
  var reg_label = document.createElement("b");
  reg_label.innerText = "Selection: ";
  var rb_coord1 = document.createElement("span");
  var rb_coord2 = document.createElement("span");
  region_bounds.appendChild(reg_label);
  region_bounds.appendChild(rb_coord1);
  region_bounds.appendChild(document.createTextNode(", "));
  region_bounds.appendChild(rb_coord2);
  var region_text = document.createElement("textarea")
  region_text.id = "area_results";

  headerBar.appendChild(area_copy);
  headerBar.appendChild(region_bounds);

  function updateOutput() {
    var o_color = c_color.cbElm.checked;
    var o_bgcolor = c_bgcolor.cbElm.checked;
    var o_link = c_link.cbElm.checked;
    var o_deco = c_deco.cbElm.checked;
    var o_prot = c_prot.cbElm.checked;
    var o_protpub = c_pprot.cbElm.checked;
    var o_tleft = t_left.cbElm.checked;
    var o_tright = t_right.cbElm.checked;
    var o_tempty = t_empty.cbElm.checked;
    var o_rgap = r_gap.cbElm.checked;
    var o_rlnbrk = r_br.cbElm.checked;
    var o_rsurrog = r_surr.cbElm.checked;
    var o_rcomb = r_comb.cbElm.checked;
    var text = s_str;
    var currentCol = -1;
    var currentBgCol = -1;
    var resText = [];
    for(var y = 0; y < text.length; y++) {
      var textRow = text[y].slice(0);
      filterAdvancedChars(textRow, o_rsurrog, o_rcomb);
      var colRow = o_color && s_colors[y] && s_colors[y].slice(0);
      var bgColRow = o_bgcolor && s_bgcolors[y] && s_bgcolors[y].slice(0);
      var linkRow = o_link && s_links[y] && s_links[y].slice(0);
      var protRow = o_prot && s_prots[y] && s_prots[y].slice(0);
      var decoRow = o_deco && s_decos[y] && s_decos[y].slice(0);
      if(o_tleft || o_tright || o_rgap) spaceTrim(textRow, o_tleft, o_tright, o_rgap, [colRow, linkRow, protRow, decoRow]);
      if(o_deco && decoRow) {
        for(var x = 0; x < textRow.length; x++) {
          var chr = textRow[x];
          var deco = decoRow[x];
          if(deco) {
            chr = setCharTextDecorations(chr, deco.bold, deco.italic, deco.under, deco.strike);
            textRow[x] = chr;
          }
        }
      }
      if(o_color || (o_color && o_bgcolor)) {
        for(var x = 0; x < textRow.length; x++) {
          var col = 0;
          var bgCol = -1;
          if(colRow) col = colRow[x];
          if(bgColRow) bgCol = bgColRow[x];

          if(col == currentCol && bgCol == currentBgCol) continue;

          var chr = "";
          if(bgCol != currentBgCol && o_bgcolor) { // cell color
            chr += "\x1b";
            if(bgCol == -1) {
              chr += "x";
              currentCol = -1; // this also resets text color, so re-add it right after bgcolor definition
            } else {
              chr += "b" + bgCol.toString(16).padStart(6, 0);
            }
          }
          if(col != currentCol && o_color) { // text color
            chr += "\x1b";
            if(col == 0) {
              chr += "x";
              if(o_bgcolor && bgCol != -1) { // re-add cell color if applicable
                chr += "\x1b" + "b" + bgCol.toString(16).padStart(6, 0);
              }
            } else {
              chr += "F" + col.toString(16).padStart(6, 0);
            }
          }
          currentCol = col;
          currentBgCol = bgCol;
          textRow[x] = chr + textRow[x];
        }
      }
      if(o_link && linkRow) {
        for(var x = 0; x < textRow.length; x++) {
          var link = linkRow[x];
          if(!link) continue;
          textRow[x] = "\x1b" + link + textRow[x];
        }
      }
      if(o_prot && protRow) {
        for(var x = 0; x < textRow.length; x++) {
          var prot = protRow[x];
          if(prot == 0 && !o_protpub) continue;
          textRow[x] = "\x1b" + "P" + prot + textRow[x]; // prot should be one character in length
        }
      }
      textRow = textRow.join("");
      if(o_tempty && !textRow.length) {
        continue;
      }
      resText.push(textRow);
    }
    if(!o_rlnbrk) {
      resText = resText.join("\n");
    } else {
      resText = resText.join("");
    }
    region_text.value = resText;
  }

  var s_str;
  var s_colors;
  var s_bgcolors;
  var s_links
  var s_prots;
  var s_decos;

  var modal = new Modal();
  modal.setMinimumSize(500, 450);
  modal.append(headerBar);
  modal.append(region_text);
  modal.createCheckboxField();
  modal.createClose();
  var c_color = modal.addCheckbox("Copy colors");
  var c_bgcolor = modal.addCheckbox("Copy cell colors", c_color);
  var c_link = modal.addCheckbox("Copy links");
  var c_prot = modal.addCheckbox("Copy protections");
  var c_pprot = modal.addCheckbox("Copy public protections", c_prot);
  var c_deco = modal.addCheckbox("Copy text decorations");
  var t_left = modal.addCheckbox("Trim left");
  var t_right = modal.addCheckbox("Trim right");
  var t_empty = modal.addCheckbox("Trim empty lines");
  var r_gap = modal.addCheckbox("Remove gaps");
  var r_br = modal.addCheckbox("Remove line breaks");
  var r_surr = modal.addCheckbox("Remove surrogates");
  var r_comb = modal.addCheckbox("Remove combining chars");
  c_bgcolor.elm.style.display = "none"; // keep bg color option hidden unless there exist colored cells
  modal.checkboxFieldOnInput(function(obj, checked) {
    updateOutput();
  });
  modal.onOpen(function(str, colors, bgcolors, links, protections, decorations, coords) {
    s_str = str;
    s_colors = colors;
    s_bgcolors = bgcolors;
    s_links = links;
    s_prots = protections;
    s_decos = decorations;
    var bgColorsFound = false;
    for(var i = 0; i < bgcolors.length; i++) {
      if(bgcolors[i]) {
        c_bgcolor.elm.style.display = "";
        bgColorsFound = true;
        break;
      }
    }
    if(!bgColorsFound) {
      c_bgcolor.elm.style.display = "none";
    }
    if(!showCursorCoordinates) {
      region_bounds.style.display = "none";
    } else {
      region_bounds.style.display = "";
      rb_coord1.innerText = JSON.stringify(coords[0]);
      rb_coord2.innerText = JSON.stringify(coords[1]);
    }
    updateOutput();
  });
  w.ui.selectionModal = modal;
}

// (MOD) (BEGIN)
/*if(state.userModel.is_superuser) {
  w.loadScript("/static/yw/javascript/world_tools.js");
}*/
// (MOD) (END)

if(state.background) {
  w.backgroundInfo.x = ("x" in state.background) ? state.background.x : 0;
  w.backgroundInfo.y = ("y" in state.background) ? state.background.y : 0;
  w.backgroundInfo.w = ("w" in state.background) ? state.background.w : 0;
  w.backgroundInfo.h = ("h" in state.background) ? state.background.h : 0;
  w.backgroundInfo.rmod = ("rmod" in state.background) ? state.background.rmod : 0;
  w.backgroundInfo.alpha = ("alpha" in state.background) ? state.background.alpha : 1;
}

var tellEdit = [];
// tileY, tileX, charY, charX, X, X, editID
function searchTellEdit(tileX, tileY, charX, charY) {
  for(var i = 0; i < tellEdit.length; i++) {
    if(tellEdit[i][1] == tileX &&
      tellEdit[i][0] == tileY &&
      tellEdit[i][3] == charX &&
      tellEdit[i][2] == charY) {
      return true;
    }
  }
  return false;
}

function tile_offset_object(data, tileOffX, tileOffY) {
  var refs = {};
  var tilef;
  for(var tilef in data) {
    refs[tilef] = data[tilef];
    delete data[tilef];
  }
  for(var tkp in refs) {
    var new_key = getPos(tkp);
    new_key = (new_key[0] - tileOffY) + "," + (new_key[1] - tileOffX);
    data[new_key] = refs[tkp];
  }
}

var ws_functions = {
  fetch: function(data) {
    var id = 0;
    if("request" in data) {
      id = data.request;
      var cb = network.callbacks[id];
      if(typeof cb == "function") {
        cb(data.tiles, null);
      }
      delete network.callbacks[id];
    }
    var fastQueue = id == -1;
    if(tileFetchOffsetX || tileFetchOffsetY) {
      tile_offset_object(data.tiles, tileFetchOffsetX, tileFetchOffsetY);
    }
    w.emit("fetch", data);
    for(var tileKey in data.tiles) {
      var tile = data.tiles[tileKey];
      var pos = getPos(tileKey);
      if(tile) {
        tile.content = w.splitTile(tile.content);
        Tile.set(pos[1], pos[0], tile);
      } else {
        Tile.set(pos[1], pos[0], blankTile());
      }
      if(tiles[tileKey].properties.char) {
        tiles[tileKey].properties.char = decodeCharProt(tiles[tileKey].properties.char);
      }
      var tileX = pos[1];
      var tileY = pos[0];
      w.setTileRedraw(tileX, tileY, false, fastQueue);
      if(bufferLargeChars) {
        w.setTileRedraw(tileX, tileY - 1, false, fastQueue);
        w.setTileRedraw(tileX + 1, tileY - 1, false, fastQueue);
        w.setTileRedraw(tileX + 1, tileY, false, fastQueue);
      }
    }
    w.emit("afterFetch", data);
    updateHoveredLink(null, null, null, true);
    // too many tiles, remove tiles outside of the viewport
    var tileLim = Math.floor(getArea(fetchClientMargin) * 1.5 / zoom + 1000);
    if(w.tile.count > tileLim && unloadTilesAuto) {
      clearTiles();
    }
  },
  colors: function(data) {
    // update all world colors
    w.emit("colors", data);
    styles.public = data.colors.background;
    styles.cursor = data.colors.cursor;
    styles.guestCursor = data.colors.guest_cursor;
    styles.member = data.colors.member_area;
    styles.menu = data.colors.menu;
    styles.owner = data.colors.owner_area;
    styles.text = data.colors.text;
    styles.public_text = data.colors.public_text;
    styles.member_text = data.colors.member_text;
    styles.owner_text = data.colors.owner_text;
    checkTextColorOverride();
    w.redraw();
    menu_color(styles.menu);
  },
  tileUpdate: function(data) {
    w.emit("tileUpdate", data);
    var highlights = [];
    // settings are configured to offset server-fetched tiles
    if(tileFetchOffsetX || tileFetchOffsetY) {
      tile_offset_object(data.tiles, tileFetchOffsetX, tileFetchOffsetY);
    }
    for(var tileKey in data.tiles) {
      var pos = getPos(tileKey);
      var tileX = pos[1];
      var tileY = pos[0];
      var tile = data.tiles[tileKey];
      if(!tile.properties) {
        tile.properties = {};
      }
      var localTile = Tile.get(tileX, tileY);
      if(!localTile) {
        tile.content = w.splitTile(tile.content);
        if(tile.properties.char) {
          tile.properties.char = decodeCharProt(tile.properties.char);
        }
        Tile.set(tileX, tileY, tile);
        w.setTileRedraw(tileX, tileY);
        continue;
      }
      var props = tile.properties;
      var localProps = localTile.properties;

      var charData = w.splitTile(tile.content);
      var colorData = props.color;
      var bgColorData = props.bgcolor;

      var localCharData = localTile.content;
      var localColorData = localProps.color;
      var localBgColorData = localProps.bgcolor;

      var shouldDeleteLocalColor = false;
      var shouldDeleteLocalBgColor = false;

      localProps.writability = props.writability;
      if(props.cell_props) {
        localProps.cell_props = props.cell_props;
      } else {
        delete localProps.cell_props;
      }
      if(props.char) {
        localProps.char = decodeCharProt(props.char);
      } else {
        delete localProps.char;
      }
      if(!colorData) { // no remote color data, delete local
        shouldDeleteLocalColor = true;
      } else if(!localColorData) { // remote color data exists, set local value to remote
        localColorData = colorData; // we will be sharing a reference with the remote color data
        localProps.color = localColorData;
      }
      if(!bgColorData) {
        shouldDeleteLocalBgColor = true;
      } else if(!localBgColorData) {
        localBgColorData = bgColorData; // again, same with the remote bg color data
        localProps.bgcolor = localBgColorData;
      }

      for(var c = 0; c < tileArea; c++) {
        var charX = c % tileC;
        var charY = Math.floor(c / tileC);

        var localChar = localCharData[c];
        var remoteChar = charData[c];

        var localColor = localColorData ? localColorData[c] : 0;
        var remoteColor = colorData ? colorData[c] : 0;

        var localBgColor = localBgColorData ? localBgColorData[c] : -1;
        var remoteBgColor = bgColorData ? bgColorData[c] : -1;

        if(localChar != remoteChar || localColor != remoteColor || localBgColor != remoteBgColor) {
          // don't overwrite local changes until those changes are confirmed
          if(!searchTellEdit(tileX, tileY, charX, charY)) {
            localCharData[c] = remoteChar;
            if(localColorData) {
              localColorData[c] = remoteColor;
            }
            if(localBgColorData) {
              localBgColorData[c] = remoteBgColor;
            }
          } else {
            shouldDeleteLocalColor = false;
            shouldDeleteLocalBgColor = false;
          }
          // briefly highlight these changes (10 at a time)
          if(useHighlight && Tile.visible(tileX, tileY)) {
            highlights.push([tileX, tileY, charX, charY]);
          }
        }
      }
      if(shouldDeleteLocalColor) {
        delete localProps.color;
      }
      if(shouldDeleteLocalBgColor) {
        delete localProps.bgcolor;
      }
      w.setTileRedraw(tileX, tileY);
      if(bufferLargeChars) {
        w.setTileRedraw(tileX, tileY - 1);
        w.setTileRedraw(tileX + 1, tileY - 1);
        w.setTileRedraw(tileX + 1, tileY);
      }
    }
    if(highlights.length > 0 && useHighlight) highlight(highlights);
    var tileLim = Math.floor(getArea(fetchClientMargin) * 1.5 / zoom + 1000);
    if(w.tile.count > tileLim && unloadTilesAuto) {
      clearTiles();
    }
    w.emit("afterTileUpdate", data);
  },
  write: function(data) {
    if("request" in data) {
      var id = data.request;
      var cb = network.callbacks[id];
      if(typeof cb == "function") {
        cb(data, null);
      }
      delete network.callbacks[id];
    }
    w.emit("writeResponse", data);
    for(var i = 0; i < data.accepted.length; i++) {
      for(var x = 0; x < tellEdit.length; x++) {
        if(tellEdit[x][6] == data.accepted[i]) {
          var tileX = tellEdit[x][1];
          var tileY = tellEdit[x][0];
          var charX = tellEdit[x][3];
          var charY = tellEdit[x][2];
          // check if there are links in queue
          for(var r = 0; r < linkQueue.length; r++) {
            var queueItem = linkQueue[r];
            if(queueItem[1] == tileX && queueItem[2] == tileY && queueItem[3] == charX && queueItem[4] == charY) {
              var linkType = queueItem[0];
              if(linkType == "url") {
                network.link({
                  tileY: tileY,
                  tileX: tileX,
                  charY: charY,
                  charX: charX
                }, "url", { url: queueItem[5] });
              } else if(linkType == "coord") {
                network.link({
                  tileY: tileY,
                  tileX: tileX,
                  charY: charY,
                  charX: charX
                }, "coord", { x: queueItem[5], y: queueItem[6] });
              }
              linkQueue.splice(r, 1);
              break;
            }
          }
          if(uncolorChar(tileX, tileY, charX, charY, "err")) {
            w.setTileRedraw(tileX, tileY, true);
          }
          tellEdit.splice(x, 1);
          // because the element has been removed, the length of the array is shorter
          x--;
        }
      }
    }
    for(var i in data.rejected) {
      var rej = data.rejected[i];
      for(var x = 0; x < tellEdit.length; x++) {
        if(tellEdit[x][6] != i) continue;
        var tileX = tellEdit[x][1];
        var tileY = tellEdit[x][0];
        var charX = tellEdit[x][3];
        var charY = tellEdit[x][2];
        if(rej == 1 || rej == 4) { // denied because zero rate limit
          highlight([[tileX, tileY, charX, charY]], true, [255, 0, 0]);
          tellEdit.splice(x, 1);
          x--;
          continue;
        }
        colorChar(tileX, tileY, charX, charY, "err");
        w.setTileRedraw(tileX, tileY, true);
        tellEdit[x][4] = getDate();
        writeBuffer.push(tellEdit[x]);
      }
    }
  },
  channel: function(data) {
    w.socketChannel = data.sender;
    w.clientId = data.id;
    w.userCount = data.initial_user_count;
    updateUserCount();
  },
  announcement: function(data) {
    w.emit("announcement", data);
    data.text = html_tag_esc(data.text);
    w.doAnnounce(data.text);
  },
  ping: function(data) {
    w.emit("ping", data);
    if(data.id) {
      if(network.callbacks[data.id]) {
        var cb = network.callbacks[data.id];
        delete network.callbacks[data.id];
        cb();
      }
    }
  },
  propUpdate: function(data) {
    w.emit("propUpdate", data.props);
    var props = data.props;
    for(var p = 0; p < props.length; p++) {
      var prop = props[p];
      var type = prop.type;
      var value = prop.value;
      switch(type) {
        case "isMember":
          state.userModel.is_member = value;
          break;
        case "isOwner":
          state.userModel.is_owner = value;
          break;
        case "goToCoord":
          state.worldModel.feature_go_to_coord = value;
          break;
        case "coordLink":
          state.worldModel.feature_coord_link = value;
          break;
        case "urlLink":
          state.worldModel.feature_url_link = value;
          break;
        case "paste":
          state.worldModel.feature_paste = value;
          break;
        case "chat":
          state.worldModel.chat_permission = value;
          elm.chatbar.disabled = !Permissions.can_chat(state.userModel, state.worldModel);
          break;
        case "showCursor":
          state.worldModel.show_cursor = value;
          break;
        case "colorText":
          state.worldModel.color_text = value;
          resetColorModalVisibility();
          break;
        case "colorCell":
          state.worldModel.color_cell = value;
          resetColorModalVisibility();
          break;
        case "memberTilesAddRemove":
          state.worldModel.feature_membertiles_addremove = value;
          break;
        case "readability":
          break;
        case "writability":
          state.worldModel.writability = value;
          w.redraw();
          break;
        case "name":
          state.worldModel.name = value;
          state.worldModel.pathname = value ? "/" + value : "";
          if(!value || value.toLowerCase() == "main" || value.toLowerCase() == "owot") {
            document.title = "Our World of Text";
          } else {
            document.title = state.worldModel.pathname;
          }
          ws_path = createWsPath();
          if(window.history && window.history.replaceState) {
            history.replaceState({}, "", state.worldModel.pathname + window.location.search + window.location.hash);
          }
          break;
        case "charRate":
          state.worldModel.char_rate = value;
          break;
        case "writeInt":
          w.setFlushInterval(value);
          break;
      }
    }
    updateMenuEntryVisiblity();
  },
  chat: function(data) {
    var type = chatType(data.registered, data.nickname, data.realUsername);
    w.emit("chat", {
      location: data.location,
      id: data.id,
      type: type,
      nickname: data.nickname,
      message: data.message,
      realUsername: data.realUsername,
      op: data.op,
      admin: data.admin,
      staff: data.staff,
      color: data.color,
      date: data.date,
      dataObj: data,
      hide: false
    });
  },
  user_count: function(data) {
    var count = data.count;
    w.emit("userCount", count);
    w.userCount = count;
    updateUserCount();
  },
  chathistory: function(data) {
    if(data.error) {
      return;
    }
    var global_prev = data.global_chat_prev;
    var page_prev = data.page_chat_prev;
    for(var g = 0; g < global_prev.length; g++) {
      var chat = global_prev[g];
      var type = chatType(chat.registered, chat.nickname, chat.realUsername);
      addChat(chat.location, chat.id, type, chat.nickname,
        chat.message, chat.realUsername, chat.op, chat.admin, chat.staff, chat.color, chat.date, chat);
    }
    for(var p = 0; p < page_prev.length; p++) {
      var chat = page_prev[p];
      var type = chatType(chat.registered, chat.nickname, chat.realUsername);
      addChat(chat.location, chat.id, type, chat.nickname,
        chat.message, chat.realUsername, chat.op, chat.admin, chat.staff, chat.color, chat.date, chat);
    }
  },
  chatdelete: function(data) {
    // subject to change
    var id = data.id; // client id
    var time = data.time;
    removeChatByIdAndDate(id, time);
  },
  cmd: function(data) {
    w.emit("cmd", data);
  },
  cursor: function(data) {
    w.emit("guestCursor", data);
    var channel = data.channel;
    var hidden = data.hidden;
    var position = data.position;
    if(channel == w.socketChannel) return;
    if(hidden) {
      var csr = guestCursors[channel];
      if(!csr) return;
      var tileX = csr.tileX;
      var tileY = csr.tileY;
      delete guestCursors[channel];
      var tilePos = tileY + "," + tileX;
      if(guestCursorsByTile[tilePos]) {
        delete guestCursorsByTile[tilePos][channel];
        if(Object.keys(guestCursorsByTile[tilePos]).length == 0) {
          delete guestCursorsByTile[tilePos];
        }
      }
      w.setTileRedraw(tileX, tileY, true);
    } else if(position) {
      var csr = guestCursors[channel];
      if(!csr) {
        csr = {};
        guestCursors[channel] = csr;
      } else {
        var prevTilePos = csr.tileY + "," + csr.tileX;
        if(guestCursorsByTile[prevTilePos]) {
          delete guestCursorsByTile[prevTilePos][channel];
        }
        if(Object.keys(guestCursorsByTile[prevTilePos]).length == 0) {
          delete guestCursorsByTile[prevTilePos];
        }
        w.setTileRedraw(csr.tileX, csr.tileY, true);
      }
      csr.tileX = position.tileX;
      csr.tileY = position.tileY;
      csr.charX = position.charX;
      csr.charY = position.charY;
      tilePos = csr.tileY + "," + csr.tileX;
      if(!guestCursorsByTile[tilePos]) {
        guestCursorsByTile[tilePos] = {};
      }
      guestCursorsByTile[tilePos][channel] = csr;
      w.setTileRedraw(csr.tileX, csr.tileY, true);
    }
  },
  error: function(data) {
    var code = data.code;
    var message = data.message;
    switch(code) {
      case "CONN_LIMIT": // too many connections
      case "INVALID_ADDR": // invalid websocket path
      case "NO_EXIST": // world does not exist
      case "NO_PERM": // no permission to access world
        console.log("Received error from the server with code [" + code + "]: " + message);
        if(code == "NO_PERM") {
          w.doAnnounce("Access to this world is denied. Please make sure you are logged in.", "err_access");
        } else if(code == "CONN_LIMIT") {
          w.doAnnounce("You have too many connections.", "err_limit");
        }
        break;
      case "PARAM": // invalid parameters in message
        break;
    }
  }
};

function begin() {
  getStoredConfig();
  getStoredNickname();

  makeCoordLinkModal();
  makeCoordGotoModal();
  makeURLModal();
  makeColorModal();
  makeSelectionModal();

  addColorShortcuts();
  updateColorPicker();

  if(state.announce) {
    w.doAnnounce(state.announce);
  }

  if(window.location.hostname == "www.ourworldoftext.com") {
    w.doAnnounce("You are currently under the 'www' subdomain. <a href=\"https://ourworldoftext.com\">You may want to go here instead.</a>", "www_warn");
  }

  buildMenu();
  updateMenuEntryVisiblity();
  w.regionSelect.onselection(handleRegionSelection);

  w.protectSelect.onselection(protectSelectionStart);
  w.protectSelect.oncancel(protectSelectionCancel);
  w.protectSelect.tiled = true;

  //w.fetchUnloadedTiles(); // (MOD)
  w.fixFonts("legacycomputing");

  browserZoomAdjust(true);

  manageCoordHash();
  /*getWorldProps(state.worldModel.name, "style", function(style, error) { // (MOD) (BEGIN)
    if(error) {
      console.warn("An error occurred while loading the world style");
    } else {
      styles = style;
    }
    checkTextColorOverride();
    menu_color(styles.menu);
    loadBackgroundData(function() {
      owotCtx.clearRect(0, 0, owotWidth, owotHeight);
      renderLoop();
      createSocket();
      elm.loading.style.display = "none";
    }, function() {
      w.redraw();
    });
  });*/ // (MOD) (END)
  
  // (MOD) (BEGIN)
  setTimeout(function() {
    styles = defaultStyles();
    checkTextColorOverride();
    menu_color(styles.menu);
    
    owotCtx.clearRect(0, 0, owotWidth, owotHeight);
    renderLoop();
    createSocket();
    elm.loading.style.display = "none";
  }, 1);
  // (MOD) (END)
  
}

begin();

    </script>
    <script>
// (EXT)
var atcInfo = document.createElement("label");
atcInfo.style.display = "none";
atcInfo.innerText = "Press CTRL and move your mouse around to clear tiles. " + 
  "This will clear all tiles where the mouse cursor is located.";
atcInfo.style.backgroundColor = "black";
atcInfo.style.color = "white";
atcInfo.style.position = "absolute";
atcInfo.style.left = "0px";
atcInfo.style.top = "0px";
document.body.appendChild(atcInfo);

var admclrActivated = document.createElement("label");
admclrActivated.innerText = " [ ACTIVE ]";
admclrActivated.style.backgroundColor = "black";
admclrActivated.style.color = "red";
admclrActivated.style.fontWeight = "bold";
admclrActivated.style.display = "none";
atcInfo.appendChild(admclrActivated);

menu.addCheckboxOption("Clear Tiles", function() {
  // activated
  atcInfo.style.display = "";
  admclr.activated = true;
}, function() {
  // deactivated
  atcInfo.style.display = "none";
  admclr.activated = false;
  tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = "";
  w.setTileRedraw(currentPosition[0], currentPosition[1]);
});

var admclr = {
  activated: false,
  lastPos: null,
  ctrlDown: false,
  color: "#00FF00",
  renderTile: function(preserveLastPos) {
    if(tiles[currentPosition[1] + "," + currentPosition[0]]) {
      // change color to red
      tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = admclr.color;
      if(!preserveLastPos)
        admclr.lastPos = [currentPosition[0], currentPosition[1]];
      // re-render the tile
      w.setTileRender(currentPosition[0], currentPosition[1]);
    }
  },
  handleClear: function(x, y) {
    network.clear_tile(x, y);
  }
};

// ctrl is pressed
function keydown_admclr(e) {
  if(!admclr.activated) return;
  if(admclr.ctrlDown) return;
  if(e.ctrlKey) {
    admclr.ctrlDown = true;
    admclrActivated.style.display = "";
    admclr.color = "#FF0000";
    admclr.renderTile(true);
    admclr.handleClear(currentPosition[0], currentPosition[1]);
  }
}
document.body.addEventListener("keydown", keydown_admclr);

// mouse is moved
function mousemove_admclr(e) {
  if(!admclr.activated) return;
  if(admclr.lastPos) {
    /*
      currentPosition is the built in way to get the current tile and char position from
      where your mouse cursor is.
      currentPosition = [tileX, tileY, charX, charY]
    */
    // do no re-render if the cursor moved but is still inside the same tile
    if(admclr.lastPos[0] == currentPosition[0] && admclr.lastPos[1] == currentPosition[1]) {
      return;
    }
    var tileBackColorRes = tiles[admclr.lastPos[1] + "," + admclr.lastPos[0]];
    if(tileBackColorRes) tileBackColorRes.backgroundColor = "";
    // re-render the tile
    w.setTileRender(admclr.lastPos[0], admclr.lastPos[1]);
  }
  // if tile exists
  admclr.renderTile();
  if(admclr.ctrlDown) {
    admclr.handleClear(currentPosition[0], currentPosition[1]);
  }
}
document.body.addEventListener("mousemove", mousemove_admclr);

// a key is released
function keyup_admclr(e) {
  if(!admclr.activated) return;
  admclr.ctrlDown = false;
  admclrActivated.style.display = "none";
  admclr.color = "#00FF00";
  // remove color of tile
  if(admclr.lastPos) {
    tiles[admclr.lastPos[1] + "," + admclr.lastPos[0]].backgroundColor = "";
    // re-render the tile
    w.setTileRender(admclr.lastPos[0], admclr.lastPos[1]);
  }
  tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = "";
  w.setTileRender(currentPosition[0], currentPosition[1]);
  admclr.lastPos = null;
}
document.body.addEventListener("keyup", keyup_admclr);

client_commands.search = function(args) {
  var phrase = args.join(" ");
  if(!phrase) return;
  clientChatResponse("Looking for phrase: \"" + phrase + "\"");
  function doSearch() {
    searchLookup({
      text: phrase
    }, function(val) {
      val = (val * 100).toFixed(2);
      clientChatResponse("Searching... (" + val + "%)");
    }).then(function(coords) {
      var data = "Results:<br>";
      for(var i = 0; i < coords.length; i++) {
        var pos = coords[i];
        var scr = "javascript:searchTeleportTo(" + pos[0] + ", " + pos[1] + ", " + pos[2] + ", " + pos[3] + ", " + phrase.length + ")";
        var sty = "text-decoration: underline; color: blue;";
        data += "<a href=\"" + scr + "\" style=\"" + sty + "\">(" + pos[0] + ", " + pos[1] + ") [" + pos[2] + ", " + pos[3] + "]</a><br>";
      }
      addChat(null, 0, "user", "[ Client ]", data, "Client", true, false, false, null, getDate());
    });
  }
  doSearch();
}

    </script>
    <script>
// (EXT)
window.OWOTSearchUtil = true;
w.on("fetch", function(data) {
  var tiles = data.tiles;
  var tileCount = Object.keys(tiles).length;
  for(var i = 0; i < searchAwaitingBlocks.length; i++) {
    var context = searchAwaitingBlocks[i];
    var x1 = context[0];
    var y1 = context[1];
    var x2 = context[2];
    var y2 = context[3];
    var res = context[4];
    var areaSize = (x2 - x1 + 1) * (y2 - y1 + 1);
    if(tileCount != areaSize) continue;
    var isNotVerified = false;
    for(var tpos in tiles) {
      var pos = tpos.split(",");
      var tileX = parseInt(pos[1]);
      var tileY = parseInt(pos[0]);
      var inRange = x1 <= tileX && tileX <= x2 && y1 <= tileY && tileY <= y2;
      if(!inRange) {
        isNotVerified = true;
        break;
      }
    }
    if(isNotVerified) continue;
    searchAwaitingBlocks.splice(i, 1);
    i--;
    res(tiles);
  }
});
var searchAwaitingBlocks = [];
function searchGetBlock(x1, y1, x2, y2) {
  return new Promise(function(res) {
    network.fetch([{
      minX: x1, minY: y1,
      maxX: x2, maxY: y2
    }]);
    searchAwaitingBlocks.push([x1, y1, x2, y2, res]);
  });
}
function searchWait(ms) {
  return new Promise(function(res) {
    setTimeout(res, ms);
  });
}
function searchText(rows, text, startX) {
  var results = []; // [tileX, tileY, charX, charY]
  for(var r in rows) {
    var trow = rows[r];
    var tileY = parseInt(r);
    for(var y = 0; y < 8; y++) {
      var row = trow[y];
      var currentIndex = 0;
      while(true) {
        var lookup = row.indexOf(text, currentIndex);
        if(lookup == -1) break;
        currentIndex = lookup + text.length;
        results.push([
          startX + Math.floor(lookup / 16), tileY,
          lookup % 16, y
        ]);
      }
    }
  }
  return results;
}
function searchHighlightResult(tileX, tileY, charX, charY, length) {
  var coords = [];
  var tilesLoaded = true;
  for(var i = 0; i < length; i++) {
    coords.push([tileX, tileY, charX, charY]);
    if(!Tile.loaded(tileX, tileY)) {
      tilesLoaded = false;
    }
    charX++;
    if(charX >= 16) {
      charX = 0;
      tileX++;
    }
  }
  if(!tilesLoaded) {
    var loadTimeout;
    var loadInterval = setInterval(function() {
      var loaded = true;
      for(var i = 0; i < coords.length; i++) {
        if(!Tile.loaded(coords[i][0], coords[i][1])) {
          loaded = false;
        }
      }
      if(loaded) {
        clearInterval(loadInterval);
        clearTimeout(loadTimeout);
        highlight(coords, true);
      }
    }, 1000 / 4);
    loadTimeout = setTimeout(function() {
      clearInterval(loadInterval);
    }, 5000);
  } else {
    highlight(coords, true);
  }
}
function searchTeleportTo(tileX, tileY, charX, charY, length) {
  var posX = tileX * 16 + charX + Math.floor(length / 2);
  var posY = tileY * 8 + charY;
  w.doGoToCoord(-(posY / (8 * 4)), posX / (16 * 4));
  searchHighlightResult(tileX, tileY, charX, charY, length);
}
async function searchLookup(conf, progress_cb) {
  var text = conf.text;
  var pos = w.getCenterCoords();
  var tileX = Math.floor(pos[1]);
  var tileY = Math.floor(pos[0]);
  var blockSize = 20;
  var startX = tileX - 25;
  var startY = tileY - 25;
  var endX = tileX + 25;
  var endY = tileY + 25;
  var areaWidth = endX - startX + 1;
  var areaHeight = endY - startY + 1;
  var areaSegWidth = Math.ceil(areaWidth / blockSize);
  var areaSegHeight = Math.ceil(areaHeight / blockSize);
  var areaSegTotal = areaSegWidth * areaSegHeight;
  var lastReq = 0;
  var reqCount = 0;
  var searchData = [];
  for(var y = 0; y < areaSegHeight; y++) {
    var rows = {};
    for(var x = 0; x < areaSegWidth; x++) {
      var x1 = startX + (x * blockSize);
      var y1 = startY + (y * blockSize);
      var x2 = x1 + blockSize - 1;
      var y2 = y1 + blockSize - 1;
      if(x2 > endX) x2 = endX;
      if(y2 > endY) y2 = endY;
      var time = Date.now();
      var timeDiff = time - lastReq;
      if(timeDiff >= 0 && timeDiff < 1) {
        await searchWait(1 - timeDiff);
      }
      var tiles = await searchGetBlock(x1, y1, x2, y2);
      lastReq = Date.now();
      reqCount++;
      if(typeof progress_cb == "function") {
        progress_cb(reqCount / areaSegTotal);
      }
      for(var ty = y1; ty <= y2; ty++) {
        if(!rows[ty]) {
          rows[ty] = ["", "", "", "", "", "", "", ""];
        }
        var row = rows[ty];
        for(var tx = x1; tx <= x2; tx++) {
          var cont = tiles[ty + "," + tx];
          if(!cont) {
            for(var by = 0; by < 8; by++) {
              row[by] += " ".repeat(16);
            }
            continue;
          }
          if(!conf.norm) {
            cont = w.split(cont.content);
          } else {
            cont = w.split(cont.content, false, false, true);
          }
          for(var cx = 0; cx < 128; cx++) {
            var rowNum = Math.floor(cx / 16);
            row[rowNum] += cont[cx].toLowerCase();
          }
        } 
      }
    }
    var search = searchText(rows, text, startX);
    for(var i = 0; i < search.length; i++) {
      searchData.push(search[i]);
    }
  }
  return searchData;
}
    </script>
    <script>
// (EXT)
function exportWorld() {
  var filename = "export" + Date.now() + ".json"
  var down = document.createElement("a");
  down.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(JSON.stringify(tile_database)));
  down.setAttribute("download", filename);
  if (document.createEvent && "download" in down && !window.navigator.msSaveBlob) {
    var event = document.createEvent("MouseEvents");
    event.initEvent("click", true, true);
    down.dispatchEvent(event);
  } else if("download" in down && !window.navigator.msSaveBlob) {
    down.click();
  } else if(window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(new Blob([JSON.stringify(tile_database)], {type: "octet/stream"}), filename);
  }
}
    </script>
    <script>
// (EXT)
import_world.onchange = function(e) {
  var files = import_world.files;
  for(var i = 0; i < files.length; i++) {
    var file = files[i];
    var fr = new FileReader();
    fr.onload = function(res) {
      var data = JSON.parse(res.target.result);
      if(Array.isArray(data)) { // world-download export
        for(var t = 0; t < data.length; t++) {
          var tile = data[t];
          var content = tile.content;
          var tileX = tile.tileX;
          var tileY = tile.tileY;
          var properties = tile.properties;
          var writability = tile.writability;
          properties = JSON.parse(properties);
          properties.writability = writability;
          tile_database[tileY + "," + tileX] = {
            content: content,
            properties: properties
          };
        }
      } else { // offlineOWOT export
        for(var tile in data) {
          tile_database[tile] = data[tile];
        }
      }
      clearTiles(true);
      w.fetchUpdates();
    }
    fr.readAsText(file);
  }
}
    </script>
    <script>
    var x = 0;
var y = 0;
var g = getCharInfoXY;
menu.addOption("Gravity", () => {
let e = RegionSelection();
e.init();
e.onselection((a,b) => {
x = [a[0]*16+a[2], b[0]*16+b[2]];
y = [a[1]*8+a[3], b[1]*8+b[3]];
});
e.startSelection();
});
menu.addOption("No gravity", () => {
x = 0;
y = 0;
});
menu.addOption("Velocity", () => {
clearInterval(s);
s = setInterval(tick,1000/prompt("Set the falling speed of the chars",10));
});
tick = () => {
if (x == 0 || y == 0) return;
for (let i = 1; i < y[1]-y[0]+1; i++) {
for (let j = 0; j < x[1]-x[0]+1; j++) {
if (g(x[0]+j,y[1]-i+1).char == " " && g(x[0]+j,y[1]-i).char != " ") {
let char = g(x[0]+j,y[1]-i);
if (char.decoration == null) char.decoration = {
bold: 0,
italic: 0,
under: 0,
strike: 0
};
writeCharToXY(char.char,char.color,x[0]+j,y[1]-i+1,char.bgColor,char.decoration.bold,char.decoration.italic,char.decoration.under,char.decoration.strike);
writeCharToXY(" ",0,x[0]+j,y[1]-i);
}
}
}
flushWrites();
}
var s = setInterval(tick,100);
    </script>
  </body>
</html>